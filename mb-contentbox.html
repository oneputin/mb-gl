<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="routing-behavior.html">

<!--
    `mb-contentbox`

    `quickformat` - object:

            quickmap[mbid] = {
                "layer": {
                    "type": "line",
                    "id": mbid,
                    "source": mbid
                },
                "srcdata": srcdata,
                "raw": 1
            };
    
    @demo demo/routingtracks.html 
-->

<dom-module id="mb-contentbox">

    <template>

        <style>
        </style>

    </template>

    <script>
        Polymer({
            is: 'mb-contentbox',

            properties: {
                /**
                 *  map-object available for query and manipulation outside 
                 */
                map: {
                    type: Object,
                    observer: "onMapSetup"
                },

                mbid: {
                    type: String,
                    observer: 'styleChanged'
                },
                // 
                contentbox: {
                    type: Object
                },
                // Old content 
                _contentbox: {
                    type: Object
                },
                // features of (all) jsoncontent-layers loaded
                // !! grouped by layer !!
                mapcontent: {
                    type: Object,
                    value: {},
                    notify: true
                },
            },

            observers: [
                'mapContentRefresh(contentbox.*)',
            ],

            behaviors: [
                Mbb.MapBehavior,
                Mbb.RoutingBehavior
            ],

            ready: function() {
                // console.log("READY: mb-contentbox");
            },

            /**
             * Create/Replaces all mb-Layers 
             * delivered within contentbox-container
             */
            mapContentRefresh: function(contentbox) {
                if (!this.map || !this.checked) return;
                console.log("mapContent UPDATE from ", contentbox); 
                // remove old content
                this._mapContentPrepare(this._contentbox, "delete");
                // add new content
                this._contentbox = contentbox; 
                this._mapContentPrepare(contentbox); 
            },    

            // ADD/REMOVE all objects of contentbox as mb-layers
            _mapContentPrepare: function(contentbox, deleteflag) {    
                if (!contentbox || !Object.keys(contentbox).length) return;
                if (contentbox.path == 'contentbox') contentbox = contentbox.value;
                // console.log("START mapContentPrepare", contentbox);

                var scope = this,
                    map = scope.map;

                // Generic HILITE-function based on "id-Filter"	
                function featureHilite(e, layerid) {

                    if (!map.getLayer(layerid)) return;
                    if (!map.getLayer(layerid + "-hover")) return;

                    // 
                    var hilayerid, hifilter;

                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [layerid]
                    });

                    // CHANGE cursor temporarily
                    map.getCanvas().style.cursor = (features.length) ? 'pointer' : ''; // crosshair';

                    if (features.length) {  // Apply HILITE-FILTER  
                    	
                        // var trackInfo = scope.trackGetInfo(features[0], layerid);
                        var fkeys = scope.guessFeatureKeys(features[0]); 
                        // scope.popupOnMap(trackInfo.html);

                        if (!fkeys) {

                             console.log("HILITING in " + layerid + ":", features[0]);
                        
                        } else {    // Filtering the HOVER-Layer
                            
                            hifilter = ["==", fkeys[0], fkeys[1]] ; // trackInfo[keyname]];
                            // console.log("hi " + layerid + ":", trackInfo.length+" km");

                            hilayerid = layerid + "-hover";
                           
                            map.setFilter(hilayerid, hifilter);
                        }

                    } else {  // remove HILITE filter 
                        
                        map.setFilter(layerid + "-hover", ["==", "name", ""]);
                    
                    }

                }

                // Track-Select 
                //   - zooms to the track
                //   - show start/stop based on "id-Filter"	
                function featureSelect(e, layerid) {
                    // console.log("featureSelect in ", layerid); 

                    if (!map.getLayer(layerid)) return;
                    // if (!map.getLayer(layerid + "-select")) return;

                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [layerid]
                    });

                    if (!features || !features.length) return;  
                        
                    scope.tracksHilite(features, layerid);
                }

                // Layer that occurs on-mouse-hover only 
                function createHiliteLayer(layertemplate, hitype) {
                    
                    var lhilite = {},// layertemplate,
                        templateid = layertemplate.id + "-" + hitype;
                    // console.log("createHiliteLayer for", templateid);

                    if (hitype == "nodes") { // sonderfall
                        
                       lhilite = {
                            "type": "symbol",
                            "id": templateid,
                            "source": templateid,
                            // "source": "",

                            "layout": {
                                "icon-image": "{icon}-15",
                                "text-field": "{title}",
                                "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                "text-offset": [0, 0.6],
                                "text-anchor": "top"
                            },
                            "paint": {
                                "text-halo-color": "#ffffff",
                                "text-halo-width": 6,
                                "text-color": "#ff0000"
                            }
                       };
                       return lhilite; 
                    } 
                    
                    // Copy most properties from source template 
                    // add some specific styling

                    basetype = layertemplate.type,

                    Object.keys(layertemplate).forEach(function(k) {
                        lhilite[k] = layertemplate[k];
                    })

                    lhilite.id = templateid ;
                    lhilite.filter = ["==", "id", ""];

                    var linecolor, linewidth, lineopacity, linedasharray;

                    if (hitype == "hover") {
                        linecolor = "#FF0000";
                        linewidth = 5;
                        lineopacity = 1;
                    } else if (hitype=="trace")  {
                        linecolor = "#000000";
                        linewidth = 3;
                        lineopacity = 0.7;
                        linedasharray = [4,4];  
                    }

                    lhilite.paint = {
                        "line-color": linecolor,
                        "line-width": linewidth,
                        "line-opacity": lineopacity,
                    }
                    if (linedasharray) {
                        lhilite.paint["line-dasharray"] = linedasharray;
                    } 

                    return lhilite;
                }

                // Add temporary paint-properties 
                // for easy identification of features (line-width, random colors)
                function rawBeautify(layerObject) {

                    var srcdata = layerObject.srcdata;

                    var lookuplist = [], paintObj;

                    srcdata.features.forEach(function(f) {
                        var col = f.properties.color;
                        lookuplist.push([col, col]);
                    });
                    paintObj = {
                        "line-width": 3,
                        "line-color": {
                            property: 'color',
                            type: 'categorical',
                            stops: lookuplist
                        }
                    }; // console.log("rawBeautify", paintObj);
                    
                    layerObject.layer.paint = paintObj;

                    return layerObject.layer;
                }

                // create linear list of features 
                // suitable for "menu-generation"
                function getFeatures(layerData, layername, longtitle) {

                    var flist = [],
                        fitem = {},
                        id, title;
                    if (!layerData || !layerData.features) return flist;

                    layerData.features.forEach(function(f) {
                        id = f.id;
                        if (!id) id = f.properties.name;
                        if (!id) id = f.properties.time;
                        // Typische Nachbearbeitung
                        id = id.replace("ACTIVE LOG:", "");
                        title = id.replace(/-/g, "_");

                        if (longtitle) title = layername + "_" + title;
                        title = title.replace(/ /g, "");

                        fitem = {
                            "layer": layername,
                            "id": id,
                            "title": title,
                            "feature": f
                        };
                        flist.push(fitem);
                    })

                    return flist;
                }

                // Create (multiple) layers to create "" 
                function getQuickTemplates(layerObject) {

                    var layerTemplates = [],
                        layerTemplate = layerObject['layer'];

                    if (layerTemplate) layerTemplates.push(layerTemplate);

                    // Insert BELOW main layer 
                    if (layerObject['bglayer']) {
                        layerTemplates.splice(0, 0, layerObject['bglayer']); // !!! 
                    }

                    if (layerObject['selectlayer']) {
                       
                        layerObject['selectlayer'].forEach(function(l) {
                            layerTemplates.push(l);
                        });

                    } else if (layerTemplate) { // "Standardisierte" HILITE-Layers
                        
                        let hoverTemplate = createHiliteLayer(layerTemplate, "hover");
                        if (hoverTemplate) layerTemplates.push(hoverTemplate);

                        let traceTemplate = createHiliteLayer(layerTemplate, "trace");
                        if (traceTemplate) layerTemplates.push(traceTemplate);

                        // another type 
                        let nodeTemplate = createHiliteLayer(layerTemplate, "nodes");
                        if (nodeTemplate) layerTemplates.push(nodeTemplate);
                    }

                    return layerTemplates;
                }

                // 
                function addMapContent(layername, layerObject){

                    var layerData = layerObject.srcdata;
                    if (!layerData) return ; 

                    var layerSource = map.getSource(layername),
                        mapLayer = map.getLayer(layername);

                    // 1.A. (Re)Set datasources for all linear presentations
                    if (!layerSource) {

                        map.addSource(layername, {
                            "type": "geojson",
                            "data": layerData
                        });
                        layerSource = map.getSource(layername);

                        // console.log("SRC", layername, layerData, layerSource);
                    } else {
                        // 1.B  CHECK 
                        if (true) {
                            layerSource.setData(layerData);
                        }
                    }


                    // 1.C. (Re)Create layer(s) 
                    if (!mapLayer) {
                        // console.log("layerTemplates for " + layername, layerTemplates, layerSource);
                        var layerTemplates = getQuickTemplates(layerObject);
                
                        layerTemplates.forEach(function(template) {

                            if (!map.getLayer(template.id)) {

                                // console.log("adding layer", template);
                                
                                if ((template.type == "symbol") && template.source) { 
                                    // console.log("Set placeholder-source !!", template.source); 
                                    if (!map.getSource(template.source)) {   
                                        map.addSource(template.source, {
                                            "type": "geojson",
                                            "data": { "type": "Point", "coordinates": [0, 0] }
                                        });
                                    }    
                                }

                                map.addLayer(template);
                            }
                        });

                        mapLayer = map.getLayer(layername);
                    }

                    // Check in ??? 
                    if (mapLayer) {
                        /*var features = map.querySourceFeatures(layername, {
                            sourceLayer: 'original',
                            filter: null
                        });
                        if (features.length) {
                            console.log("Loaded "+features.length + " features of layer [" + layername+ "]"); // , features, layerSource);
                        }*/    
                        return layerData; 
                    }

                }

                function removeMapContent(layerObject) {

                    var quickTemplates = getQuickTemplates(layerObject);
                    // console.log("removing quickContentLayers", quickTemplates);  
                    
                    quickTemplates.forEach(function(template) {
                        var qlayername = template.id,
                            qlayer = map.getLayer(qlayername);

                        // console.log("remove qlayer", qlayername, qlayer) ;                        
                        if (qlayer) {
                            map.removeLayer(qlayername);
                        }  
                   });  

                   quickTemplates.forEach(function(template) { 
                        var srcid = template.source,
                            qsrc = map.getSource(srcid);
                        // console.log("remove qsource ", srcid, qsrc);
                        if (qsrc) {
                            map.removeSource(srcid);
                        }   
                    })    
                }

                // --------------------------------------------------

                var mapcontent = {};
                
                var contentboxLayers = Object.keys(contentbox);   // console.log("Refreshing quickmap-layers", contentboxLayers);

                contentboxLayers.forEach(function(layername, j) {

                    function hiliter(e) {
                        featureHilite(e, layername);
                    }

                    function selector(e) {
                        featureSelect(e, layername);
                    }

                    var layerObject = contentbox[layername];

                    // Option 
                    if (deleteflag) { // REMOVE layers (on demand) 
                        // console.log("DELETE qlayer " + layername, layerObject);
                        removeMapContent(layerObject); 

                        map.off("mousemove", hiliter)
                        map.off("click", selector)
                        //return; 
                    
                    }   else {        // CREATE / REFRESH contentbox
    
                        if (layerObject.raw) rawBeautify(layerObject);

                        // console.log("SETUP qlayer " + layername, layerObject);
                        
                        var layerData = addMapContent(layername, layerObject); 

                        if (layerData) {

                            map.on("mousemove", hiliter)
                            map.on("click", selector)

                            // GET all source-features of the basic layer 
                            var contentfeatures = getFeatures(layerData, layername);

                            // Add layer-features to mapcontent
                            if (contentfeatures.length) {
                                // console.log("contentfeatures of " + layername, contentfeatures);
                                mapcontent[layername] = contentfeatures;
                            }
                        }                        
                    }

                }.bind(this));

                // console.log("DONE mapContentPrepare: " + deleteflag, mapcontent);
                this.mapcontent = mapcontent;

            },

            // rarely used 
            onMapSetup: function(map) {
                if (!map || !this.contentbox) return;
                // console.log("FIRST prepare mapcontent from", this.contentbox);
                this.mapContentRefresh(this.contentbox);
            },

            // refresh contentbox on changed basemap
            styleChanged: function(mbid, mbidold) {
                this.mapContentRefresh(this.contentbox);
            },

        })
    </script>
</dom-module>                  