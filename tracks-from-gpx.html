<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../kml-json/kml-json.html">

<link rel="import" href="mb-tools-behavior.html">

<!--<link rel="import" href="routing-behavior.html">-->


<!--
`tracks-from-gpx`
Interface for import/export of tracking data from handheld gps-devices

Optional: create quick-preview-data 

@demo demo/routinghandheld.html 
-->

<dom-module id="tracks-from-gpx">

<template>

    <style is="custom-style">
        :host {
            position: absolute;
            display: none; /*inline-block;*/
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <kml-json 
        url="[[xmlurl]]" 
        query="[[xmlquery]]" 
        geojson="{{rawdata}}">
    </kml-json>

</template>

<script>
    Polymer({
        is: 'tracks-from-gpx',

        properties: {

            srcmeta: {
                type: Object,
            },

            xmlurl: {
                type: String
            },

            xmlquery: {
                type: Object,
                value: {
                    "tags": "Track",
                    "structure": "doc"
                }
            },

            usepreview: {
                type: Boolean,
                value: false
            },

            rawdata: {
                type: Object,
                value: {}
                //observer: 'getRawTracks'
            },

            // can be processed in "quickViewer"
            quickmap: {
                type: Object,
                notify: true
            },

            // to be processed in "trackAnimation"
            trackdata: {
                type: Array,
                value: [],
                notify: true
            }

        },

        behaviors: [
            Polymer.ToolsBehavior,
        ],

        observers: [
            'triggerQuery(srcmeta.*)',
            'getRawTracks(rawdata, srcmeta, usepreview)'
        ],

        attached: function() {
            // console.log("target attached");
        },

        triggerQuery: function(srcmeta) { // trigger new dataquery !!
            if (srcmeta.path == 'srcmeta') srcmeta = srcmeta.value;
            if (srcmeta.type != "gpx") return;  
            // set parameters for data-fetch with <kml-json>
            this.xmlurl = srcmeta.url;
            if (srcmeta.xmlquery) this.xmlquery = srcmeta.xmlquery;
        },
        
        // 
        getRawTracks: function(rawdata, srcmeta, usepreview) {
            if (!rawdata || !Object.keys(rawdata).length) return; 
            // console.log("GPX-data, raw tracks", rawdata);

            // 1. Simplify list of "simple" tracks 
            var rawtracks = this.simpleTrackdata(rawdata);
            // console.log("GPX-data, mode, flat tracks", rawtracks);

            if (usepreview) { 
                // 3. CREATE/SUPPLY quickMapObject to quickViewer
                // console.log(rawtracks);  
                var quickmap = this.quickmapCreate(rawtracks);
               
               if (quickmap) {  // console.log("GPX-data to view", quickmap);

                    this.quickmap = quickmap;

                    this.trackdata = rawtracks.features;
                
                }    

            } else {  
                // 2. CREATE/SUPPLY list of tracks to animation-processor 
                var routetracks = this.createRouteTracks(rawtracks.features);
                if (routetracks.length) {
                    // console.log("GPX-data, routes",  routetracks);
                    this.trackdata = routetracks;
                }    
            }    
        },

        // 
        createRouteTracks: function(rawdata, minTrackLength) {
            if (!minTrackLength) minTrackLength=5; 
            var scope = this,
                routedata = [],
                trackpoints, tracktimes,
                route, tt, coordinates,
                type, id, title;

            function extractPnts(coords, tt) {
                // tracktimes = r.properties.coordTimes;
                var tp, trackpoints = [];
                if (!coords || !coords.length) return trackpoints;
                var dott, utc;
                coords.forEach(function(cc, j) {
                    dott = scope.trackTime(tt[j]);
                    utc = scope.utcTime(dott);
                    tp = {};
                    tp.coords = [cc[0], cc[1]]; // !!! mapbox
                    tp.z = cc[2];
                    tp.ab = dott;
                    tp.an = tp.ab;
                    tp.utc = utc;
                    trackpoints.push(tp);
                });

                return trackpoints;
            }

            if (rawdata.features) rawdata = rawdata.features;

            rawdata.forEach(function(r, i) {

                coordinates = r.geometry.coordinates;

                tracktimes = r.properties.coordTimes;

                type = r.geometry.type;

                if (type == "MultiLineString") {

                    coordinates.forEach(function(coords, j) {

                        if (coords.length > minTrackLength) {

                            tt = tracktimes[j];
                            id = tt[0];

                            trackpoints = extractPnts(coords, tt);
                            // console.log(id, coords, trackpoints);

                            route = {
                                "id": id,
                                "title": id,
                                "unitsystem": "metric",
                                "trackmode": true,
                                "nodes": trackpoints
                            };

                            routedata.push(route);
                        }
                    })

                } else { // 

                    id = r.properties.time;
                    title = r.properties.name;
                    if (!title) title = id;
                    title = title.replace("ACTIVE LOG:", "");

                    if (coordinates.length > minTrackLength) {

                        trackpoints = extractPnts(coordinates, tracktimes);

                        route = {
                            "id": id,
                            "title": title,
                            "unitsystem": "metric",
                            "trackmode": true,
                            "nodes": trackpoints
                        };

                        routedata.push(route);
                    }
                }

            })

            return routedata;
        },

        // Process tracks from GPX, KML
        simpleTrackdata: function(rawdata) {
            if (!rawdata) return; 

            var scope = this;
            var trackdata , mapboxlayer;

            // Split multiLineTracks into tracksegments 
            // that are addressable by "own" start-time 
            function jsonTrackSimplify(rawdata) {

                var segmentFeatures = [],
                    starttime;

                rawdata.features.forEach(function(f, i) {

                    coordinates = f.geometry.coordinates;

                    tracktimes = f.properties.coordTimes;

                    type = f.geometry.type;

                    if (type == "MultiLineString") {

                        coordinates.forEach(function(coords, j) {

                            var cc = JSON.parse(JSON.stringify(coords)); // .slice(0);
                            var tt = JSON.parse(JSON.stringify(tracktimes[j])); // .slice(0);

                            if (!starttime) starttime = tt[0];

                            var seg = {
                                "type": "Feature",
                                "geometry": {
                                    "type": "LineString",
                                    "coordinates": cc
                                },
                                "properties": {
                                    "coordTimes": tt,
                                    "name": tt[0],
                                    "time": tt[0],
                                    "color": scope.getRandomColor()
                                }
                            };

                            segmentFeatures.push(seg);
                        })

                    } else {

                        if (!starttime) starttime = tracktimes[0];
                        f.properties.color = scope.getRandomColor();
                        segmentFeatures.push(f);
                    }
                })

                var segdata = {
                    "time": starttime, // rawdata.time (probably time of gpxToJson-conversion)
                    "type": rawdata.type,
                    "features": segmentFeatures
                };

                return segdata;
            }

            trackdata = jsonTrackSimplify(rawdata);
            // console.log("flattenRawTracks, geojson-2", data)

            return trackdata;
        },

        // Process tracks from GPX, KML
        quickmapCreate: function(trackdata) {

            var quickmapObject,
                srcmeta = this.srcmeta; // console.log("quickmapCreate", srcmeta); 

            function jsonTrackToQuickview(srcdata, title) {

                if (!title) title = srcdata.time;
               
                var mapid = "tracks-" + title;

                quickmap = {};
                quickmap[mapid] = {
                    "layer": {
                        "type": "line",
                        "id": mapid,
                        "source": mapid
                    },
                    "srcdata": srcdata,
                    "raw": 1
                };
                return quickmap; 
            };

            // Create data for quickview of raw trackdata 
            // with "short as possible" id-entification of features 
            var title = srcmeta.key;
            if (!title) title = srcmeta.title;
            quickmapObject = jsonTrackToQuickview(trackdata, title); 
            
            // SUPPLY quickmap to viewing element 
            return quickmapObject;
            // if (quickmapObject) this.mapcontent = quickmapObject;

        }    

    });
</script>

</dom-module>