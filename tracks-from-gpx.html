<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../kml-json/kml-json.html">
<link rel="import" href="mb-content-behavior.html">
<!-- <link rel="import" href="mb-map-behavior.html"> -->
<link rel="import" href="mb-app-behavior.html">

<!--
`tracks-from-gpx`
Interface for import/export of tracking data from handheld gps-devices

Optional: create quick-preview-data 

@demo demo/routingtracks.html 
-->

<dom-module id="tracks-from-gpx">

<template>

    <style is="custom-style">
        :host {
            position: absolute;
            display: none; /*inline-block;*/
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <kml-json 
        url="[[_xmlurl]]" 
        query="[[_xmlquery]]" 
        geojson="{{_rawdata}}">
    </kml-json>

</template>

<script>
    Polymer({
        is: 'tracks-from-gpx',

        properties: {

            srcmeta: {
                type: Object,
            },

            logmode: {
                type: Boolean,
                value: false
            },

            trackdata : {
                type: Object,
                notify: true
            },

            _xmlurl: {
                type: String
            },

            _xmlquery: {
                type: Object,
                value: {}
            },
            // Query to be applied in kml-json 
            _basequery: {
                type: Object,
                value: {
                    "tags": "Track",
                    "structure": "doc"
                }
            },

            // json from document-IF
            _rawdata: {
                type: Object
            },

        },

        behaviors: [
            Mbb.AppBehavior,
            Mbb.ContentBehavior
        ],

        observers: [
            '_triggerQuery(srcmeta.*)',
            '_createTrackData(_rawdata, srcmeta, logmode)'
        ],

        attached: function() {
        },

        _triggerQuery: function(srcmeta) { // trigger new dataquery !!
            if (srcmeta.path == 'srcmeta') srcmeta = srcmeta.value;
            if (srcmeta.type != "gpx") {
                this.rawdata = null;
                return;
            }  // console.log("gpx-Query (meta)",srcmeta) ;
            
            // Join the xmlquery from basic and variable query-items
            var xmlquery = {};
            Object.assign(xmlquery, this._basequery); 
            if (srcmeta.xmlquery && Object.keys(srcmeta.xmlquery).length) {
                Object.assign(xmlquery, srcmeta.xmlquery);
            } // console.log("_triggerLog", srcmeta, xmlquery);
            // Trigger action 
            this._xmlquery = xmlquery; 
            this._xmlurl = srcmeta.url; // !! TRIGGER !!
        },
        
        // Convert raw gpx-json-data into 
        _createTrackData: function(rawdata, srcmeta, logmode) {
            
            this.debounce("track", function() {
                if (!rawdata || !Object.keys(rawdata).length) return; 
    
                // 1. Simplify list of "simple" tracks 
                var rawtracks = this._getRawData(rawdata);
                // console.log("GPX-data, mode, flat tracks", rawdata, rawtracks);

                // 2. 
                if (logmode) { // derive features for mb-visualization of rawTracks
                    // console.log("prepare quickmap of ", rawtracks);  
                    var rawtracks = this.createTrackLogs(rawtracks, srcmeta);
                    if (rawtracks) {  console.log("RAW track-data (gpx)", rawtracks);
                        this.trackdata = rawtracks;
                    }    

                } else {   // derive structures for mb-based animation of 'suitable' tracks
                    // console.log("prepare routedata", rawtracks);  
                    var trackroutes = this.createTrackRoutes(rawtracks); // .features);
                    if (trackroutes.length) {  console.log("RAW route-data (gpx)",  trackroutes);
                        // this.routedata = trackroutes;
                        this.trackdata = trackroutes;
                    }    
                }    
                // ** !! ** 
                this._rawdata = null; 

            }, 200);      
        },

        // Derive "raw tracks" from GPX, KML 
        _getRawData: function(rawdata) {
            if (!rawdata) return; 
            // console.log("_getRawData: rawdata=", rawdata);

            var scope = this;
            var trackdata , mapboxlayer;
            
            // enable processing of different input structures
            if (rawdata.features) rawdata = rawdata.features; 

            // Split multiLineTracks into tracksegments 
            // that can be identified by "own" start-time 
            function jsonTrackSimplify(rawdata) {

                var segmentFeatures = [],
                    coordinates, tracktimes, coordZ, 
                    starttime;

                rawdata.forEach(function(f, i) {
                    coordinates = f.geometry.coordinates;
                    tracktimes = f.properties.coordTimes;
                    coordz = f.properties.coordZ;
                    // console.log(i, f, coordinates, tracktimes, coordz); 

                    type = f.geometry.type;
                    if (type == "MultiLineString") {

                        coordinates.forEach(function(coords, j) {

                            var cc = JSON.parse(JSON.stringify(coords)); 
                            // property-arrays are structured identical to coords-array (same j)
                            var tt = JSON.parse(JSON.stringify(tracktimes[j])); 
                            var cz = JSON.parse(JSON.stringify(coordz[j]));  

                            if (!starttime) starttime = tt[0];

                            var seg = {
                                "type": "Feature",
                                "geometry": {
                                    "type": "LineString",
                                    "coordinates": cc
                                },
                                "properties": {
                                    "coordTimes": tt,
                                    "coordZ": cz,
                                    "name": tt[0],
                                    "time": tt[0],
                                    "color": scope.getRandomColor()
                                }
                            };

                            segmentFeatures.push(seg);
                        })

                    } else {

                        if (!starttime) starttime = tracktimes[0];

                        f.properties.color = scope.getRandomColor();

                        segmentFeatures.push(f);
                    }
                })

                var segdata = {
                    "time": starttime, // rawdata.time (probably time of gpxToJson-conversion)
                    "type": rawdata.type,
                    "features": segmentFeatures
                };

                return segdata;
            }

            trackdata = jsonTrackSimplify(rawdata);
            // console.log("Raw Tracks, geojson-flat", trackdata)

            return trackdata;
        },

        // Derive mb-content to view RAW trackdata 
        createTrackLogs: function(trackdata, srcmeta) {

            var trackLogObject;

            function trackLogCreate(srcdata, title, prefix) {

                if (!title) title = srcdata.time;
               
                var mapid = title,
                    quickmap = {};
    
                quickmap[mapid] = {
                    "layer": {
                        "type": "line",
                        "id": mapid,
                        "source": mapid
                    },
                    "srcdata": srcdata,
                    "raw": 1
                };
                return quickmap; 
            };

            // Create data for quickview of raw trackdata 
            // with "short as possible" id-entification of features 
            var title; //  = srcmeta.key;
            if (!title) title = srcmeta.title;
            trackLogObject = trackLogCreate(trackdata, title); 
            
            // SUPPLY quickmap to viewing element 
            return trackLogObject;
            // if (trackLogObject) this.mapcontent = trackLogObject;

        },

        // Derive mb-content usable by (gia-)animatation-api 
        createTrackRoutes: function(rawdata, minTrackLength) {
            if (!minTrackLength) minTrackLength=5; 
            var scope = this,
                routedata = [],
                trackpoints, tracktimes,
                route, tt, coordinates,
                type, id, title;

            function extractPnts(coords, tt) {
                // tracktimes = r.properties.coordTimes;
                var tp, trackpoints = [];
                if (!coords || !coords.length) return trackpoints;
                var dott, utc;
                coords.forEach(function(cc, j) {
                    dott = scope.trackTime(tt[j]);
                    utc = scope.utcTime(dott);
                    tp = {};
                    tp.coords = [cc[0], cc[1]]; // !!! mapbox
                    tp.z = cc[2];
                    tp.ab = dott;
                    tp.an = tp.ab;
                    tp.utc = utc;
                    trackpoints.push(tp);
                });

                return trackpoints;
            }

            if (rawdata.features) rawdata = rawdata.features;

            rawdata.forEach(function(r, i) {

                coordinates = r.geometry.coordinates;

                tracktimes = r.properties.coordTimes;

                type = r.geometry.type;

                if (type == "MultiLineString") {

                    coordinates.forEach(function(coords, j) {

                        if (coords.length > minTrackLength) {

                            tt = tracktimes[j];
                            id = tt[0];

                            trackpoints = extractPnts(coords, tt);
                            // console.log(id, coords, trackpoints);

                            route = {
                                "id": id,
                                "title": id,
                                "unitsystem": "metric",
                                "trackmode": true,
                                "nodes": trackpoints
                            };

                            routedata.push(route);
                        }
                    })

                } else { // other like LineString

                    id = r.properties.time;
                    title = r.properties.name;
                    if (!title) title = id;
                    title = title.replace("ACTIVE LOG:", "");

                    if (coordinates.length > minTrackLength) {

                        trackpoints = extractPnts(coordinates, tracktimes);

                        route = {
                            "id": id,
                            "title": title,
                            "unitsystem": "metric",
                            "trackmode": true,
                            "nodes": trackpoints
                        };

                        routedata.push(route);
                    }
                }

            })

            return routedata;
        }

    });
</script>

</dom-module>