<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../kml-json/kml-json.html">
<link rel="import" href="tracks-behavior.html">

<!--
`tracks-from-gpx`
Interface for import/export of tracking data from handheld gps-devices

Optional: create quick-preview-data 

@demo demo/routingtracks.html 
-->

<dom-module id="tracks-from-gpx">

<template>

    <style is="custom-style">
        :host {
            position: absolute;
            display: none; /*inline-block;*/
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <kml-json 
        url="[[_xmlurl]]" 
        query="[[_xmlquery]]" 
        geojson="{{_rawdata}}">
    </kml-json>

</template>

<script>
    Polymer({
        is: 'tracks-from-gpx',

        properties: {

            srcmeta: {
                type: Object,
            },

            routemode: {
                type: Boolean,
                value: false
            },

            trackdata : {
                type: Object,
                notify: true
            },

            _xmlurl: {
                type: String
            },

            _xmlquery: {
                type: Object,
                value: {}
            },
            // Query to be applied in kml-json 
            _basequery: {
                type: Object,
                value: {
                    "tags": "Track",
                    "structure": "doc"
                }
            },

            // json from document-IF
            _rawdata: {
                type: Object
            },

        },

        behaviors: [
            Mbb.TracksBehavior
        ],

        observers: [
            '_triggerQuery(srcmeta.*, routemode)',
            '_createTrackData(_rawdata, srcmeta, routemode)'
        ],

        attached: function() {
        },

        /**
         * routemode required to trigger requests
         */
        _triggerQuery: function(srcmeta, routemode) { // trigger new dataquery !!
            if (srcmeta.path == 'srcmeta') srcmeta = srcmeta.value;
            if (srcmeta.type != "gpx") {
                this.rawdata = null;
                return;
            }  
            
            // Join the xmlquery from basic and variable query-items
            var xmlquery = {};
            Object.assign(xmlquery, this._basequery); 
            if (srcmeta.xmlquery && Object.keys(srcmeta.xmlquery).length) {
                Object.assign(xmlquery, srcmeta.xmlquery);
            } // console.log("_triggerLog", srcmeta, xmlquery);
            // console.log("gpx-Query (meta)",srcmeta, xmlquery) ;
            
            // Trigger action 
            this._xmlquery = xmlquery; 
            this._xmlurl = srcmeta.url; // !! TRIGGER !!
        },
        
        // Convert raw gpx-json-data into 
        _createTrackData: function(rawdata, srcmeta, routemode) {

            this.debounce("track", function() {
                if (!rawdata || !Object.keys(rawdata).length) return; 
                // console.log("GPX-data, rawTracks", rawdata); // return;
    
                // 1. "Simplify" into list of "simple" tracks 
                var rawTracks = this._makeFlatTrackset(rawdata);
                // console.log("GPX-data, rawTracks, flatTracks", rawdata, rawTracks); return;

                // 2. 

                if (routemode) {  // derive structures for mb-based animation of 'suitable' tracks

                    var trackSet = this.createTrackSet(rawTracks, srcmeta.minlength); // .features);
                    if (trackSet.length) {  // console.log("RAW route-data (gpx)",  trackSet);
                        // this.trackSet = trackSet;
                        this.trackdata = trackSet;
                    }    

                } else {  // derive features for mb-visualization of rawTracks
                    // console.log("prepare quickmap of ", rawTracks);  
                    var trackLogs = this.createTrackLogs(rawTracks, srcmeta);
                    if (trackLogs) {  // console.log("RAW track-data (gpx)", trackLogs);
                        this.trackdata = trackLogs;
                    }    
                    // console.log("prepare trackSet from", rawTracks);  
                }    

                // ** !! ** 
                this._rawdata = null; 
                this._xmlurl = null;

            }, 200);      
        },

        // Derive "raw tracks" from geoJson originating from GPX, KML 
        _makeFlatTrackset: function(rawdata) {
            if (!rawdata) return; 
            // console.log("_makeFlatTrackset: rawdata=", rawdata);
            var scope = this;

            // get color in hex-format
            function getRandomColor() {
                var letters = '0123456789ABCDEF';
                var color = '#';
                for (var i = 0; i < 6; i++) {
                    color += letters[Math.floor(Math.random() * 16)];
                }
                return color;
            }
            // Split multiLineTracks into tracksegments 
            // that can be identified by "own" start-time 
            function jsonTrackSimplify(rawdata) {

                var segmentFeatures = [],
                    coordinates, tracktimes, coordElevs, 
                    starttime;

                rawdata.forEach(function(f, i) {

                    // All property-arrays are structured identical
                    coordinates = f.geometry.coordinates;
                    tracktimes = f.properties.coordTimes;
                    coordz = f.properties.coordElevs;
                    // console.log(f.geometry.type, i, f); // coordinates, tracktimes, coordz); 

                    type = f.geometry.type;
                    
                    if (type == "MultiLineString") {

                        coordinates.forEach(function(coords, j) {

                            // All property-arrays are structured identical to coords-array (same j)
                            var cc = JSON.parse(JSON.stringify(coords)); 
                            var tt = JSON.parse(JSON.stringify(tracktimes[j])); 
                            var cz = JSON.parse(JSON.stringify(coordz[j]));  

                            if (!starttime) starttime = tt[0];

                            var seg = {
                                "type": "Feature",
                                "geometry": {
                                    "type": "LineString",
                                    "coordinates": cc
                                },
                                "properties": {
                                    "coordTimes": tt,
                                    "coordElevs": cz,
                                    "id": tt[0],
                                    "name": tt[0],
                                    "time": tt[0],
                                    "color": getRandomColor()
                                }
                            };

                            segmentFeatures.push(seg);
                        })

                    } else {

                        if (!starttime) starttime = tracktimes[0];

                        f.properties.id = tracktimes[0];
                        f.properties.color = getRandomColor();

                        segmentFeatures.push(f);
                    }
                })

                var segdata = {
                    "time": starttime, // rawdata.time (probably time of gpxToJson-conversion)
                    "type": rawdata.type,
                    "features": segmentFeatures
                };

                return segdata;
            }

            // append vec-gis-properties 
            function addbbox(jsondata) {
                var bb, ffa, ffc=[];
                jsondata.features.forEach(function(f){
                    ffa = [];
                    f.geometry.coordinates.forEach(function(cc){
                        ffa.push(turf.point(cc.slice(0,2)));
                    })                        
                    bb = turf.bbox(turf.featureCollection(ffa)); // console.log("bb of:"+ffa.length, bb);
                    f.properties.bbox = bb;
                    ffc = ffc.concat(ffa);
                })
                var bbox = turf.bbox(turf.featureCollection(ffc));
                jsondata.bbox = bbox; // console.log("ADDBBOX", srcdata); 
                return jsondata;
            } 

            // var trackdata , mapboxlayer;
            
            // enable processing of different input structures
            if (rawdata.features) rawdata = rawdata.features; 

            // 1. Simplify
            var trackdata = jsonTrackSimplify(rawdata);

            // 2. SET basic vec-props
            addbbox(trackdata); 
            // console.log("Raw Tracks, geojson-flat", trackdata)

            return trackdata;
        },

        // Combine rawdata and metadata into contentObj 
        // (with mb-preview-properties) 
        createTrackLogs: function(rawdata, srcmeta) {
            // Create geojson-object for quickview of raw trackdata 
            // with "short as possible" id-entification of features 

            function trackLogCreate(srcdata, title) {
                
                var logId = srcdata.time;

                if(!logId) title;
                if(!logId) logId = srcdata.id;
                if(!logId) logId = srcdata.name;
                
                var trackLog = {};
                trackLog[logId] = {
                    "layer": {
                        "type": "line",
                        "id": logId,
                        "source": logId
                    },
                    "srcdata": srcdata,
                    "raw": 1
                };

                return trackLog; 
            };

            var title; //  = srcmeta.key;
            if (!title) title = srcmeta.title;
            
            var trackLogObject = trackLogCreate(rawdata, title); 
            
            return trackLogObject;

        },

        // Derive contentObj usable by animatation-api 
        // !! id of features = "first coord-time"
        createTrackSet: function(rawdata, minTrackLength) {
            if (!minTrackLength) minTrackLength = 5; 
            var scope = this,
                trackSet = [],
                trackpoints, tracktimes,
                track, tt, coordinates,
                type, id, title;

            // 
            function extractPnts(coords, tt) {
                // tracktimes = r.properties.coordTimes;
                var tp, trackpoints = [];
                if (!coords || !coords.length) return trackpoints;
                var dott, utc;
                coords.forEach(function(cc, j) {
                    dott = scope.trackTime(tt[j]);
                    utc = scope.utcTime(dott);
                    tp = {};
                    tp.coords = [cc[0], cc[1]]; // !!! mapbox
                    tp.z = cc[2];
                    tp.ab = dott;
                    tp.an = tp.ab;
                    tp.utc = utc;
                    trackpoints.push(tp);
                });

                return trackpoints;
            }
            // 
            if (rawdata.features) rawdata = rawdata.features;

            rawdata.forEach(function(r, i) {

                coordinates = r.geometry.coordinates;

                tracktimes = r.properties.coordTimes;

                type = r.geometry.type;

                if (type == "MultiLineString") {

                    coordinates.forEach(function(coords, j) {

                        if (coords.length > minTrackLength) {

                            tt = tracktimes[j];

                            id = tt[0];
                            //*********

                            trackpoints = extractPnts(coords, tt);
                            // console.log(id, coords, trackpoints);

                            track = {
                                "id": id,
                                "title": id,
                                "unitsystem": "metric",
                                "trackmode": true,
                                "nodes": trackpoints
                            };

                            trackSet.push(track);
                        }
                    })

                } else { // other like LineString

                    id = r.properties.time;
                    // ********************
                    id = id.replace(/-/g, "_");
                    
                    title = r.properties.name;
                    if (!title) title = r.properties.id;
                    if (!title) title = id;

                    if (coordinates.length > minTrackLength) {

                        trackpoints = extractPnts(coordinates, tracktimes);

                        route = {
                            "id": id,
                            "title": title,
                            "unitsystem": "metric",
                            "trackmode": true,
                            "nodes": trackpoints
                        };

                        trackSet.push(route);
                    }
                }

            })

            return trackSet;
        }

    });
</script>

</dom-module>