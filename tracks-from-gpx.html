<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../kml-json/kml-json.html">
<link rel="import" href="mb-content-behavior.html">
<!-- <link rel="import" href="mb-map-behavior.html"> -->
<link rel="import" href="mb-app-behavior.html">

<!--
`tracks-from-gpx`
Interface for import/export of tracking data from handheld gps-devices

Optional: create quick-preview-data 

@demo demo/routingtracks.html 
-->

<dom-module id="tracks-from-gpx">

<template>

    <style is="custom-style">
        :host {
            position: absolute;
            display: none; /*inline-block;*/
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <kml-json 
        url="[[xmlurl]]" 
        query="[[xmlquery]]" 
        geojson="{{rawdata}}">
    </kml-json>

</template>

<script>
    Polymer({
        is: 'tracks-from-gpx',

        properties: {

            srcmeta: {
                type: Object,
            },

            xmlurl: {
                type: String
            },

            // Query to be applied in kml-json 
            xmlquery: {
                type: Object,
                value: {
                    "tags": "Track",
                    "structure": "doc"
                }
            },

            logmode: {
                type: Boolean,
                value: false
            },

            rawdata: {
                type: Object,
                value: {}
                //observer: 'deriveTracks'
            },

            trackdata : {
                type: Object,
                notify: true
            },

            // can be processed in "quickViewer"
            rawtracks: {
                type: Object,
                notify: true
            },

            // to be processed in "trackAnimation"
            routedata: {
                type: Array,
                value: [],
                notify: true
            }

        },

        behaviors: [
            Mbb.AppBehavior,
            Mbb.ContentBehavior
        ],

        observers: [
            'triggerQuery(srcmeta.*)',
            'deriveTracks(rawdata, srcmeta, logmode)'
        ],

        attached: function() {
            // console.log("target attached");
        },

        triggerQuery: function(srcmeta) { // trigger new dataquery !!
            if (srcmeta.path == 'srcmeta') srcmeta = srcmeta.value;
            console.log("triggerQuery srcmeta",srcmeta) ;
            if (srcmeta.type != "gpx") {
                this.rawdata = null;
                return;
            }  
            // set parameters for data-fetch with <kml-json>
            if (srcmeta.xmlquery) this.xmlquery = srcmeta.xmlquery;
            this.xmlurl = srcmeta.url; // !! TRIGGER !!
        },
        
        // Convert raw gpx-json-data into 
        deriveTracks: function(rawdata, srcmeta, logmode) {
            if (!rawdata || !Object.keys(rawdata).length) return; 
            // console.log("GPX-data, raw tracks", rawdata);

            // 1. Simplify list of "simple" tracks 
            var rawtracks = this.getRawTracks(rawdata);
            // console.log("GPX-data, mode, flat tracks", rawtracks);

            // 2. 
            if (logmode) { // derive features for mb-visualization of rawTracks
                // console.log("prepare quickmap of ", rawtracks);  
                var rawtracks = this.createTrackLogs(rawtracks, srcmeta);
                if (rawtracks) {  console.log("RAW GPX-track data", rawtracks);
                    // this.rawtracks = rawtracks;
                    this.trackdata = rawtracks;
                }    

            } else {   // derive structures for mb-based animation of 'suitable' tracks
                // console.log("prepare routedata", rawtracks);  
                var trackroutes = this.createTrackRoutes(rawtracks); // .features);
                if (trackroutes.length) {  console.log("RAW ROUTEDATA (from GPX)",  trackroutes);
                    // this.routedata = trackroutes;
                    this.trackdata = trackroutes;
                }    
            }    
        },

        // Derive "raw tracks" from GPX, KML 
        getRawTracks: function(rawdata) {
            if (!rawdata) return; 
            // console.log("getRawTracks: rawdata=", rawdata);

            var scope = this;
            var trackdata , mapboxlayer;

            // Split multiLineTracks into tracksegments 
            // that are addressable by "own" start-time 
            function jsonTrackSimplify(rawdata) {

                var segmentFeatures = [],
                    starttime;

                rawdata.features.forEach(function(f, i) {

                    coordinates = f.geometry.coordinates;

                    tracktimes = f.properties.coordTimes;

                    type = f.geometry.type;

                    if (type == "MultiLineString") {

                        coordinates.forEach(function(coords, j) {

                            var cc = JSON.parse(JSON.stringify(coords)); // .slice(0);
                            var tt = JSON.parse(JSON.stringify(tracktimes[j])); // .slice(0);

                            if (!starttime) starttime = tt[0];

                            var seg = {
                                "type": "Feature",
                                "geometry": {
                                    "type": "LineString",
                                    "coordinates": cc
                                },
                                "properties": {
                                    "coordTimes": tt,
                                    "name": tt[0],
                                    "time": tt[0],
                                    "color": scope.getRandomColor()
                                }
                            };

                            segmentFeatures.push(seg);
                        })

                    } else {

                        if (!starttime) starttime = tracktimes[0];

                        f.properties.color = scope.getRandomColor();

                        segmentFeatures.push(f);
                    }
                })

                var segdata = {
                    "time": starttime, // rawdata.time (probably time of gpxToJson-conversion)
                    "type": rawdata.type,
                    "features": segmentFeatures
                };

                return segdata;
            }

            trackdata = jsonTrackSimplify(rawdata);
            // console.log("Raw Tracks, geojson-flat", trackdata)

            return trackdata;
        },

        // Derive mb-content to view RAW trackdata 
        createTrackLogs: function(trackdata, srcmeta) {

            var trackLogObject;

            function trackLogCreate(srcdata, title, prefix) {

                if (!title) title = srcdata.time;
               
                var mapid = title,
                    quickmap = {};
    
                quickmap[mapid] = {
                    "layer": {
                        "type": "line",
                        "id": mapid,
                        "source": mapid
                    },
                    "srcdata": srcdata,
                    "raw": 1
                };
                return quickmap; 
            };

            // Create data for quickview of raw trackdata 
            // with "short as possible" id-entification of features 
            var title; //  = srcmeta.key;
            if (!title) title = srcmeta.title;
            trackLogObject = trackLogCreate(trackdata, title); 
            
            // SUPPLY quickmap to viewing element 
            return trackLogObject;
            // if (trackLogObject) this.mapcontent = trackLogObject;

        },

        // Derive mb-content usable by (gia-)animatation-api 
        createTrackRoutes: function(rawdata, minTrackLength) {
            if (!minTrackLength) minTrackLength=5; 
            var scope = this,
                routedata = [],
                trackpoints, tracktimes,
                route, tt, coordinates,
                type, id, title;

            function extractPnts(coords, tt) {
                // tracktimes = r.properties.coordTimes;
                var tp, trackpoints = [];
                if (!coords || !coords.length) return trackpoints;
                var dott, utc;
                coords.forEach(function(cc, j) {
                    dott = scope.trackTime(tt[j]);
                    utc = scope.utcTime(dott);
                    tp = {};
                    tp.coords = [cc[0], cc[1]]; // !!! mapbox
                    tp.z = cc[2];
                    tp.ab = dott;
                    tp.an = tp.ab;
                    tp.utc = utc;
                    trackpoints.push(tp);
                });

                return trackpoints;
            }

            if (rawdata.features) rawdata = rawdata.features;

            rawdata.forEach(function(r, i) {

                coordinates = r.geometry.coordinates;

                tracktimes = r.properties.coordTimes;

                type = r.geometry.type;

                if (type == "MultiLineString") {

                    coordinates.forEach(function(coords, j) {

                        if (coords.length > minTrackLength) {

                            tt = tracktimes[j];
                            id = tt[0];

                            trackpoints = extractPnts(coords, tt);
                            // console.log(id, coords, trackpoints);

                            route = {
                                "id": id,
                                "title": id,
                                "unitsystem": "metric",
                                "trackmode": true,
                                "nodes": trackpoints
                            };

                            routedata.push(route);
                        }
                    })

                } else { // other like LineString

                    id = r.properties.time;
                    title = r.properties.name;
                    if (!title) title = id;
                    title = title.replace("ACTIVE LOG:", "");

                    if (coordinates.length > minTrackLength) {

                        trackpoints = extractPnts(coordinates, tracktimes);

                        route = {
                            "id": id,
                            "title": title,
                            "unitsystem": "metric",
                            "trackmode": true,
                            "nodes": trackpoints
                        };

                        routedata.push(route);
                    }
                }

            })

            return routedata;
        }

    });
</script>

</dom-module>