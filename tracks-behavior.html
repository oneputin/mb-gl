<link rel="import" href="../polymer/polymer.html">

<script>

  /**
   * `Mbb.TracksBehavior` 
   *
   * @polymerBehavior Mbb.TracksBehavior
   * @demo demo/index.html
   **/

    window.Mbb = window.Mbb || {};

    Mbb.TracksBehavior = {

        // Spatial length in variable unit
        trackLength : function(aLine, unit, decimals) {
          // aLine must be geojsonFeature (type, geometry)    
          var unitshort ;
          if (!unit) unit="kilometers";
          if (!decimals) decimals = 3; 
          
          if (unit=="kilometers") unitshort ="km";
          if (unit=="miles") unitshort ="mi";
          if (unit=="nautic") {
              unit="kilometers"; // calculate later !!
              unitshort ="nm";
          }    
          var dl = 1;
          if (typeof turf !== "undefined") dl = turf.lineDistance(aLine, unit);
          else dl = 999; // ??? 

          if (typeof dl == "number") {
              if (unitshort=="nm") dl = dl / 1.856; 
              dl = this.toFixed(dl, decimals) + unitshort;
          }  // console.log("trackLength", dl);  
          return dl;
        },

        // Create readable time period h:min
        // from dt formatted as unixTime as [h]
        deltaT: function(dt, fallback) {
            //console.log("DELTAT", t)
            var h = Math.floor(dt),
                hh;
            if (h > 0) {
                hh = h < 10 ? "0" + h + "h" : h + "h";
            } else {
                hh = "";
            }  

            var m = Math.round((dt - h) * 60);
            m = (m < 10) ? "0" + m : m;
            
            var deltat = hh || m ? hh + m + "min" : fallback; 
            return deltat;
        },

        // derive comparable/calculable times
        // from dates of type "2016.12.11,16.00" or "2016.12.16,16:00"
        utcTime: function(t, unit, lonlat) {
            // !! for parser the MONTH must be numbered 0 .. 11 !!
            var tlocal;
            if (typeof t == "string") {
                var t = t.replace(",", "."),
                    t = t.replace(":", "."),
                    a = t.split(".");

                // Time intervals 
                if (a[0] == "0") {
                    a[0] = "1970";
                    if (a[1] == "0") {
                        a[1] = "1";
                        if (a[2] == "0") {
                            a[2] = "1";
                            if (a[3] == "0") {
                                a[3] = "1";
                                if (a[4] == "0") {
                                    a[4] = "1";
                                }
                            }
                        }
                    }
                    // console.log("utcTime", t, a);
                }

                if (a.length > 5) { // 
                    tlocal = new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]), parseInt(a[5]));
                } else {
                    tlocal = new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]));
                }
            } else {
                tlocal = t;
            }

            var tg = tlocal,
                t_unit = tg;

            if (unit == "h") t_unit = tg / (1000 * 3600);
            else if (unit == "s") t_unit = tg / 1000;
            else t_unit = tg; // [ms]

            return t_unit;
        },

        /**
         * convert any(?) device-formatted track-times into "dot-only" format
         */
        trackTime : function (traw, asarray) { 
            if (typeof traw == "string") {
                var t = traw.replace("Z", "");
                t = t.split(":").join(".");
                t = t.split("-").join(".");
                t = t.split("T").join(".");
                // console.log(t);
                if (asarray)  return t.split(".");
                return t;
            }     
            return traw;
        },

        /**
         * 
         */
        logTime: function(ms1970, unit, sep) {
            if (unit == "h") ms1970 = ms1970 * 3600 * 1000;
            var logtime = new Date(ms1970);
            // console.log("logTime",ms1970,logtime);
            if (!sep) return logtime;
 
            var D = logtime.getDate(),
                M = logtime.getMonth() + 1,
                h = logtime.getHours(),
                m = logtime.getMinutes();
             
            switch (sep) {
                case 'D':
                    logtime = D;
                    break;
                case 'M':
                    logtime = M;
                    break;
                case 'h':
                    logtime = h;
                    break;
                case 'm':
                    logtime = m;
                    break;
                default:
                    // Combined date/time strings
                    if (sep) { 
                        D = D < 10 ? "0" + D : D;
                        M = M < 10 ? "0" + M : M;
                        h = h < 10 ? "0" + h : h;
                        m = m < 10 ? "0" + m : m;

                        var logdate = D + "." + M,
                            daytime = h + ":" + m;
                        // 
                        if  (sep=="t") logtime = daytime;
                        else logtime = logdate + sep + daytime;
                    }
            }

            return logtime;
        },

        /**
         * TOOL
         *
         */
        objectClone: function(obj) {
            var cloned = {}; 
            if (obj) {
                Object.keys(obj).forEach(function(k){
                    cloned[k] = obj[k];
                })
            }
            return cloned; 
        },

        // get color in hex-format
        getRandomColor: function() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        },

        // extended version optionally negative precision
        toFixed : function(number, precision) {
            var factor = Math.pow(10, precision);
            var tempNumber = number * factor;
            var roundedTempNumber = Math.round(tempNumber);
            return roundedTempNumber / factor;
        },


        // Get track-specific Info about the "geoJson-src-feature", 
        // the selected json-tile belongs to
        trackLogAddDetails: function(trackident, lnglat) { //console.log("trackLogAddDetails", trackident, lnglat); 
            var scope = this, 
                trackLog = {}, 
                trackLine, selectPnt, dragPnt, 
                trackTimes, trackElevs,
                tpTime, trackZ;    

            // A. APP-SPECIFIC: derive line-specific props
            
            if (trackident.snap) {   // Sonderfall ? ? ?

                selectPnt = trackident.query; // features[1];
                dragPnt   = trackident.snap; // features[2];
                trackLine = trackident.track; // features[0];

                trackLog = trackLine.properties;
            
            } else if (trackident.geometry) { // 

                trackLog = trackident; 
                trackLog.bbox = this.setFeatureBounds([trackident]);
                trackLog.length = this.trackLength(trackident);
                
                trackLog.coords = trackident.geometry.coordinates; // **!!!** 
                trackLog.fromnode = trackident.coords[0];
                trackLog.tonode = trackident.coords[trackident.coords.length - 1];
            }

            if (lnglat) trackLog.lnglat = lnglat; 

            trackLog.html = "ID: <span style='color: red;'>" + trackLog.time +"</span><hr>";

            trackLog.toast = "";


            // B. SPECIFIC: derive tracklog-specific parameterArrays 

            if (trackLog.coordTimes) { 

                trackTimes = trackLog.coordTimes;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                
                if (typeof trackTimes == "string") {
                    trackTimes = JSON.parse(trackTimes);
                    trackLog.coordTimes = trackTimes;
                }   // console.log(trackLog, trackTimes);
                
                var n = trackTimes.length, // equal to number of coords
                    tvon = scope.trackTime(trackTimes[0]);
                    tbis = scope.trackTime(trackTimes[n - 1])
                    von = scope.utcTime(tvon, "h"),
                    bis = scope.utcTime(tbis, "h"),
                    dt = bis - von;
                // console.log(trackTimes[0],trackTimes[n-1], tvon, tbis, von, bis, dt);

                trackLog.duration = scope.deltaT(dt);
                trackLog.count = n;
                trackLog.von = scope.logTime(von, "h", "t");
                trackLog.bis = scope.logTime(bis, "h", "t");

                // E. SPECIFIC: add some parameters to quickInfo-HTML 
                var vonbis = " [ " + trackLog.von +" to " + trackLog.bis + "] ";
                trackLog.html  += "Duration: " 
                                + trackLog.duration
                                + "<br>" + vonbis; 
                // trackLog.toast += vonbis;
            }

            // C. 
            if (trackLog.coordElevs) {
                
                trackElevs = trackLog.coordElevs;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                
                if (typeof trackElevs == "string") {
                    trackElevs = JSON.parse(trackZ);
                }
            }    
            // console.log("TP:", dragPnt, trackLine); // , trackLog);

            // D. Add dragpnt - data 

            if (dragPnt) { 
                var tpinfo = dragPnt.properties,
                    coords = dragPnt.geometry.coordinates;
                trackLog.lnglat = new mapboxgl.LngLat(coords[0],coords[1]);

                trackLog.html += "<hr>TP-Index: "+ tpinfo.index; 

                if (trackTimes) {
                    tpTime = scope.trackTime(trackTimes[tpinfo.index]);
                    tpTime = scope.utcTime(tpTime, "h");
                    tpTime = scope.logTime(tpTime, "h", "t");
                    tpTime = tpTime + " [UTC]" ;
                
                    trackLog.html  += "<br>Time: " + tpTime; 
                    trackLog.toast += tpTime ; // + trackLog.toast;
                }    

                if (trackElevs) {

                    trackZ = trackZ[tpinfo.index] + " m";

                    trackLog.html += "<br>Elev : " + trackZ + " m NN"; 
                    trackLog.toast += "  :  z = "+ trackZ ; 
                }    
                // console.log("TP:", dragPnt, trackLine); // , trackLog);
          
            } else {

                trackLog.html += "<br>Length: " + trackLog.length
                trackLog.html += "<br>TP's: " + trackLog.count;

            } // console.log("trackLog",trackLog); 
            
            return trackLog;
        }

    };
</script>    