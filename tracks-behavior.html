<link rel="import" href="../polymer/polymer.html">

<script>

  /**
   * `Mbb.TracksBehavior` 
   *
   * @polymerBehavior Mbb.TracksBehavior
   * @demo demo/index.html
   **/

    window.Mbb = window.Mbb || {};

    Mbb.TracksBehavior = {

        // 
        deltaL : function(aLine, unit) {
          // aLine must be an element of src-data (!!!) , here   
          var unitshort ;
          if (!unit) unit="kilometers";
          if (unit=="kilometers") unitshort ="km";
          if (unit=="miles") unitshort ="mi";
          if (unit=="nautic") {
              unit="kilometers";
              unitshort ="nm";
          }    
          var dl = 1;
          if (typeof turf !== "undefined") dl = turf.lineDistance(aLine, unit);
          if (typeof dl == "number") {
              if (unitshort=="nm") dl = dl / 1.856; 
              dl = this.toFixed(dl, 3) + unitshort;
          }    
          return dl;
        },

        // Create readable time period h:min
        // from dt formatted as unixTime as [h]
        deltaT: function(dt, fallback) {
            //console.log("DELTAT", t)
            var h = Math.floor(dt),
                hh;
            if (h > 0) {
                hh = h < 10 ? "0" + h + "h" : h + "h";
            } else {
                hh = "";
            }  

            var m = Math.round((dt - h) * 60);
            m = (m < 10) ? "0" + m : m;
            
            var deltat = hh || m ? hh + m + "min" : fallback; 
            return deltat;
        },

        // derive comparable/calculable times
        // from dates of type "2016.12.11,16.00" or "2016.12.16,16:00"
        utcTime: function(t, unit, lonlat) {
            // !! for parser the MONTH must be numbered 0 .. 11 !!
            var tlocal;
            if (typeof t == "string") {
                var t = t.replace(",", "."),
                    t = t.replace(":", "."),
                    a = t.split(".");

                // Time intervals 
                if (a[0] == "0") {
                    a[0] = "1970";
                    if (a[1] == "0") {
                        a[1] = "1";
                        if (a[2] == "0") {
                            a[2] = "1";
                            if (a[3] == "0") {
                                a[3] = "1";
                                if (a[4] == "0") {
                                    a[4] = "1";
                                }
                            }
                        }
                    }
                    // console.log("utcTime", t, a);
                }

                if (a.length > 5) { // 
                    tlocal = new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]), parseInt(a[5]));
                } else {
                    tlocal = new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]));
                }
            } else {
                tlocal = t;
            }

            var tg = tlocal,
                t_unit = tg;

            if (unit == "h") t_unit = tg / (1000 * 3600);
            else if (unit == "s") t_unit = tg / 1000;
            else t_unit = tg; // [ms]

            return t_unit;
        },

        /**
         * convert any(?) device-formatted track-times into "dot-only" format
         */
        trackTime : function (traw, asarray) { 
            if (typeof traw == "string") {
                var t = traw.replace("Z", "");
                t = t.split(":").join(".");
                t = t.split("-").join(".");
                t = t.split("T").join(".");
                // console.log(t);
                if (asarray)  return t.split(".");
                return t;
            }     
            return traw;
        },

        /**
         * 
         */
        logTime: function(ms1970, unit, sep) {
            if (unit == "h") ms1970 = ms1970 * 3600 * 1000;
            var logtime = new Date(ms1970);
            // console.log("logTime",ms1970,logtime);
            if (!sep) return logtime;

            var D = logtime.getDate(),
                M = logtime.getMonth() + 1,
                h = logtime.getHours(),
                m = logtime.getMinutes();
             
            switch (sep) {
                case 'D':
                    logtime = D;
                    break;
                case 'M':
                    logtime = M;
                    break;
                case 'h':
                    logtime = h;
                    break;
                case 'm':
                    logtime = m;
                    break;
                default:
                    // Combined date/time strings
                    if (sep) { 
                        D = D < 10 ? "0" + D : D;
                        M = M < 10 ? "0" + M : M;
                        h = h < 10 ? "0" + h : h;
                        m = m < 10 ? "0" + m : m;

                        var logdate = D + "." + M,
                            daytime = h + ":" + m;
                        // 
                        if (sep=="t") logtime = daytime;
                        else logtime = logdate + sep + daytime;
                    }
            }

            return logtime;
        },

        /**
         * TOOL
         *
         */
        objectClone: function(obj) {
            var cloned = {}; 
            if (obj) {
                Object.keys(obj).forEach(function(k){
                    cloned[k] = obj[k];
                })
            }
            return cloned; 
        },

        // get color in hex-format
        getRandomColor: function() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        },

        // extended version optionally negative precision
        toFixed : function(number, precision) {
            var factor = Math.pow(10, precision);
            var tempNumber = number * factor;
            var roundedTempNumber = Math.round(tempNumber);
            return roundedTempNumber / factor;
        },


        // Get track-specific Info about the "geoJson-src-feature", 
        // the selected json-tile belongs to
        trackInfoCollect: function(trackident ) { // console.log("trackInfoCollect", trackident); 
            var scope = this, 
                trackInfo = {}, 
                trackLine, selectPnt, dragPnt, 
                trackTimes, trackElevs,
                tpTime, trackZ;    

            // A. APP-SPECIFIC: derive line-specific props
            
            if (trackident.snap) {   // 

                selectPnt = trackident.query; // features[1];
                dragPnt   = trackident.snap; // features[2];
                trackLine = trackident.track; // features[0];

                trackInfo = trackLine.properties;
            
            } else if (trackident.srcfeature) { // 

                trackInfo = trackident; 
                
                trackInfo.coords = trackident.srcfeature.geometry.coordinates; // **!!!** 
                trackInfo.fromnode = trackident.coords[0];
                trackInfo.tonode = trackident.coords[trackident.coords.length - 1];
                trackInfo.bbox = this.setFeatureBounds([trackident.srcfeature]);
                trackInfo.length = this.deltaL(trackident.srcfeature);
            }

            trackInfo.html = "Track LOG <hr>" + trackInfo.time;

            trackInfo.toast = "";


            // B. SPECIFIC: derive tracklog-specific parameterArrays 

            if (trackInfo.coordTimes) { 

                trackTimes = trackInfo.coordTimes;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                
                if (typeof trackTimes == "string") {
                    trackTimes = JSON.parse(trackTimes);
                    trackInfo.coordTimes = trackTimes;
                }   // console.log(trackInfo, trackTimes);
                
                var n = trackTimes.length, // equal to number of coords
                    tvon = scope.trackTime(trackTimes[0]);
                    tbis = scope.trackTime(trackTimes[n - 1])
                    von = scope.utcTime(tvon, "h"),
                    bis = scope.utcTime(tbis, "h"),
                    dt = bis - von;
                // console.log(trackTimes[0],trackTimes[n-1], tvon, tbis, von, bis, dt);

                trackInfo.duration = scope.deltaT(dt);
                trackInfo.count = n;
                trackInfo.von = scope.logTime(von, "h", "t");
                trackInfo.bis = scope.logTime(bis, "h", "t");

                // E. SPECIFIC: add some parameters to quickInfo-HTML 
                var vonbis = " [ " + trackInfo.von +" to " + trackInfo.bis + "] ";
                trackInfo.html  += "<br>Duration: " 
                                + trackInfo.duration
                                + "<br>" + vonbis; 
                // trackInfo.toast += vonbis;
            }


            if (trackInfo.coordElevs) {
                
                trackElevs = trackInfo.coordElevs;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                
                if (typeof trackElevs == "string") {
                    trackElevs = JSON.parse(trackZ);
                }
            }    
            // console.log("TP:", dragPnt, trackLine); // , trackInfo);

            // C. 

            if (dragPnt) { 

                var tpinfo = dragPnt.properties,
                    coords = dragPnt.geometry.coordinates;
                trackInfo.lnglat = new mapboxgl.LngLat(coords[0],coords[1]);

                trackInfo.html += "<hr>TP-Index: "+ tpinfo.index; 

                if (trackTimes) {
                    tpTime = scope.trackTime(trackTimes[tpinfo.index]);
                    tpTime = scope.utcTime(tpTime, "h");
                    tpTime = scope.logTime(tpTime, "h", "t");
                    tpTime = tpTime + " [UTC]" ;
                
                    trackInfo.html  += "<br>Time: " + tpTime; 
                    trackInfo.toast += tpTime ; // + trackInfo.toast;
                }    

                if (trackElevs) {

                    trackZ = trackZ[tpinfo.index] + " m";

                    trackInfo.html += "<br>Elev : " + trackZ + " m NN"; 
                    trackInfo.toast += "  :  z = "+ trackZ ; 
                }    
                // console.log("TP:", dragPnt, trackLine); // , trackInfo);
          
            } else {
        
                trackInfo.html += "<br>Length: " + trackInfo.length
                trackInfo.html += "<br>TP's: " + trackInfo.count;

            } 
            
            return trackInfo;
        }

    };
</script>    