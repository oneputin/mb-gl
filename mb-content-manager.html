<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="mb-app-behavior.html">

<!--
`mb-content-manager`
Refresh mb-contentbox features
- after contentbox-items changed  
- after map component is available
- after mapstyle (background) changed : mbid

@demo demo/routingtracks.html 
-->

<dom-module id="mb-content-manager">

    <template>
        <style>
        </style>
    </template>

    <script>
        Polymer({
            is: 'mb-content-manager',

            properties: {
                /**
                 *  IN: map-object tries to trigger content-draw when available first time 
                 */
                map: {
                    type: Object,
                    observer: "onMapSetup"
                },

                // OUT: features of (all) contentbox-layers loaded
                // !! grouped by layer !!
                contentfeatures: {
                    type: Object,
                    notify: true
                },

                // OUT: (linear) List of (basic) mapcontent-features from 1(optionally more) layer(s)
                // fi. to be used for external selection
                dataset: {
                    type: Array,
                    notify: true
                },

                // After selection by map-events defined on layers of contentbox 
                featureselected : {
                    type: Object,
                    notify: true
                },

                // IN new contentbox to be 
                contentbox: {
                    type: Object,
                    notify: true
                },

                // IN: events added to "content"
                mapevents : {
                    type : Object 
                },

                // IN: id of mb-mapstyle (basemap) triggers content-redraw when changed
                mbid: {
                    type: String,
                    observer: 'onStyleChanged'
                },

                // Cached (Old) content 
                _contentbox: {
                    type: Object
                }
            },

            behaviors: [
                Mbb.AppBehavior,
                Mbb.MapBehavior
            ],


            observers: [
                'mbContentApply(contentbox.*, "CONTENTBOX")',
                'contentToDataset(contentfeatures.*)'
            ],


            ready: function() {
                // console.log("READY: mb-content-manager");
            },

            // rarely used 
            onMapSetup: function(map) {
                // if (!map || !this.contentbox) return;
                // console.log("FIRST prepare mapcontent from", this.contentbox);
                this.mbContentApply(this.contentbox, "NEW MAP");
            },

            // refresh contentbox on changed basemap
            onStyleChanged: function(mbid) {
                this.mbContentApply(this.contentbox, "STYLE " + mbid);
            },

            /**
             * Create/Update all mbContent items 
             * related to newly selected contentbox
             */
            mbContentApply: function(contentbox, reason) { console.log("mbContentApply for reason=", reason, contentbox); 
                if (!contentbox || !Object.keys(contentbox).length) return;

                var scope = this,
                    map = scope.map; 
                // if (contentbox.path == 'contentbox') {
                this.debounce("apply", function(){
                    // 
                    var cp = contentbox.path; // console.log("mbContentApply-1 ", contentbox, cp);
                    if (cp && (cp.indexOf('contentbox') >= 0)) { 
                        contentbox = contentbox.base;
                    } 

                    // Verify weather (at least some) new content is "well defined"
                    if (map) {
                        // 
                        var mapevents = this.mapevents;

                        contentbox = this._mbContentVerify(contentbox, map, mapevents);
                    }

                    if (!contentbox || !Object.keys(contentbox).length)  {
                        console.log("NO content to apply for", reason);
                        return; 
                    }

                    // REMOVE all old content (this._contentbox) 
                    // from app (from actual map) if new is prepared 
                    this._mbContentCheckOut();

                    // Memorize push back as 
                    this._contentbox = contentbox;   

                    // INSERT new content into map
                    // console.log("Apply content for reason", reason, contentbox);
                    let checkedcontent = this._mbContentCheckIn(contentbox, reason); 

                    this.contentfeatures = checkedcontent;
                    // **********************************
                }, 100);        
            },    

            // Make contentbox "complete"  
            _mbContentVerify: function(contentbox, map, mapevents) {    
                if (!contentbox || !Object.keys(contentbox).length) return; 

                var scope = this;
                //  map = scope.map;

                var verifiedContent = {}, layerObject ;
                
                var featureHilite = mapevents.hilite, 
                    featureSelect = mapevents.select; 

                // Fallback-functions
                if (!featureHilite) {
                    featureHilite = function(e, layerid){
                        // console.log("HILITE", e,layerid)
                    }
                }
                if (!featureSelect) {
                    featureSelect = function(e, layerid){
                        console.log("SELECT", e, layerid)
                    }
                }

                // Add temporary paint-properties 
                // for easy identification of features (line-width, random colors)
                function rawBeautify(layerObject) {

                    var srcdata = layerObject.srcdata;

                    var lookuplist = [], paintObj;

                    srcdata.features.forEach(function(f) {
                        var col = f.properties.color;
                        lookuplist.push([col, col]);
                    });

                    if (true) { // Line-feature
                        paintObj = {
                            "line-width": 3,
                            "line-color": {
                                property: 'color',
                                type: 'categorical',
                                stops: lookuplist
                            }
                        }; 
                    }

                    layerObject.layer.paint = paintObj;

                    // console.log("RAW-Beautify", layerObject);

                    return layerObject.layer;
                }

                // Apply prepared 
                function rawEvents(layername) {

                    function hiliter(e) {
                        featureHilite(e, layername, scope);
                    }

                    function selector(e) {
                        featureSelect(e, layername, scope);
                    }

                    // 
                    var eventset = {
                        "mousemove" : hiliter,
                        "click" : selector
                    };

                    return eventset;
                }

                // Create (multiple) themeLayers 
                // used to comfortably interact with datalayer in mapbox  
                function getContentTemplates(layerObject) {
                    // Compile templates of mb-layer-objects (without data)

                    function createHiliteLayer(layertemplate, hitype) {
                        
                        var lhilite = {},// layertemplate,
                            templateid = layertemplate.id + "-" + hitype;
                        // console.log("createHiliteLayer for", templateid);

                        if (hitype == "nodes") { // sonderfall
                            lhilite = {
                                    "type": "symbol",
                                    "id": templateid,
                                    "source": templateid,
                                    // "source": "",

                                    "layout": {
                                        "icon-image": "{icon}-15",
                                        "text-field": "{title}",
                                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                        "text-offset": [0, 0.6],
                                        "text-anchor": "top"
                                    },
                                    "paint": {
                                        "text-halo-color": "#ffffff",
                                        "text-halo-width": 6,
                                        "text-color": "#ff0000"
                                    }
                            };
                            return lhilite; 
                        } 
                        
                        // Copy most properties from source template 
                        // add some specific styling

                        basetype = layertemplate.type,

                        Object.keys(layertemplate).forEach(function(k) {
                            lhilite[k] = layertemplate[k];
                        })

                        lhilite.id = templateid ;
                        lhilite.filter = ["==", "id", ""];

                        var linecolor, linewidth, lineopacity, linedasharray;

                        if (hitype == "hover") {
                            linecolor = "#FF0000";
                            linewidth = 5;
                            lineopacity = 1;

                        } else if (hitype=="select")  {
                            linecolor = "#000000";
                            linewidth = 3;
                            lineopacity = 0.7;
                            linedasharray = [4,4];  
                        }

                        lhilite.paint = {
                            "line-color": linecolor,
                            "line-width": linewidth,
                            "line-opacity": lineopacity,
                        }
                        if (linedasharray) {
                            lhilite.paint["line-dasharray"] = linedasharray;
                        } 

                        // Append event functions


                        return lhilite;
                    }

                    var basicTemplate = layerObject['layer'],
                        bgTemplate = layerObject['bglayer'],
                        selectTemplates = layerObject['selectlayer'];

                    // Compile collection of     
                    var layerTemplates = [];

                    if (basicTemplate) layerTemplates.push(basicTemplate);

                    // Insert BG BELOW main layer 
                    if (bgTemplate) {
                        layerTemplates.splice(0, 0, bgTemplate); // !!! 
                    }

                    // Specify some HILITE Layer(s) for selected feature(s)
                    if (selectTemplates && selectTemplates.length) {
                        // A. Vordefinierte HILITE layers 

                        layerObject['selectlayer'].forEach(function(l) {
                            layerTemplates.push(l);
                        });

                    } else if (basicTemplate && layerObject.raw) { 
                        // B. "Standardisierte" HILITE-Layers des basic 'layer' 
                        //    wenn keine speziellen vordefiniert waren 
                        
                        // Layer that occurs during "mouse-hover"
                        let hoverTemplate = createHiliteLayer(basicTemplate, "hover");
                        if (hoverTemplate) layerTemplates.push(hoverTemplate);

                        // Layer that occurs after "selection"
                        let selectTemplate = createHiliteLayer(basicTemplate, "select");
                        if (selectTemplate) layerTemplates.push(selectTemplate);

                        var isLine = true; 
                        if (isLine) {
                            // additional commented NODES at LINE-ends
                            let nodeTemplate = createHiliteLayer(basicTemplate, "nodes");
                            if (nodeTemplate) layerTemplates.push(nodeTemplate);
                        }  
                    }

                    return layerTemplates;
                }


                var contentboxLayers = Object.keys(contentbox);   // console.log("Refreshing quickmap-layers", contentboxLayers);

                contentboxLayers.forEach(function(layername, j) {

                    layerObject = contentbox[layername];
                    // console.log("VERIFY", layername, layerObject); 

                    if (layerObject.raw) {
                        // console.log("SETUP qlayer " + layername, layerObject);
                        layerObject.layer = rawBeautify(layerObject);
                    }

                    if (!layerObject.templates) {
                        layerObject.templates = getContentTemplates(layerObject);
                    }    


                    if (!layerObject.events) { 
                        layerObject.events = rawEvents(layername);
                    }

                    verifiedContent[layername] = layerObject;
                })
                // console.log("NEW contentBox", verifiedContent);  
                return verifiedContent; 
            },


            // Insert all layers of contentbox 
            _mbContentChecker: function(contentbox, flag, map) {    
                if (!contentbox || !Object.keys(contentbox).length) return; 
                if (!flag) flag = "IN";

                var scope = this;
                //var map = scope.map;
                //if (!map) return; 

                // create linear list of features 
                // suitable for "menu-generation"
                function getFeatureList(layerData, layername, longtitle) {
                    // console.log("getFeatureList", layername, layerData);

                    var flist = [],
                        fitem = {},
                        id, title, i = 0;
                    if (!layerData || !layerData.features) return flist;

                    layerData.features.forEach(function(f) {
                        id = f.id;
                        if (typeof id == "undefined") id = f.properties.name;
                        if (typeof id == "undefined") id = f.properties.time;
                        // Typische Nachbearbeitung
                        if (typeof id == "string") {
                            title = id.replace("ACTIVE LOG:", "");
                            id = id.replace(/-/g, "_");
                        } else if (id) {
                            title = id.toString(); 
                        } else {
                            title = "F-" + i; 
                        }

                        if (longtitle) title = layername + "_" + title;
                        title = title.replace(/ /g, "");

                        fitem = {
                            "layer": layername,
                            "id": id,
                            "title": title,
                            "feature": f
                        };
                        flist.push(fitem);
                        i = i + 1; 
                    })

                    return flist;
                }
                // 
                function addMapContent(layername, layerObject){
                    var layerData = layerObject.srcdata;
                    if (!layerData) return ; 

                    var layerSource = map.getSource(layername);

                    layerData.type = "FeatureCollection";

                    if (!layerSource) {   // 1.A. Add(create) mapSource 
                        // console.log("ADD source: "+layername, layerData);
                        map.addSource(layername, {
                            "type": "geojson",
                            "data": layerData
                        });

                        layerSource = map.getSource(layername);

                    } else {   
                                   // 1.B  Update data of existing mapSource  
                       layerSource.setData(layerData);
                    }  // console.log("SET SRC", layername, layerData, layerSource._data);


                    // 1.C. (Re)Create all layer(s) of same srcdata 
                    var mapLayer = map.getLayer(layername); // reference layer

                    if (!mapLayer && layerObject.templates) {
                        // console.log("ADD contentLayers for " + layername, layerObject);
                        
                        layerObject.templates.forEach(function(template) {

                            if (!map.getLayer(template.id)) {

                                // spezieller Sonderfall      
                                if ((template.type == "symbol") && template.source) { 
                                    var mapHasSource = map.getSource(template.source);                                        
                                    if (!mapHasSource) {   
                                        // console.log("+PLACEHOLDER-source for " + template.id, template.source); 
                                        map.addSource(template.source, {
                                            "type": "geojson",
                                            "data": { "type": "Point", "coordinates": [0, 0] }
                                        });
                                    }    
                                }

                                map.addLayer(template);
                            }
                        });

                        mapLayer = map.getLayer(layername);
                    }

                    // Check layer content  
                    if (mapLayer) { 
                    /*
                        var features = map.querySourceFeatures(layername, {
                            filter: null
                        });
                        console.log("Checked "+features.length + " features of layer [" + layername+ "]"); // , features, layerSource);
                    */
                    }
                    return layerData; 
                }

                //
                function toggleContentEvents(layerObject, flag){

                    var eventset = layerObject.events;
                    if (!eventset) return;  

                    // var events = ;

                    Object.keys(eventset).forEach(function(ev){
                        if (flag=="IN") {
                            map.on(ev, eventset[ev])
                        } else {
                            map.off(ev, eventset[ev])
                        }    
                    }); 

                }
                // 
                function removeMapContent(layerObject) {

                    var contentLayers = layerObject.templates;
                    // console.log("remove contentLayers of " + layerObject.layer.source, contentTemplates); // , layerObject); 
                    // deactivate related events 

                    // remove templateLayers
                    contentLayers.forEach(function(template) {
                        var qlayername = template.id,
                            qlayer = map.getLayer(qlayername);

                        if (qlayer) {
                            // console.log("remove contentLayer", qlayername, qlayer) ;                        
                            map.removeLayer(qlayername);
                        }  
                   });  

                   // remove Sources
                   contentLayers.forEach(function(template) { 
                        var srcid = template.source,
                            qsrc = map.getSource(srcid);
                        if (qsrc) {
                            // console.log("remove contentSource ", srcid, qsrc);
                            map.removeSource(srcid);
                        }   
                    })    
                }

                // --------------------------------------------------

                var mapcontent = {};
                
                var contentboxKeys = Object.keys(contentbox);   // console.log("Refreshing contentboxlayers", contentboxLayers, contentbox);

                contentboxKeys.forEach(function(layername, j) {

                    var layerObject = contentbox[layername],
                        contentfeatures = [];
                    // console.log("CHECK-CONTENT-"+flag+" of " + layername, layerObject);

                    // Option 
                    if (flag == "IN") { // ADD/REFRESH a contentbox object 

                        var layerData = layerObject.srcdata;

                        if (map)  {
                            layerData = addMapContent(layername, layerObject);
                            // console.log("MAP ADDed content for " + layername, layerData); // , layerObject);
                        } 

                        if (layerData) {   // Check/Get all source-features of the basic layer 
                            contentfeatures = getFeatureList(layerData, layername);
                            // console.log("CHECKED-"+flag+" ["+layername+"].", "feat.cnt=" + contentfeatures.length); // , contentfeatures);
                        }                        

                    }   else {        // REMOVE object (on demand)

                        if (map) {
                            // console.log("CHECKED-"+flag+" [" + layername+"]", layerObject); 
                            removeMapContent(layerObject); 
                        }     
                    } 
                    
                    if (map) {
                        // console.log("TOGGLE Contentevents-"+flag +" [" + layername+"]", layerObject); 
                        toggleContentEvents(layerObject, flag) 
                    }    
                    // Add layer-features to mapcontent
                    if (contentfeatures.length) {
                        // console.log("contentfeatures of " + layername, contentfeatures);
                        mapcontent[layername] = {
                            "features": contentfeatures,
                            "usefeatures": layerObject['usefeatures']
                        }    
                    }  

                }.bind(this));

                return mapcontent; 
            },

            // Remove previous Content-layers
            _mbContentCheckOut: function() { 
                if (this._contentbox) console.log("MAP-OUT-features", this._contentbox); 
                var oldcontent = this._mbContentChecker(this._contentbox, "OUT", map) ;    
                // if (oldcontent)  console.log("MAP-OUT-features", oldcontent);
            },

            // Add/Insert layers according contentbox
            _mbContentCheckIn: function(contentbox, reason) { 
                var mapcontent = this._mbContentChecker(contentbox, "IN", map) ;
                if (mapcontent)  {
                    console.log("MAP-IN-features for", reason, mapcontent);
                    return mapcontent; 
                }    
            },


            /**
             * Create a linear LIST(array) of all features  
             * of the mapcontent-layer (marked with flag 'usefeatures' if more layers) 
             * and supply as notify-parameter 'dataset'
             */
            contentToDataset: function(contentfeatures, keys) {
                if (contentfeatures.path == 'contentfeatures') contentfeatures = contentfeatures.value;
                if (!contentfeatures || !Object.keys(contentfeatures).length) return;
                
                if (!keys) keys = Object.keys(contentfeatures);
                console.log("START contentToDataset :", keys, contentfeatures);
                
                // Select features from layer with basefeatures only !! 

                var obj, usedkeys=[], dataset = [];

                keys.forEach(function(lname) {
                    obj = contentfeatures[lname];
                    // add features to dataset 
                    //  - if layer is "marked with 'usefeatures' "  or
                    //  - if only one layer exists in contentfeatures  
                    if ((keys.length == 1) || obj.usefeatures) { //
                        usedkeys.push(lname); 
                        obj.features.forEach(function(item) {
                            dataset.push(item);
                        })
                    } 
                });

                this.dataset = [];
                this.dataset = dataset; // NOTIFIES  !!
                console.log("OK contentToDataset :", usedkeys, dataset);
            },

        })
    </script>
</dom-module>                  