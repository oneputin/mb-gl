<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="mb-content-behavior.html">
<link rel="import" href="mb-app-behavior.html">

<!--
`mb-content-manager`
Refresh mb-contentbox features
- after contentbox-items changed  
- after map component is available
- after mapstyle (background) changed : mbid

@demo demo/routingtracks.html 
-->

<dom-module id="mb-content-manager">

    <template>
        <style>
        </style>
    </template>

    <script>
        Polymer({
            is: 'mb-content-manager',

            properties: {
                // OUT: features of (all) contentbox-layers loaded
                // !! grouped by layer !!
                contentfeatures: {
                    type: Object,
                    notify: true
                },

                // OUT: (linear) List of (basic) mapcontent-features from 1(optionally more) layer(s)
                // fi. to be used for external selection
                featuresused: {
                    type: Array,
                    notify: true
                },

                // After selection by map-events defined on layers of contentbox 
                featureselected : {
                    type: Object,
                    notify: true
                },

                // IN new contentbox to be 
                contentbox: {
                    type: Object,
                    notify: true
                },
                /**
                 *  IN: map-object triggers content-draw when available first time 
                 */
                map: {
                    type: Object,
                    observer: "onMapSetup"
                },

                // IN: id of mb-mapstyle (basemap) triggers content-redraw when changed
                mbid: {
                    type: String,
                    observer: 'onStyleChanged'
                },

                // Cached (Old) content 
                _contentbox: {
                    type: Object
                }
            },

            behaviors: [
                Mbb.AppBehavior,
                Mbb.ContentBehavior,
                Mbb.MapBehavior
            ],


            observers: [
                'mbContentApply(contentbox.*, "CONTENTBOX")',
                'contentFeaturesToList(contentfeatures.*)'
            ],


            ready: function() {
                // console.log("READY: mb-content-manager");
            },

            // rarely used 
            onMapSetup: function(map) {
                // if (!map || !this.contentbox) return;
                // console.log("FIRST prepare mapcontent from", this.contentbox);
                this.mbContentApply(this.contentbox, "NEW MAP");
            },

            // refresh contentbox on changed basemap
            onStyleChanged: function(mbid) {
                this.mbContentApply(this.contentbox, "STYLE " + mbid);
            },

            /**
             * Create/Update all mbContent items 
             * related to newly selected contentbox
             */
            mbContentApply: function(contentbox, meta) {
                if (!contentbox || !Object.keys(contentbox).length) return;
                // if (contentbox.path == 'contentbox') {
                var cp = contentbox.path; // console.log("mbContentApply-1 ", contentbox, cp);
                if (cp && (cp.indexOf('contentbox') >= 0)) { 
                    contentbox = contentbox.base;
                } 

                // Verify weather (at least some) content is "well defined"
                if (map) contentbox = this._mbContentVerify(contentbox);

                if (!contentbox || !Object.keys(contentbox).length)  return; 

                // REMOVE all old content (this._contentbox) 
                // from app (from actual map) if new is prepared 
                this._mbContentCheckOut();

                // Memorize push back as 
                this._contentbox = contentbox;   

                // INSERT new content into map
                let checkedcontent = this._mbContentCheckIn(contentbox, meta); 

                this.contentfeatures = checkedcontent;
                // **********************************
            },    

            // Make contentbox "complete"  
            _mbContentVerify: function(contentbox) {    
                if (!contentbox || !Object.keys(contentbox).length) return; 

                var scope = this; // , map = scope.map;

                var verifiedContent = {}, layerObject ;
                
                // Add temporary paint-properties 
                // for easy identification of features (line-width, random colors)
                function rawBeautify(layerObject) {

                    var srcdata = layerObject.srcdata;

                    var lookuplist = [], paintObj;

                    srcdata.features.forEach(function(f) {
                        var col = f.properties.color;
                        lookuplist.push([col, col]);
                    });

                    if (true) { // Line-feature
                        paintObj = {
                            "line-width": 3,
                            "line-color": {
                                property: 'color',
                                type: 'categorical',
                                stops: lookuplist
                            }
                        }; 
                    }

                    layerObject.layer.paint = paintObj;

                    // console.log("RAW-Beautify", layerObject);

                    return layerObject.layer;
                }

                // 
                function rawEvents(layername) {

                    // Generic HILITE-function based on "id-Filter"	
                    function featureHilite(e, layerid) {

                        if (!map.getLayer(layerid)) return;
                        if (!map.getLayer(layerid + "-hover")) return;

                        // 
                        var hilayerid, hifilter;

                        var features = map.queryRenderedFeatures(e.point, {
                            layers: [layerid]
                        });

                        // CHANGE cursor temporarily
                        map.getCanvas().style.cursor = (features.length) ? 'pointer' : ''; // crosshair';

                        if (features.length) {  // Apply HILITE-FILTER  
                            
                            var fkeys = scope.guessFeatureKeys(features[0]); 
                            // scope.popupOnMap(trackInfo.html);

                            if (!fkeys) {

                                console.log("HILITING in " + layerid + ":", features[0]);
                            
                            } else {    // Filtering the HOVER-Layer
                                
                                hifilter = ["==", fkeys[0], fkeys[1]] ; // trackInfo[keyname]];
                                // console.log("hi " + layerid + ":", trackInfo.length+" km");

                                hilayerid = layerid + "-hover";
                            
                                map.setFilter(hilayerid, hifilter);
                            }

                        } else {  // remove HILITE filter 
                            
                            map.setFilter(layerid + "-hover", ["==", "name", ""]);
                        
                        }

                    }
                    // Feature-Select 
                    //   supplies info-object of selected feature 
                    //   generated by any external function       
                    function featureSelect(e, layerid) {
                        // console.log("featureSelect in ", layerid); 

                        if (!map.getLayer(layerid)) return;
                        // if (!map.getLayer(layerid + "-select")) return;

                        var features = map.queryRenderedFeatures(e.point, {
                            layers: [layerid]
                        });
                        if (!features || !features.length) return;  
                        
                        // Necessary to SYNC with content-browser after selection in map   
                        scope.featureselected = scope.featuresSelect(features, layerid);

                    }

                    function hiliter(e) {
                        featureHilite(e, layername);
                    }

                    function selector(e) {
                        featureSelect(e, layername);
                    }

                    // 
                    var eventset = {
                        "mousemove" : hiliter,
                        "click" : selector
                    };

                    return eventset;
                }

                // Create (multiple) themeLayers 
                // used to comfortably interact with datalayer in mapbox  
                function getContentTemplates(layerObject) {
                    // Compile templates of mb-layer-objects (without data)

                    function createHiliteLayer(layertemplate, hitype) {
                        
                        var lhilite = {},// layertemplate,
                            templateid = layertemplate.id + "-" + hitype;
                        // console.log("createHiliteLayer for", templateid);

                        if (hitype == "nodes") { // sonderfall
                            lhilite = {
                                    "type": "symbol",
                                    "id": templateid,
                                    "source": templateid,
                                    // "source": "",

                                    "layout": {
                                        "icon-image": "{icon}-15",
                                        "text-field": "{title}",
                                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                        "text-offset": [0, 0.6],
                                        "text-anchor": "top"
                                    },
                                    "paint": {
                                        "text-halo-color": "#ffffff",
                                        "text-halo-width": 6,
                                        "text-color": "#ff0000"
                                    }
                            };
                            return lhilite; 
                        } 
                        
                        // Copy most properties from source template 
                        // add some specific styling

                        basetype = layertemplate.type,

                        Object.keys(layertemplate).forEach(function(k) {
                            lhilite[k] = layertemplate[k];
                        })

                        lhilite.id = templateid ;
                        lhilite.filter = ["==", "id", ""];

                        var linecolor, linewidth, lineopacity, linedasharray;

                        if (hitype == "hover") {
                            linecolor = "#FF0000";
                            linewidth = 5;
                            lineopacity = 1;

                        } else if (hitype=="select")  {
                            linecolor = "#000000";
                            linewidth = 3;
                            lineopacity = 0.7;
                            linedasharray = [4,4];  
                        }

                        lhilite.paint = {
                            "line-color": linecolor,
                            "line-width": linewidth,
                            "line-opacity": lineopacity,
                        }
                        if (linedasharray) {
                            lhilite.paint["line-dasharray"] = linedasharray;
                        } 

                        // Append event functions


                        return lhilite;
                    }

                    var basicTemplate = layerObject['layer'],
                        bgTemplate = layerObject['bglayer'],
                        selectTemplates = layerObject['selectlayer'];

                    // Compile collection of     
                    var layerTemplates = [];

                    if (basicTemplate) layerTemplates.push(basicTemplate);

                    // Insert BG BELOW main layer 
                    if (bgTemplate) {
                        layerTemplates.splice(0, 0, bgTemplate); // !!! 
                    }

                    // Specify some HILITE Layer(s) for selected feature(s)
                    if (selectTemplates && selectTemplates.length) {
                        // A. Vordefinierte HILITE layers 

                        layerObject['selectlayer'].forEach(function(l) {
                            layerTemplates.push(l);
                        });

                    } else if (basicTemplate && layerObject.raw) { 
                        // B. "Standardisierte" HILITE-Layers des basic 'layer' 
                        //    wenn keine speziellen vordefiniert waren 
                        
                        // Layer that occurs during "mouse-hover"
                        let hoverTemplate = createHiliteLayer(basicTemplate, "hover");
                        if (hoverTemplate) layerTemplates.push(hoverTemplate);

                        // Layer that occurs after "selection"
                        let selectTemplate = createHiliteLayer(basicTemplate, "select");
                        if (selectTemplate) layerTemplates.push(selectTemplate);

                        var isLine = true; 
                        if (isLine) {
                            // additional commented NODES at LINE-ends
                            let nodeTemplate = createHiliteLayer(basicTemplate, "nodes");
                            if (nodeTemplate) layerTemplates.push(nodeTemplate);
                        }  
                    }

                    return layerTemplates;
                }


                var contentboxLayers = Object.keys(contentbox);   // console.log("Refreshing quickmap-layers", contentboxLayers);

                contentboxLayers.forEach(function(layername, j) {

                    layerObject = contentbox[layername];
                    // console.log("VERIFY", layername, layerObject); 

                    if (layerObject.raw) {
                        // console.log("SETUP qlayer " + layername, layerObject);
                        layerObject.layer = rawBeautify(layerObject);
                    }

                    if (!layerObject.templates) {
                        layerObject.templates = getContentTemplates(layerObject);
                    }    


                    if (!layerObject.events) { 
                        layerObject.events = rawEvents(layername);
                    }

                    verifiedContent[layername] = layerObject;
                })
                // console.log("NEW contentBox", verifiedContent);  
                return verifiedContent; 
            },


            // Insert all layers of contentbox 
            _mbContentChecker: function(contentbox, flag) {    
                if (!contentbox || !Object.keys(contentbox).length) return; 
                if (!flag) flag = "IN";

                var scope = this;
                // var map = scope.map;

                // create linear list of features 
                // suitable for "menu-generation"
                function getFeatureList(layerData, layername, longtitle) {
                    // console.log("getFeatureList", layername, layerData);

                    var flist = [],
                        fitem = {},
                        id, title, i = 0;
                    if (!layerData || !layerData.features) return flist;

                    layerData.features.forEach(function(f) {
                        id = f.id;
                        if (typeof id == "undefined") id = f.properties.name;
                        if (typeof id == "undefined") id = f.properties.time;
                        // Typische Nachbearbeitung
                        if (typeof id == "string") {
                            id = id.replace("ACTIVE LOG:", "");
                            title = id.replace(/-/g, "_");
                        } else if (id) {
                            title = id.toString(); 
                        } else {
                            title = "F-" + i; 
                        }

                        if (longtitle) title = layername + "_" + title;
                        title = title.replace(/ /g, "");

                        fitem = {
                            "layer": layername,
                            "id": id,
                            "title": title,
                            "feature": f
                        };
                        flist.push(fitem);
                        i = i + 1; 
                    })

                    return flist;
                }
                // 
                function addMapContent(layername, layerObject){

                    var layerData = layerObject.srcdata;
                    if (!layerData) return ; 

                    var layerSource = map.getSource(layername),
                        mapLayer = map.getLayer(layername);

                    if (!layerSource) {   // 1.A. Add(create) mapSource 

                        map.addSource(layername, {
                            "type": "geojson",
                            "data": layerData
                        });
                        layerSource = map.getSource(layername);

                    } else {              // 1.B  Update data of existing mapSource  
                       layerSource.setData(layerData);
                    }  // console.log("SET SRC", layername, layerData, layerSource._data);


                    // 1.C. (Re)Create all layer(s) of same srcdata 
                    if (!mapLayer) {
                        // console.log("layerTemplates for " + layername, layerTemplates, layerSource);
                        
                        var layerTemplates = layerObject.templates;
                
                        layerTemplates.forEach(function(template) {

                            if (!map.getLayer(template.id)) {
                                // console.log("adding layer " + template.id, template);
                                
                                // console.log("Set placeholder-source !!", template.source); 
                                if ((template.type == "symbol") && template.source) { 
                                    if (!map.getSource(template.source)) {   
                                        map.addSource(template.source, {
                                            "type": "geojson",
                                            "data": { "type": "Point", "coordinates": [0, 0] }
                                        });
                                    }    
                                }

                                map.addLayer(template);
                            }
                        });

                        mapLayer = map.getLayer(layername);
                    }

                    // Check layer content  
                    if (mapLayer) { 
                    /*
                        var features = map.querySourceFeatures(layername, {
                            filter: null
                        });
                        console.log("Checked "+features.length + " features of layer [" + layername+ "]"); // , features, layerSource);
                    */
                    }
                    return layerData; 

                }

                //
                function toggleContentEvents(layerObject, flag){

                    var eventset = layerObject.events;
                    var events = Object.keys(eventset);

                    events.forEach(function(ev){
                        if (flag=="IN") {
                            map.on(ev, eventset[ev])
                        } else {
                            map.off(ev, eventset[ev])
                        }    
                    }); 

                }
                // 
                function removeMapContent(layerObject) {
                    if (!map) return ;

                    var contentTemplates = layerObject.templates;
                    // console.log("removeMapContent contentTemplates", contentTemplates, layerObject); 
                    // deactivate related events 

                    // remove Layers
                    contentTemplates.forEach(function(template) {
                        var qlayername = template.id,
                            qlayer = map.getLayer(qlayername);

                        // console.log("remove qlayer", qlayername, qlayer) ;                        
                        if (qlayer) {
                            map.removeLayer(qlayername);
                        }  
                   });  

                   // remove Sources
                   contentTemplates.forEach(function(template) { 
                        var srcid = template.source,
                            qsrc = map.getSource(srcid);
                        // console.log("remove qsource ", srcid, qsrc);
                        if (qsrc) {
                            map.removeSource(srcid);
                        }   
                    })    
                }

                // --------------------------------------------------

                var mapcontent = {};
                
                var contentboxLayers = Object.keys(contentbox);   // console.log("Refreshing contentboxlayers", contentboxLayers, contentbox);

                contentboxLayers.forEach(function(layername, j) {

                    var layerObject = contentbox[layername],
                        contentfeatures = [];
                    // console.log("CHECK-CONTENT-"+flag+" of " + layername, layerObject);

                    // Option 
                    if (flag == "IN") { // ADD/REFRESH a contentbox object 

                        var layerData = layerObject.srcdata;

                        if (map)  {
                            console.log("MAP ADD content: "+layername, layerObject);
                            layerData = addMapContent(layername, layerObject);
                        } 

                        if (layerData) {   // Check/Get all source-features of the basic layer 
                            contentfeatures = getFeatureList(layerData, layername);
                            // console.log("CHECKED-"+flag+" ["+layername+"].", "feat.cnt=" + contentfeatures.length); // , contentfeatures);
                        }                        

                    }   else {        // REMOVE object (on demand)

                        if (map) removeMapContent(layerObject); 
                        // console.log("CHECKED-"+flag+" [" + layername+"]", layerObject); 
                    } 
                    
                    // console.log("TOGGLEevents-"+flag +" [" + layername+"]", layerObject); 
                    if (map) toggleContentEvents(layerObject, flag) 

                    // Add layer-features to mapcontent
                    if (contentfeatures.length) {
                        // console.log("contentfeatures of " + layername, contentfeatures);
                        mapcontent[layername] = {
                            "features": contentfeatures,
                            "usefeatures": layerObject['usefeatures']
                        }    
                    }  

                }.bind(this));

                return mapcontent; 
            },

            // Remove previous Content-layers
            _mbContentCheckOut: function() { 
                // if (!this._contentbox || !Object.keys(this._contentbox).length) return; 
                var oldcontent = this._mbContentChecker(this._contentbox, "OUT") ;    
                if (oldcontent)  console.log("MAP-OUT-features", oldcontent);
            },

            // Add/Insert layers according contentbox
            _mbContentCheckIn: function(contentbox, meta) { 
                var mapcontent = this._mbContentChecker(contentbox, "IN") ;
                if (mapcontent)  {
                    console.log("MAP-IN-features", mapcontent, meta);
                    return mapcontent; 
                }    
            },


            /**
             * Create a linear LIST(array) of all features  
             * of the mapcontent-layer (marked with flag 'usefeatures' if more layers) 
             * and supply as notify-parameter 'featuresused'
             */
            contentFeaturesToList: function(contentfeatures, keys) {
                if (contentfeatures.path == 'contentfeatures') contentfeatures = contentfeatures.value;
                if (!contentfeatures || !Object.keys(contentfeatures).length) return;
                
                if (!keys) keys = Object.keys(contentfeatures);
                
                // Select features from layer with basefeatures only !! 

                var obj, featuresused = [];

                keys.forEach(function(lname) {
                    obj = contentfeatures[lname];
                    // add features to featuresused if layer is "marked with 'usefeatures' " 
                    // or if only one layer exists in contentfeatures  
                    if ((keys.length == 1) || obj.usefeatures) { // 
                        obj.features.forEach(function(item) {
                            featuresused.push(item);
                        })
                    } 
                });

                this.featuresused = featuresused; // NOTIFIES  !!
                // console.log("GOT contentFeaturesToList :", layernames, featuresused);
            },

        })
    </script>
</dom-module>                  