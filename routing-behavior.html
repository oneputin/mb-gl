<link rel="import" href="../polymer/polymer.html">

<script>
  /**
   * `Mbb.RoutingBehavior` 
   * Note, the `BehaviorRouting` event is non-bubbling.
   *
   * @polymerBehavior Mbb.RoutingBehavior
   * @demo demo/index.html
   **/
    window.Mbb = window.Mbb || {};

    Mbb.RoutingBehavior = {

        properties: {

            // I. Import properties
            /**
             * collection of trackRoutes (as processed by routing API) 
             */
            routedata: {
                type: Object,
                notify: true
            },

            /**
             * url to trackRoute-data
             */
            url: {
                type: String
            },

            /**
             * url to trackObj-masterdata
             */
            basedataurl: {
                type: String
            },

            /**
             * raw trackRoutes (json data)
             */
            rawdata: {
                type: Object
            },

            /**
             * raw trackObjects (as JSON)  
             */
            rawmasterdata: {
                type: Object
            },

            /**
             * collection of trackObjects-data that may be included into INFO-Popup
             * (masterdata or optionally time dependent)
             */
            masterdata: {
                type: Object
            },

            // II. Info-compilation

            /**
             *  collection of trackObj-data (id-,location-data) describing actual status
             */
            trackdata: {
                type: Object,
                value: {}
            },

            /**
             * tarckObj-data compiled for use as popup in map-api 
             */
            trackinfo: {
                type: Object,
                value: {},
                notify: true
            },


            // III. Presentation as draggable CARD-object

            /**
             * { item_description }
             */
            carddata: {
                type: Object,
                value: {}
            },

            /**
             * { item_description }
             */
            cardimgurl: {
                type: String
            },

            /**
             * { item_description }
             */
            dragctrl: {
                type: Object,
                value: {}
            },

            // Behavior of drag-element
            // flow, left, right
            dragtype: {
                type: String,
                value: "flow"
            }

        },

        observers: [
            'processTrackdata(trackdata.*)',
            // 'refreshCardContent(carddata)',

            '_drag(dragctrl.x, dragctrl.y, dragtype)',
            '_toggle(carddata.open)'
        ],

        'listeners': {
            "track": '_myPopupTrackHandler',
            "tap": '_onBackClick'
        },

        // Get Info about "complete track", not only features in actually "visible" tile(s)
        trackGetInfo: function(aLine, layerid) {
            if (!this.map) return; 
            
            var scope = this,
                map = this.map;

            var trackInfo = aLine.properties; // console.log("trackInfo", trackInfo, srcFeatures); 

            // Get SOURCE-properties for identified feature !!!
            var keys = this.guessFeatureKeys(aLine); 
            if (keys) {
                trackInfo.keyname = keys[0];  
                trackInfo.keyvalue = keys[1];  
                trackInfo.id = keys[1];

                var trackLayer = map.getLayer(layerid),
                    trackSource = map.getSource(trackLayer.source),
                    srcFeatures = trackSource._data.features;

                var keyname = trackInfo.keyname; 
                srcFeatures.some(function(f){
                    if (f.properties[keyname] == trackInfo[keyname]) {
                        // console.log("detected", trackInfo[keyname], f);
                        trackInfo.bbox = scope.setFeatureBounds([f]);
                        trackInfo.coords = f.geometry.coordinates;
                        trackInfo.fromnode = trackInfo.coords[0];
                        trackInfo.tonode = trackInfo.coords[trackInfo.coords.length - 1];
                        trackInfo.length = scope.deltaL(f);
                        return true;
                    }
                });
            }
            
            // Get typical track time parameters 
            if (trackInfo.coordTimes) { 

                var trackTimes = trackInfo.coordTimes; // console.log("trackTimes", typeof trackTimes, trackTimes);
                if (typeof trackTimes == "string") trackTimes = JSON.parse(trackTimes);
                // console.log(trackInfo, trackTimes);
                
                var n = trackTimes.length, // equal to number of coords
                    tvon = scope.trackTime(trackTimes[0]);
                    tbis = scope.trackTime(trackTimes[n - 1])
                    von = scope.utcTime(tvon, null, "h"),
                    bis = scope.utcTime(tbis, null, "h"),
                    dt = bis - von;
                // console.log(trackTimes[0],trackTimes[n-1], tvon, tbis, von,bis,dt);

                trackInfo.duration = scope.deltaT(dt);
                trackInfo.count = n;
                trackInfo.von = scope.logTime(von, "h");
                trackInfo.bis = scope.logTime(bis, "h");
            }

            // compile basic parameters as HTML 
            trackInfo.html = trackInfo.time +
                "<br>Length: " + trackInfo.length +
                "<br>Duration: " + trackInfo.duration +
                "<br>TP's: " + trackInfo.count;

            return trackInfo;
        },

        // Special "permanent" HILITE of selected tracks
        // by HILITE-TRACE + "commented" end-nodes  
        tracksHilite: function(features, layerid) {
            // by now for 1 feature onyl
            // var map = this.map; 

            if (!features || !features.length) return;  
        
            // this.debounce("track", function(){
            var trackFeature = features[0]; 
            
            // Create trackEndMarkers
            function setTrackNodes(layerid, trackInfo) {
                // layer of nodes symbols with text in HALO
                var hilayerid = layerid + "-nodes",
                    hilayer = map.getLayer(hilayerid);
                if (!hilayer) return; 
                
                var fromicon = "toilet"; // "monument",
                    toicon = "harbor";

                var fromnode = trackInfo.fromnode.slice(0,2),
                    tonode = trackInfo.tonode.slice(0,2),
                    fromtime = trackInfo.von,
                    totime = trackInfo.bis,
                    nodedata = { // for nodes-source = 2 points
                        "type": "FeatureCollection",
                        "features": [{
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": fromnode
                            },
                            "properties": {
                                "title": fromtime,
                                "icon": fromicon
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": tonode
                            },
                            "properties": {
                                "title": totime,
                                "icon": toicon
                            }
                        }]
                    } ;

                // map.addSource(layerid, node);    
                var src = map.getSource(hilayerid); 
                if (src)  {
                    // console.log("set nodes-data into ", hilayerid, nodedata, src); 
                    src.setData(nodedata);                     
                }    
            } 

            // HILITE the TRACE of the track (Filtering-Layer)
            function setTrackTrace(layerid, trackInfo) {
                // 
                var hilayerid = layerid + "-trace", // ?
                    hilayer = map.getLayer(hilayerid),  
                    keyname = trackInfo.keyname,
                    hifilter = ["==", keyname, trackInfo[keyname]];
                if (!hilayer) return ;

                // console.log("set trace-filter in " + hilayerid, hifilter, hilayer); 
                map.setFilter(hilayerid, hifilter);
            } 

            var trackInfo = this.trackGetInfo(trackFeature, layerid);  // console.log("Selected track(s)", trackInfo);  

            // APPLY start- and stop-nodes of track
            setTrackNodes(layerid, trackInfo); 

            // APPLY trace-overlay (gestrichelt) on track
            setTrackTrace(layerid, trackInfo); 

            // Triggersignal to enable ZOOM & SYNC with sibling elements (fi. with menues )
            if (trackInfo.id)  this.featureselected = trackInfo;

            // ZOOM to complete track
            map.fitBounds(trackInfo.bbox, {
                padding: 40
            });

            // Prepare info-popup after mapFit
            map.once('moveend', function() {
                this.popupOnMap(trackInfo.html);
            }.bind(this));
        
            // }, 100);     

        },

        // A. DATA-INTERFACE 

        /**
         * LOAD raw data via ajax
         *
         * @param   {<type>} ajaxresponse : basic routedata as wp-dataset (packaged in default ajax-response)
         */
        getrawdata: function(ajaxresponse) {
            if (!ajaxresponse || !ajaxresponse.detail) return;
            // console.log("GET " + dataname, ajaxresponse.detail.response);
            // var rawdata = ajaxresponse.detail.response;
            // if (!rawdata) return;
            this.rawdata = ajaxresponse.detail.response; // triggers 'setupTracking'
        },

        // Zoom to bbox of all nodes in raw routedata (waypoints, trackpoints) 
        trackNodesZoomToX: function(routedata, routeid) {
            if (!routedata) routedata = this.routedata;

            // Collect routenode-coordinates
            var coordinates = [],
                coords_datum = [],
                neast = 0,
                nwest = 0,
                lmin, lmax, dl, bounds, center,
                startmode = false;

            // "NOT-Heuristic" zum Problem Datumsgrenze
            // a.  
            routedata.forEach(function(route, j) {
                if (route.nodes) {
                    route.nodes.forEach(function(wp, i) {
                        var lng = wp.coords[0];
                        nwest = lng < 0 ? nwest + 1 : nwest;
                        neast = lng > 0 ? neast + 1 : neast;
                        if (!lmin) {
                            lmin = lng;
                            lmax = lng;
                        }
                        lmin = lng < lmin ? lng : lmin;
                        lmax = lng > lmax ? lng : lmax;
                    })
                }
            });
            if (!lmax && !lmin) return;

            // b. 
            dl = lmax - lmin;
            // console.log("delta-lng=" + dl, "nwest=" + nwest, "neast=" + neast);
            routedata.forEach(function(route, j) {
                route.nodes.forEach(function(wp, i) {
                    var lng = wp.coords[0];
                    if (dl < 180) coordinates.push(wp.coords);
                    else if ((lng < 0) && (nwest > neast)) coordinates.push(wp.coords);
                    else if ((lng > 0) && (neast > nwest)) coordinates.push(wp.coords);
                })
            });

            // Specialcase !!
            if (startmode) { // workaround for coords around dateline
                center = coordinates[0];
            } else { // create bounds around all wp-coordinates
                // startvalue 
                bounds = new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]);
                // collect all 
                bounds = coordinates.reduce(function(bounds, coord) {
                    return bounds.extend(coord);
                }, bounds);

                center = bounds.getCenter();
            }
            // console.log("center, wp-coordinates", center, coordinates);

            if (bounds) {
                map.fitBounds(bounds, {
                    padding: 20
                });
            }
        },


        // B. DISPLAY-INTERFACE 

        /**
         * Manages the alternative approaches to create an INFO-POPUP 
         *
         * @param      {<type>}  trackdata  data related to a trackObj 
         */
        processTrackdata: function(trackdata) {
            if (!trackdata || !trackdata.value) return;
            trackdata = trackdata.value;
            // console.log("processing trackdata", trackdata);

            var trackobj = trackdata.trackobj,
                lnglat = trackdata.lnglat,
                openflag = trackdata.open;

            // if (!trackobj) return;

            if (this.calcExtendedInfo) {
                // A. 
                this.carddata = this.calcExtendedInfo(trackobj, openflag);

            } else if (this.calcBasicInfo) {
                // B. Calc a mapPopup with 
                this.trackinfo = {
                    "html": this.calcBasicInfo(trackobj),
                    "lnglat": lnglat,
                    "open": openflag
                }
            }
        },

        // C: POPUP-Handling
        /**
         * Manages interactive drag-behavior of     
         *     Combines last track(tap)-coordinates with coordinates at start  
         *     into new location of tracked element 
         * @param      {<type>}  e  { parameter_description }
         */
        _myPopupTrackHandler: function(e) {
            //e.cancelBubble = true;
            //e.stopPropagation();
            var style = window.getComputedStyle(this),
                top = parseFloat(style.getPropertyValue('top')),
                left = parseFloat(style.getPropertyValue('left')),
                dy = e.detail.y - top,
                dx = e.detail.x - left,
                x, y;

            switch (e.detail.state) {
                case 'start':
                    this.dragctrl.msg = 'Tracking started at top=';
                    this.dragctrl.dx = dx;
                    this.dragctrl.dy = dy;
                    this.unlisten(this, 'tap', '_onBackClick');
                    // console.log("start:x,y,dx,dy",left, top, dx, dy);
                    break;
                case 'track':
                    // console.log(this.dragctrl);
                    this.dragctrl.msg = "Tracking...";
                    this.set('dragctrl.x', left + dx - this.dragctrl.dx);
                    this.set('dragctrl.y', top + dy - this.dragctrl.dy);
                    break;
                case 'end':
                    this.dragctrl.msg = 'Tracking ended!';
                    this.listen(this, 'tap', '_onBackClick');
                    break;
            }
        },

        /**
         * Translate ctrl-values of dragObject into style-properties
         *
         * @param      {string}  x         { parameter_description }
         * @param      {string}  y         { parameter_description }
         * @param      {<type>}  dragtype  drag-behavior
         */
        _drag: function(x, y, dragtype) {
            //console.log("drag", x, y);
            this.style.left = x + "px";
            this.style.top = y + "px";
            if (dragtype) this.style.right = "auto";
        },
        /**
         * Toggle visibility of drag-element
         *
         * @param      {number}  open    The status to toggle into 
         */
        _toggle: function(open) {
            if (open == 0) {
                this.style.display = "none";
            } else if (open == 1) {
                this.style.display = "inline-block";
                this.style.right = "0px";
            }
        },
        /**
         * Default tap-action of close elements
         */
        _onBackClick: function() {
            this._toggle(0);
            // this.style.display = "none";
        }
    };

</script>