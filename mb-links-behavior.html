<link rel="import" href="../polymer/polymer.html">

<script>
  /**
   * `Mbb.LinksBehavior` 
   * Utilities to create and manage pointLinks 
   *
   * @polymerBehavior Mbb.LinksBehavior
   * @demo demo/imagelinks.html
   **/
    window.Mbb = window.Mbb || {};

    Mbb.LinksBehavior = {

        properties: {

            // checkIn/checkOut : selected doc(img)
            docselected : {
                type: Object,
                observer: '_logProperty',
                notify : true
            },
            // checkIn/checkOut : selected doc(img)
            linkdocid : {
                type: String,
                observer: '_queryDoc'
            },
            
            mbbtest: {
                value: 99
            },
            popup:{
                type: Object
            },
            clustered: {
                type: Array,
                value: [],
                notify:true
            },
            featureidname : {
                type: String,
                value: "name"
            },
        },

        observers: [
            'trackDocsUnlinked(_sessionUnSet.length)'
        ],

        // generic debug-util
        _logProperty: function(prop) {
            // console.log("_logProperty", prop);
        },

        // trigger "idSelect" on sessionDocs
        _queryDoc: function(docid){  
            var docselected = this._sessionDocs[docid]; // console.log("_queryDoc", docid, docselected, this.docselected); // this._sessionDocs);
            if (docselected) this.docselected = docselected; 
        },


        // MB-specific tool to remove duplicates !!
        _mbUniqueFeatures: function(features, idname) {
            if (!idname) idname = "name"; // the property for unique id 
            var uniqs = [], ids = [], id = "";

            features.forEach(function(f) {
                id = f.properties[idname];
                if (!id || (ids.indexOf(id) < 0)) {
                    ids.push(id);
                    uniqs.push(f);
                }   
            });
            return uniqs; 
        },

        _mbGetBounds : function(features, asfeature) {    

            var bounds = map.getBounds(); 

            if (features) {
                
                if (features.features) features = features.features; // if a feature-set was passed

                var coord0 = features[0].geometry.coordinates;
                bounds = features.reduce(function(bounds, feature) {
                    var coord = feature.geometry.coordinates;
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coord0, coord0));
            }  

            if (!asfeature) return bounds; // console.log("bounds", bounds, asfeature);
            
            var e = bounds.getEast(), s = bounds.getSouth(), w = bounds.getWest(), n = bounds.getNorth(),
                p = [[[w,s], [w,n], [e,n], [e,s], [w,s]]];  // console.log("boundrect", e,s,w,n,p);  
            
            var bb = {
                "type": "Feature",
                "properties": {},
                "geometry": {
                    "type": "Polygon",
                    "coordinates": p
                }
            };
            return bb; 
        },     

        // Test the layer status
        _linkLayerStatus : function(layid) {
            if (!layid) layid = this.layerid;
            var status = {
                id : layid,
                src :  map.getSource(layid),
                layer : map.getLayer(layid)
            };  // console.log("_linkLayerStatus", status);  
            return status;  
        },

        // generic click-listener
        _mapClickListener : function(e) {
            var f = wpscope._mapeventListener(e); 
            if (!f) return; // console.log("clicked",f);

            wpscope._checkoutDocFromMap(f);
        }, 

        // generic hover-listener
        _mapHoverListener : function(e) {
            var f = wpscope._mapeventListener(e); 
            if (!f) return; 
            wpscope.hoverAction(features[0]);
        }, 

        // GENERIC select-event-translator
        _mapeventListener : function(e) {
            var st = wpscope._linkLayerStatus(); 
            if (!st.layer) return ;  

            var features = map.queryRenderedFeatures(e.point, {
                layers: [st.id]
            });
            if (!features || !features.length) return;   
            return features[0];
        },    

        // Refresh the "src"(content) of "explored" data-layers 
        // creates layers if not yet existing 


        // Update viewPort to include last loaded locations  
        _viewSelectedFeatures : function(selectedFeatures, zoomflag) {
            // different actions methods 
            var ff = selectedFeatures;

            function bbFunction(features, asfeature) {    

                var bounds = map.getBounds(); 

                if (features) {
                    
                    if (features.features) features = features.features; // if a feature-set was passed

                    var coord0 = features[0].geometry.coordinates;
                    bounds = features.reduce(function(bounds, feature) {
                        var coord = feature.geometry.coordinates;
                        return bounds.extend(coord);
                    }, new mapboxgl.LngLatBounds(coord0, coord0));
                }  

                if (!asfeature) return bounds; // console.log("bounds", bounds, asfeature);
                
                var e = bounds.getEast(), s = bounds.getSouth(), w = bounds.getWest(), n = bounds.getNorth(),
                    p = [[[w,s], [w,n], [e,n], [e,s], [w,s]]];  // console.log("boundrect", e,s,w,n,p);  
                
                var bb = {
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Polygon",
                        "coordinates": p
                    }
                };
                return bb; 
            };

            // Simple fitbounds for point-features
            function zoomFunction(bounds, padding) {
                if (padding== null) padding = 20; // pixels ?
                map.fitBounds(bounds, {
                    padding: 30
                }); 
            };     

            // Add a buffer feature around single-point !!
            if (ff.length < 2) {  
                var spoint = ff[0]; 
                var bbnow  = bbFunction(null, true); 
                
                // SHOW the last linkPoint CENTERED
                if (!zoomflag) { console.log("NOZOOM: bbox as rect, pnt", bbnow, spoint);

                    if (turf.inside(spoint, bbnow)) { //console.log("addedPnt(s) inside actual viewport!")
                        return; 
                    }    

                    map.flyTo({
                        center: spoint.geometry.coordinates
                    }); 
                    return; 
                }   console.log("ZOOMTO pnt", spoint, zoomflag); 


                // HILITING in suitable Umkreis with "radius" (default 5km)
                var radius = 5,
                    units = 'kilometers',
                    steps = 10;
                if (typeof zoomflag == "number") radius = zoomflag; 

                var pp = turf.explode(turf.circle(spoint, radius, steps, units));

                ff = ff.concat(pp.features);   
            }

            var bb = bbFunction(ff); 

            zoomFunction(bb);
        },  
        
        _refreshLinks: function(rawdata) {
            
            if (!rawdata || !rawdata.type) {
                console.log("BREAK. 1  no location data attached!");
                return;  
            } 

            // 1. ReCheck structure as featureset
            var featuresetRefresh = rawdata; 
            
            if (!featuresetRefresh.features) {
                featuresetRefresh = {
                    "type": "FeatureCollection",
                    "features": [featuresetRefresh]
                }
            }    
            if (!featuresetRefresh.features.length) {
                console.log("BREAK. 2  no location data attached to ", rawdata);
                return;  
            } 

            // Update viewPort to include last loaded locations  
            var showAddedFeatures = this._viewSelectedFeatures; 

            // 2. Check/Create/Update "LinkLayer"-Data

            var st = this._linkLayerStatus();  // console.log("_refresh Layer " + st.id, st, rawdata, featuresetRefresh); 
            var addedFeatures = [];

            if (!st.layer) {   console.log("FIRST link-layer-setup from", rawdata);

                addedFeatures = this._createLayers(st.id, featuresetRefresh);
                
                // warum Timeout ???
                setTimeout( function() {
                    showAddedFeatures(addedFeatures);
                }, 500);  
            
            }  else {          // Update dataSource

                var oldFeatures = this._sessionSet.features,
                    tryFeatures = featuresetRefresh.features; // console.log("old", oldFeatures) ; console.log("try", tryFeatures) ;

                // Filtering only features with a new name  
                var addedFeatures = tryFeatures.filter(function(item){
                    var isOld = false;
                    oldFeatures.some(function(old){
                        if (old.properties.name === item.properties.name) {
                            isOld = true;
                            return;
                        } 
                    })
                    return !isOld;
                }); // console.log("really new features", addedFeatures); 
                if (!addedFeatures.length) return;   

                this._sessionSet.features = this._sessionSet.features.concat(addedFeatures); 

                // REFRESH LINKDATA-SRC   with addedFeatures 
                //console.log("new, all features", featuresetRefresh, this._sessionSet) ; 
                map.getSource(st.id).setData(this._sessionSet);

                showAddedFeatures(addedFeatures); 

            }

            // 3.  
            if (this._checkoutDocFromMap) {
                // map.off('click', this._mapClickListener);
                // map.on('click', this._mapClickListener);
            } 

            if (this.hoverAction) {
                // map.off('hover', this.hoverListener);
                // map.on('hover', this.hoverListener);
            }

            return {features: addedFeatures} ;
        },

        // 
        _refreshMap: function(featuresetLocated) {
            if (!featuresetLocated) return; 
            // console.log("_refreshMap LinkPoints of ImageSet Located", featuresetLocated); // .locations, imagesetLocated.geojson); 

            map.showTileBoundaries = true; // for DEBUG 

            var imageset = this.imageset;  // console.log("_refreshMap ImageSet Raw",  imageset); 

            // var featureSet = featuresetLocated; // .geojson; 

            featuresetLocated.features.forEach(function(f){
                if (!f.properties.img) {
                    var name = f.properties.name, img="" ; 
                    // Integrate the img into properties
                    imageset.some(function(obj){
                        if (obj.name == name) {
                            img = obj.value;
                            return;
                        }     
                    });
                    f.properties.img = img;
                }
            }); // console.log("_refreshMap FeatureSet", featureSet); 
            
            this._refreshLinks(featuresetLocated);
        },

        // Create an suitably "clustering" layer
        _createLayers : function(srcname, featureset, idname) {    
            if (!idname) idname = "name"; 
            this._sessionSet = featureset;
            
            // 
            var clusterMode = true,
                markermode = false,
                popupClusterMode = true,
                popupLinkMode = true;

            var vis = "none";
            if (this.visible) vis = "visible";

            // A. SOURCE 
            // B. Create LAYER(s) of SOURCE
            var l_circle = {
                "id": srcname,
                "type": "circle",
                "source": srcname,
                "layout" : {
                    "visibility": vis
                },
                "paint": {
                    "circle-radius": 20,
                    "circle-color": "#FFFFFF",
                    "circle-stroke-width": 2,
                    "circle-stroke-color": "#B42222"
                },
                "filter": ["==", "$type", "Point"],
            }; // console.log("added img-link-layer", map.getLayer(srcname) ); 
            
            var l_symbol = {
                "id": srcname,
                "type": "symbol",
                "source": srcname,
                "layout" : {
                    "icon-image": "attraction-15",
                    "icon-size" : 2,
                    "visibility": vis
                },
                "filter": ["==", "$type", "Point"],
            };

            /* additional layout-parameters to show a label
                    "text-field": "{name}",
                    "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                    "text-offset": [0, 0.6],
                    "text-anchor": "top",
            */        
            var scope = this;

            if (!clusterMode) {  // B.1  Simple PointLayer
                // A. Pure source
                map.addSource(srcname, {
                    "type": "geojson",
                    "data": featureset
                });
                // B. 1 uniform layer
                map.addLayer(l_circle);  // console.log("added img-link-layer", map.getLayer(srcname) ); 

            } else {                  // B.2 LayerGROUP with clusters (to best visualize the content of SOURCE) 
        
                // A. Source with cluster-properties 
                var clusterRadius = 50,
                    clusterMaxZoom = 14,
                    bgLayer = l_circle;  
                    pntLayer = l_symbol; 
                bgLayer['filter'] = ["!has", "point_count"];  
                pntLayer['filter'] = ["!has", "point_count"];  

                var Popup;

                map.addSource(srcname, {
                    "type": "geojson",
                    "data": featureset,
                    "cluster": clusterMode,
                    "clusterMaxZoom": clusterMaxZoom, // Max zoom to cluster points on
                    "clusterRadius": clusterRadius    // Radius of each cluster when clustering points (defaults to 50)
                });

                // B. 3 Layers 

                // 1.Cluster-Symbol (BG) 
                map.addLayer({
                    id: "clusters",
                    type: "circle",
                    source: srcname,
                    filter: ["has", "point_count"],
                    paint: {
                        "circle-color": {
                            property: "point_count",
                            type: "interval",
                            stops: [
                                [0, "#51bbd6"],
                                [5, "#f1f075"],
                                [20, "#f28cb1"],
                            ]
                        },
                        "circle-radius": {
                            property: "point_count",
                            type: "interval",
                            stops: [
                                [0, 20],
                                [5, 30],
                                [20, 40]
                            ]
                        }
                    }
                });

                // 2. Cluster-Label (FG)
                map.addLayer({
                    id: "cluster-count",
                    type: "symbol",
                    source: srcname,
                    filter: ["has", "point_count"],
                    layout: {
                        "text-field": "{point_count_abbreviated}",
                        "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
                        "text-size": 12
                    }
                });

                // 3. NON-clustered points
                // map.addLayer(bgLayer);
                map.addLayer(pntLayer);
                
                // Setup EVENT-listeners  to Refresh customMarkers of "PURE" points
                if (markermode ) {
                    map.on('zoomend', function(){
                        scope._checkMarkers(srcname, idname);
                    });

                    map.on('moveend', function(){
                        scope._checkMarkers(srcname, idname);
                    });
                }


                // EVENTS to query features "below" a cluster-point
                var scope = this;

                // Create generic itemdata {value:value, text:text}
                // for gui-elements 
                function featureList(points) { 
                    var itemdata = [], json, text;
                    points.forEach(function(pnt){
                        text = pnt.properties.name.split(".")[0]; // removes extensions (fi .jpg)
                        json = JSON.stringify(pnt); 
                        itemdata.push({text:text, value: json});
                    }); 

                    // Sort itemdata alphabetically by 'text' 
                    itemdata.sort(function(a, b) {
                        // return parseFloat(a.text) - parseFloat(b.text);
                        return a.text.localeCompare(b.text);
                    }); //console.log("itemdata of linkpoints",itemdata);
                    
                    return itemdata
                };    

                var viewFunction = this._viewSelectedFeatures;

                // translate deltaPix to deltaMap (DD, KM, miles)
                var distFunction = function (dpix, unit){
                    var p1 = map.getCenter().toArray(),
                        pix1 = map.project(p1), 
                        pix2 = pix1.clone(); 
                    pix2.x = pix2.x + dpix; 

                    var p2 = map.unproject(pix2).toArray(), 
                        km = turf.distance(p1, p2, unit); // console.log("km-distance", km, p1, pix1, pix2, p2); 
                    return km; 
                };

                map.on('click', 'clusters', function (e) {
                    // var clusterradius = 1;

                    function createClusterPopupDom(features){ //console.log(this); 

                        var popupDom = document.createElement("div");
                        popupDom.style.backgroundColor = "lightgray";
                        // popupDom.style.position = "relative";

                        // 1. ZOOMBTN
                        var zoomBtn = document.createElement("paper-button");
                        zoomBtn.style.margin = "3px";
                        zoomBtn.style.backgroundColor = "white";
                        zoomBtn.setAttribute("raised", true); 
                        zoomBtn.appendChild(document.createTextNode("ZoomToCluster"));

                        zoomBtn.addEventListener('tap', function(e){
                            // APP-Action: 
                            viewFunction(features);
                            Popup.remove();
                        });

                        // 2. Menu of features
                        var clusterKm = distFunction(50);

                        var itemList = featureList(features); 
                        var menu = document.createElement("paper-menu");
                        itemList.forEach(function(itemData){
                            item = document.createElement("paper-item");
                            item.style.cursor = "pointer";

                            item.setAttribute("value", itemData.value);
                            item.classList.add("cluster");
                            item.appendChild(document.createTextNode(itemData.text));

                            item.addEventListener('tap', function(e){
                                // 
                                // scope.linkdocid = e.target.getAttribute("value");
                                f = e.target.getAttribute("value"); 
                                f = JSON.parse(f); // console.log("value=", f); //  return;   
                                viewFunction([f], clusterKm);
                                Popup.remove();
                            });
                        
                            menu.appendChild(item);
                        });

                        popupDom.appendChild(zoomBtn);
                        popupDom.appendChild(menu);
                        
                        return popupDom;
                    }

                    var clusterPnt = e.features[0],
                        clusterPix = map.project(clusterPnt.geometry.coordinates); // console.log("ClusterPoint:", clusterPnt, clusterPix, e.point);

                    var linkPnts = scope._sessionSet.features;  //console.log("clusters, All links", clusters, links);

                    // FILTER points "under" Cluster : SPECIALFILTER (from stackOverflow)
                    var pointsInCluster = linkPnts.filter(function(f){
                        var pointPixels = map.project(f.geometry.coordinates);
                        var pixelDistance = Math.sqrt(
                            // Math.pow(e.point.x - pointPixels.x, 2) + 
                            // Math.pow(e.point.y - pointPixels.y, 2) 
                            Math.pow(clusterPix.x - pointPixels.x, 2) + 
                            Math.pow(clusterPix.y - pointPixels.y, 2) 
                        );
                        return Math.abs(pixelDistance) <= clusterRadius;
                    }); // console.log("clustered linkPoints", pointsInCluster);

                    // Alternives for itemdata-usage
                    if (popupClusterMode) {
                        // 
                        var popupContent = createClusterPopupDom(pointsInCluster); 
                        Popup = new mapboxgl.Popup()
                            .setLngLat(clusterPnt.geometry.coordinates)
                            .setDOMContent(popupContent)
                            .addTo(map);
                    } else {
                        // Trigger actions in outside elements listening for property "clustered"  
                        scope.clustered = featureList(pointsInCluster);
                    }

                });

                map.on('mouseenter', 'clusters', function () {
                    map.getCanvas().style.cursor = 'pointer';
                });
                map.on('mouseleave', 'clusters', function () {
                    map.getCanvas().style.cursor = '';
                });

            }

            // Only if clicked on layer "srcname"
            map.on('click', srcname, function (e) {

                var ff = map.queryRenderedFeatures(e.point),
                    lnkFeature = ff[0];  // console.log("selected in " + srcname, lnkFeature); 

                if (popupLinkMode) {
                    // 
                    function createLinkPopupDom(f){
                        var props = f.properties;  // console.log("creating popup for "+ props.name, f);

                        var popupDom = document.createElement("div");
                        popupDom.style.backgroundColor = "lightgray";
                        // popupDom.style.position = "relative";

                        // 1. ZOOMBTN
                        var openBtn = document.createElement("paper-button");
                        openBtn.style.margin = "3px";
                        openBtn.style.backgroundColor = "white";
                        openBtn.setAttribute("raised", true); 
                        openBtn.appendChild(document.createTextNode("Details"));

                        openBtn.addEventListener('tap', function(e){
                            console.log("Edit details of ", props.name);
                            Popup.remove(); 
                        });

                        // 2. Menu of features
                        var img = document.createElement("img");
                        img.style.margin = "3px";
                        img.style.width = "200px";
                        img.setAttribute("src", props.img);
                        img.addEventListener('tap', function(e){
                            console.log("View datails of ", props.name);
                            Popup.remove(); 
                        });
                        var p = document.createElement("p");
                        p.appendChild(document.createTextNode(props.name.split(".")[0]));
                                   
                        // popupDom.appendChild(openBtn);
                        popupDom.appendChild(img);
                        popupDom.appendChild(p);
                        
                        return popupDom;



                    };

                    var popupContent = createLinkPopupDom(lnkFeature); 

                    Popup = new mapboxgl.Popup()
                        .setLngLat(lnkFeature.geometry.coordinates)
                        .setDOMContent(popupContent)
                        .addTo(map);

                } else {
                    // Trigger actions in outside elements listening for property "clustered"  
                    scope._checkoutDocFromMap(lnkFeature);
                }
                
            });    	

            map.on('mouseenter', srcname, function () {
                map.getCanvas().style.cursor = 'pointer';
            });
            map.on('mouseleave', srcname, function () {
                map.getCanvas().style.cursor = '';
            });

            // C. Return features added at creationtime
            return featureset.features; 

        },    

        // Update the "_sessionDocs-object" ( =  docs(fi. img's) actually "in use") 
        // from collection of "last added docs" 
        _sessionDocsRefresh : function(docCollection) { 
            if (!docCollection || !docCollection.length)  return;  // console.log("_sessionDocsRefresh, NEW", docCollection);

            this.toolstatus = true;
            this.toolstatus = false; // dbl-zuordnung ensures that false is evaluated !! 

            var firstDoc; // of new Load process
            var sessionDocs = this._sessionDocs;   // console.log("_sessionDocsRefresh", docCollection , "OLD:", sessionDocs);

            docCollection.forEach( function(doc){  // console.log("Refresh doc", doc);
                if (!firstDoc) firstDoc = doc;

                // if (!sessionDocs[doc.name]) { 
                    sessionDocs[doc.name] = doc; // Ãœberschreiben !!!
                // }     
            });   

            this._sessionDocs = sessionDocs;  // console.log("Refreshed this._sessionDocs", this._sessionDocs);

            if (firstDoc && (docCollection.length < 2)) { // console.log("activating doc(img) ", firstDoc.name, Object.keys(firstDoc)); 
                // this.linkdocid = firstDoc.name; 
                this._checkoutDoc(firstDoc.name); 
            }    
        },

        // Checkout-1:  from list of non-geocoded docs(images)
        _checkoutDocFromList : function(e) { 
            var item = e.target;   // console.log("item-value", item.value); // , item.value);
            // this.linkdocid = item.value; 
            this._checkoutDoc(item.value); 
        },

        // Checkout-2:  according to name-property of 'tapped' point-feature
        _checkoutDocFromMap : function (feature) {  
            // this.linkdocid = feature.properties.name; // console.log("clicked at locator of  image " + id, feature.properties); 
            this._checkoutDoc(feature.properties.name); 
        },

        /**
            *  Check Notify id of selected doc to be used by other APP-Components 
            */            
        _checkoutDoc : function(checkoutid) { 
            // if (!this._sessionDocs) return;

            // console.log("Last Doc Checkout, id=[" + this.linkdocid + "]"); 
            this.linkdocid = "";  
            this.linkdocid = checkoutid;  
            // console.log("Next Doc Checkout, id=[" + checkoutid + "]"); 
            
        },


    }
</script>    