<link rel="import" href="../polymer/polymer.html">

<script>
  /**
   * `Mbb.LinksBehavior` 
   * Utilities to create and manage pointLinks 
   *
   * @polymerBehavior Mbb.LinksBehavior
   * @demo demo/imagelinks.html
   **/
    window.Mbb = window.Mbb || {};

    Mbb.LinksBehavior = {

        properties: {

            // checkIn/checkOut : selected doc(img)
            docselected : {
                type: Object,
                observer: '_logProperty',
                notify : true
            },
            // checkIn/checkOut : selected doc(img)
            linkdocid : {
                type: String,
                observer: '_queryDoc'
            },
            
            mbbtest: {
                value: 99
            },
            popup:{
                type: Object
            },
            clustered: {
                type: Array,
                value: [],
                notify:true
            },
            featureidname : {
                type: String,
                value: "name"
            },
        },

        observers: [
            'trackDocsUnlinked(_sessionunset.length)'
        ],

        // generic debug-util
        _logProperty: function(prop) {
            // console.log("_logProperty", prop);
        },

        // trigger "idSelect" on sessionDocs
        _queryDoc: function(docid){  
            var docselected = this._sessionDocs[docid]; // console.log("_queryDoc", docid, docselected, this.docselected); // this._sessionDocs);
            if (docselected) this.docselected = docselected; 
        },


        // MB-specific tool to remove duplicates !!
        _mbUniqueFeatures: function(features, idname) {
            if (!idname) idname = "name"; // the property for unique id 
            var uniqs = [], ids = [], id = "";

            features.forEach(function(f) {
                id = f.properties[idname];
                if (!id || (ids.indexOf(id) < 0)) {
                    ids.push(id);
                    uniqs.push(f);
                }   
            });
            return uniqs; 
        },

        _mbGetBounds : function(features, asfeature) {    

            var bounds = map.getBounds(); 

            if (features) {
                
                if (features.features) features = features.features; // if a feature-set was passed

                var coord0 = features[0].geometry.coordinates;
                bounds = features.reduce(function(bounds, feature) {
                    var coord = feature.geometry.coordinates;
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coord0, coord0));
            } console.log(bounds, asfeature); 

            if (!asfeature) return bounds;
            
            var e = bounds.getEast(), s = bounds.getSouth(), w = bounds.getWest(), n = bounds.getNorth(),
                p = [[[w,s], [w,n], [e,n], [e,s], [w,s]]]; console.log(e,s,w,n,p);  
            
            var bb = {
                "type": "Feature",
                "properties": {},
                "geometry": {
                    "type": "Polygon",
                    "coordinates": p
                }
            };
            return bb; 
        },     

        // Simple fitbounds for point-features
        _mbFitBounds : function(bounds, padding) {
            if (padding== null) padding = 20; // pixels ?
            // var bounds = this._mbGetBounds(features);
            map.fitBounds(bounds, {
                padding: 30
            }); 
        },     

        // Test the layer status
        _linkLayerStatus : function(layid) {
            if (!layid) layid = this.layerid;
            var status = {
                id : layid,
                src :  map.getSource(layid),
                layer : map.getLayer(layid)
            };  // console.log("_linkLayerStatus", status);  
            return status;  
        },

        // generic click-listener
        _mapClickListener : function(e) {
            var f = wpscope._mapeventListener(e); 
            if (!f) return; // console.log("clicked",f);

            wpscope._checkoutDocFromMap(f);
        }, 

        // generic hover-listener
        _mapHoverListener : function(e) {
            var f = wpscope._mapeventListener(e); 
            if (!f) return; 
            wpscope.hoverAction(features[0]);
        }, 

        // GENERIC select-event-translator
        _mapeventListener : function(e) {
            var st = wpscope._linkLayerStatus(); 
            if (!st.layer) return ;  

            var features = map.queryRenderedFeatures(e.point, {
                layers: [st.id]
            });
            if (!features || !features.length) return;   
            return features[0];
        },    

        // Refresh the "src"(content) of "explored" data-layers 
        // creates layers if not yet existing 
        _refreshLinks: function(rawdata) {
            
            if (!rawdata || !rawdata.type) {
                console.log("BREAK. 1  no location data attached!");
                return;  
            } 

            // 1. ReCheck structure as featureset
            var featuresetRefresh = rawdata; 
            
            if (!featuresetRefresh.features) {
                featuresetRefresh = {
                    "type": "FeatureCollection",
                    "features": [featuresetRefresh]
                }
            }    
            if (!featuresetRefresh.features.length) {
                console.log("BREAK. 2  no location data attached to ", rawdata);
                return;  
            } 

            var zoomFunction = this._mbFitBounds,
                bbFunction = this._mbGetBounds; 

            // Update viewPort to include last loaded locations  
            function zoomAddedFeatures(addedFeatures, oldFeatures) {
                // different actions methods 
                var ff = addedFeatures,
                    bb = bbFunction(ff); 
                var bbold = bbFunction(oldFeatures);

                // Add a buffer feature around single-point !!
                if (ff.length < 2) { 
                    var spoint = ff[0]; 
                    var bbnow  = bbFunction(null, true); console.log(spoint, bbnow);
                    if (turf.inside(spoint, bbnow)) { console.log("pnt is inside actual viewport!")
                        return; 
                    }    
                    // HILITING the last linkPoint in suitable Umkreis with "radius" km 
                    var radius = this.radius ? this.radius : 5; 
                    var units = 'kilometers';
                    var radius = radius;
                    var steps = 10;
                    var pp = turf.explode(turf.circle(spoint, radius, steps, units));
                    ff = ff.concat(pp.features);   
                }

                zoomFunction(bb);
            }  

            // 2. Check/Create/Update "LinkLayer"-Data

            var st = this._linkLayerStatus();  // console.log("_refresh Layer " + st.id, st, rawdata, featuresetRefresh); 
            var addedFeatures = [];

            if (!st.layer) {   console.log("FIRST link-layer-setup from", rawdata);

                addedFeatures = this._createLayers(st.id, featuresetRefresh);
                
                setTimeout( function() {
                    zoomAddedFeatures(addedFeatures);
                }, 500);  
            
            }  else {          // Update dataSource

                var oldFeatures = this._sessionSet.features,
                    tryFeatures = featuresetRefresh.features; // console.log("old", oldFeatures) ; console.log("try", tryFeatures) ;

                // Filtering only features with a new name  
                var addedFeatures = tryFeatures.filter(function(item){
                    var isOld = false;
                    oldFeatures.some(function(old){
                        if (old.properties.name === item.properties.name) {
                            isOld = true;
                            return;
                        } 
                    })
                    return !isOld;
                }); // console.log("really new features", addedFeatures); 
                if (!addedFeatures.length) return;   

                this._sessionSet.features = this._sessionSet.features.concat(addedFeatures); 

                // console.log("new, all features", featuresetRefresh, this._sessionSet) ; 
                map.getSource(st.id).setData(this._sessionSet);

                zoomAddedFeatures(addedFeatures, oldFeatures); 

            }

            // 3.  
            if (this._checkoutDocFromMap) {
                    map.off('click', this._mapClickListener);
                    map.on('click', this._mapClickListener);
            } 

            if (this.hoverAction) {
                    map.off('hover', this.hoverListener);
                    map.on('hover', this.hoverListener);
            }

            return {features: addedFeatures} ;
        },

        // 
        _refreshMap: function(featuresetLocated) {
            if (!featuresetLocated) return; 
            // console.log("_refreshMap LinkPoints of ImageSet Located", featuresetLocated); // .locations, imagesetLocated.geojson); 

            map.showTileBoundaries = true; // for DEBUG 

            var imageset = this.imageset;  // console.log("_refreshMap ImageSet Raw",  imageset); 

            // var featureSet = featuresetLocated; // .geojson; 

            featuresetLocated.features.forEach(function(f){
                if (!f.properties.img) {
                    var name = f.properties.name, img="" ; 
                    // Integrate the img into properties
                    imageset.some(function(obj){
                        if (obj.name == name) {
                            img = obj.value;
                            return;
                        }     
                    });
                    f.properties.img = img;
                }
            }); // console.log("_refreshMap FeatureSet", featureSet); 
            
            this._refreshLinks(featuresetLocated);
        },

        // Create an suitably "clustering" layer
        _createLayers : function(srcname, featureset, idname) {    
            if (!idname) idname = "name"; 
            this._sessionSet = featureset;
            
            // 
            var clusterMode = true,
                popupMode = true;

            var vis = "none";
            if (this.visible) vis = "visible";

            // A. SOURCE 
            // B. Create LAYER(s) of SOURCE

            if (!clusterMode) {  // B.1  Simple PointLayer
                // A. 
                map.addSource(srcname, {
                    "type": "geojson",
                    "data": featureset
                });
                // B. 
                map.addLayer({
                    "id": srcname,
                    "type": "circle",
                    "source": srcname,
                    "layout" : {
                        "visibility": vis
                    },
                    "paint": {
                        "circle-radius": 8,
                        "circle-color": "#FFFFFF",
                        "circle-stroke-width": 2,
                        "circle-stroke-color": "#B42222"
                    },
                    "filter": ["==", "$type", "Point"],
                }); // console.log("added img-link-layer", map.getLayer(srcname) ); 

            } else {                  // B.2 LayerGROUP with clusters (to best visualize the content of SOURCE) 
        
                var clusterRadius = 50,
                    clusterMaxZoom = 14;
                // A. 
                map.addSource(srcname, {
                    "type": "geojson",
                    "data": featureset,
                    "cluster": clusterMode,
                    "clusterMaxZoom": clusterMaxZoom, // Max zoom to cluster points on
                    "clusterRadius": clusterRadius    // Radius of each cluster when clustering points (defaults to 50)
                });

                // B. 
                var elem = this;

                // Cluster-Symbol (BG) 
                map.addLayer({
                    id: "clusters",
                    type: "circle",
                    source: srcname,
                    filter: ["has", "point_count"],
                    paint: {
                        "circle-color": {
                            property: "point_count",
                            type: "interval",
                            stops: [
                                [0, "#51bbd6"],
                                [5, "#f1f075"],
                                [20, "#f28cb1"],
                            ]
                        },
                        "circle-radius": {
                            property: "point_count",
                            type: "interval",
                            stops: [
                                [0, 20],
                                [5, 30],
                                [20, 40]
                            ]
                        }
                    }
                });

                // Cluster-Label (FG)
                map.addLayer({
                    id: "cluster-count",
                    type: "symbol",
                    source: srcname,
                    filter: ["has", "point_count"],
                    layout: {
                        "text-field": "{point_count_abbreviated}",
                        "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
                        "text-size": 12
                    }
                });

                // NON-clustered points
                map.addLayer({
                    id: srcname,
                    type: "circle",
                    source: srcname,
                    filter: ["!has", "point_count"],
                    paint: {
                        "circle-color": "#11b4da",
                        "circle-radius": 8,
                        "circle-stroke-width": 1,
                        "circle-stroke-color": "#fff"
                    }
                });

                // EVENTS to Refresh customMarkers of "PURE" points
                map.on('zoomend', function(){
                    elem._checkMarkers(srcname, idname);
                });

                map.on('moveend', function(){
                    elem._checkMarkers(srcname, idname);
                });


                // EVENTS to query features "below" a cluster-point
                var scope = this;

                // Create generic itemdata {value:value, text:text}
                // for gui-elements 
                function featureList(points) { 
                    var itemdata = [], id, text;
                    points.forEach(function(pnt){
                        id   = pnt.properties.name;
                        text = id.split(".")[0]; // removes extensions (fi .jpg)
                        itemdata.push({text:text, value:id});
                    }); 

                    // Sort itemdata alphabetically by 'text' 
                    itemdata.sort(function(a, b) {
                        // return parseFloat(a.text) - parseFloat(b.text);
                        return a.text.localeCompare(b.text);
                    }); //console.log("itemdata of linkpoints",itemdata);
                    
                    return itemdata
                };    

                var zoomFunction = this._mbFitBounds,
                    bbFunction = this._mbGetBounds;
                
                // 
                function createClusterPopupDom(features){
                    console.log(this); 
                    var itemList = featureList(features); 
                    var popupDom = document.createElement("div");
                    popupDom.style.backgroundColor = "lightgray";
                    // popupDom.style.position = "relative";

                    // 1. ZOOMBTN
                    var zoomBtn = document.createElement("paper-button");
                    zoomBtn.style.margin = "3px";
                    zoomBtn.style.backgroundColor = "white";
                    zoomBtn.setAttribute("raised", true); 
                    zoomBtn.appendChild(document.createTextNode("ZoomToCluster"));

                    zoomBtn.addEventListener('tap', function(e){
                        // APP-Action: 
                        console.log("zooming to", features);
                        var bb = bbFunction(features)
                        zoomFunction(bb);
                        // GUI-Action: Close the mapboxgl-popup 
                        // var popupEl = e.target.closest("div.mapboxgl-popup"); // console.log("popupParent", popupEl); 
                        // var popupEl = popupDom.closest("div.mapboxgl-popup"); 
                        var popupEl = popupDom.parentElement.parentElement;
                        // if (popupEl) popupEl.remove();
                    });

                    // 2. Menu of features
                    var menu = document.createElement("paper-menu");
                    itemList.forEach(function(itemData){
                        item = document.createElement("paper-item");
                        item.style.cursor = "pointer";

                        item.setAttribute("value", itemData.value);
                        item.classList.add("cluster");
                        item.appendChild(document.createTextNode(itemData.text));

                        item.addEventListener('tap', function(e){
                            // APP-Action: Setting APP-property "linkdocid"
                            scope.linkdocid = e.target.getAttribute("value");  
                            // GUI-Action: Close the mapboxgl-popup 
                            // var popupEl = e.target.closest("div.mapboxgl-popup"); // console.log("popupParent", popupEl); 
                            // var popupEl = popupDom.closest("div.mapboxgl-popup"); // console.log("popupParent", popupEl); 
                            var popupEl = popupDom.parentElement.parentElement;
                            // if (popupEl) popupEl.remove();
                        });
                    
                        menu.appendChild(item);
                    });

                    popupDom.appendChild(zoomBtn);
                    popupDom.appendChild(menu);
                    
                    return popupDom;
                }

                map.on('click', 'clusters', function (e) {

                    // var clusters = map.queryRenderedFeatures(e.point, {
                    //     layers: ['clusters']
                    // });
                    var clusterPnt = e.features[0]; 

                    var linkPnts = scope._sessionSet.features;  //console.log("clusters, All links", clusters, links);
                    
                    // FILTER points "under" Cluster : SPECIALFILTER (from stackOverflow)
                    var pointsInCluster = linkPnts.filter(function(f){
                        var pointPixels = map.project(f.geometry.coordinates);
                        var pixelDistance = Math.sqrt(
                            Math.pow(e.point.x - pointPixels.x, 2) + 
                            Math.pow(e.point.y - pointPixels.y, 2) 
                        );
                        return Math.abs(pixelDistance) <= clusterRadius;
                    }); console.log("clustered linkPoints", pointsInCluster);

                    // Alternives for itemdata-usage
                    if (popupMode) {
                        // 
                        var popupContent = createClusterPopupDom(pointsInCluster); 

                        new mapboxgl.Popup()
                            .setLngLat(clusterPnt.geometry.coordinates)
                            .setDOMContent(popupContent)
                            .addTo(map);
                    } else {
                        scope.clustered = featureList(pointsInCluster);
                    }

                });

            }

            // C. Return features added at creationtime
            return featureset.features; 

        },    

        // Update the "_sessionDocs-object" ( =  docs(fi. img's) actually "in use") 
        // from collection of "last added docs" 
        _sessionDocsRefresh : function(docCollection) { 
            if (!docCollection || !docCollection.length)  return;  // console.log("_sessionDocsRefresh, NEW", docCollection);

            this.toolstatus = true;
            this.toolstatus = false; // dbl-zuordnung ensures that false is evaluated !! 

            var firstDoc; // of new Load process
            var sessionDocs = this._sessionDocs;   // console.log("_sessionDocsRefresh", docCollection , "OLD:", sessionDocs);

            docCollection.forEach( function(doc){  // console.log("Refresh doc", doc);
                if (!firstDoc) firstDoc = doc;

                // if (!sessionDocs[doc.name]) { 
                    sessionDocs[doc.name] = doc; // Überschreiben !!!
                // }     
            });   

            this._sessionDocs = sessionDocs;  // console.log("Refreshed this._sessionDocs", this._sessionDocs);

            if (firstDoc && (docCollection.length < 2)) { // console.log("activating doc(img) ", firstDoc.name, Object.keys(firstDoc)); 
                // this.linkdocid = firstDoc.name; 
                this._checkoutDoc(firstDoc.name); 
            }    
        },

        // Checkout-1:  from list of non-geocoded docs(images)
        _checkoutDocFromList : function(e) { 
            var item = e.target;   // console.log("item-value", item.value); // , item.value);
            // this.linkdocid = item.value; 
            this._checkoutDoc(item.value); 
        },

        // Checkout-2:  according to name-property of 'tapped' point-feature
        _checkoutDocFromMap : function (feature) {  
            // this.linkdocid = feature.properties.name; // console.log("clicked at locator of  image " + id, feature.properties); 
            this._checkoutDoc(feature.properties.name); 
        },

        /**
            *  Check Notify id of selected doc to be used by other APP-Components 
            */            
        _checkoutDoc : function(checkoutid) { 
            // if (!this._sessionDocs) return;

            console.log("Last Doc Checkout, id=[" + this.linkdocid + "]"); 
            this.linkdocid = "";  
            this.linkdocid = checkoutid;  
            console.log("Next Doc Checkout, id=[" + checkoutid + "]"); 
            
        },


    }
</script>    