<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="mb-api.html">
<link rel="import" href="mb-routes-behavior.html">

<!--
`mb-vendee`
creates and follow animated routes 
along waypoints of file loaded from url

@demo demo/vendeemap.html 
-->
<dom-module id="mb-vendee">

    <template>
    
        <iron-ajax
            auto
            url="[[url]]"
            handle-as="json"
            on-response="dataToApp">
        </iron-ajax>
    
    </template>

    <script>
        // Global referencing this element in animation and geschachtelten functions
        var mba;

        /**
         * A waypoint along a tracked route
         */
        class Waypoint {
            /**
             * Constructs the object.
             *
             * @param      {array}   coordinates  The wp's coordinates as [lng,lat]-array
             * @param      {string}  id           The wp's identifier
             * @param      {string}  icon         The mapbox-icon name 
             */
            constructor(coordinates, id, routeid, icon) {
                if (!id) id = "wp";
                if (!icon) icon = "star";
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }
                this.id = id;
                this.properties = {
                    'routeid': routeid,
                    "title": id,
                    "icon": icon
                }
            };
        };

        Polymer({
            is: 'mb-vendee',
            properties: {
                /**
                 * Mapbox-js map to place routes on 
                 */
                map: {
                    type: Object
                },
                /**
                 * Basic Info-popup 
                 */
                popup: {
                    type: Object
                },
                /**
                 * Basic Info-popup 
                 */
                popupmode: {
                    type: Number
                },

                /**
                 * Url to source of trackable routes/waypoints
                 */
                url: {
                    type: String
                },

                /**
                 * AnimationCtrlFlag
                 */
                trackctrl: {
                    type: Boolean,
                    notify: true
                },

                /**
                 * Toggles TrackingMap/NorthMap 
                 */
                trackmode: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                /**
                 * FramePerSecond of animation
                 */
                fps: {
                    type: Number,
                    value: 60
                },
                /**
                 * { item_description }
                 */
                timescale: {
                    type: Number,
                    value: 1080
                },


                trackid: {
                    type: String,
                    value: ""
                },

                trackobj: {
                    type: Object,
                    observer: 'checkTrackobj'
                },

                // for use in popups !!
                trackinfo: {
                    type: String,
                },

                // for external use  
                trackdata: {
                    type: Object,
                    value: {},
                    notify: true,
                    //observer: 'checkTrackdata'
                },

                // INTERNAL variables

                /**
                 * Animation counter
                 */
                counter: {
                    type: Number
                },

                //
                requestframeref: {
                    type: String,
                    value: '1'
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },

                // 
                routelayers: {
                    type: Object
                },

            },

            behaviors: [
                Polymer.RoutesBehavior
            ],

            observers: [
                'setupTracking(routedata, timescale)' // ,
                /*    'dataToMap(map, routelayers.*, routedata)',
                    'ctrlTrackmove(trackctrl)',
                    'ctrlTrackmode(trackmode, trackid, map)'*/
            ],

            attached: function() {
                /**
                 * quasiglobal context for animation 
                 */
                mba = this;
                // this.trackFeaturesInit();
            },

            /**
             * Setup of animation framework from new track(wp)-dataset
             *
             * @param      {<type>}  routedata  Routedata as wp-dataset
             */
            dataToApp: function(ajaxresponse) {
                var routedata = ajaxresponse.detail.response;
                if (!routedata) return;
                this.routedata = routedata; // triggers 'setupTracking'
            },

            setupTracking: function(routedata, timescale) {
                // console.log("ORIGINAL routedata:", routedata, " with timescale=" + timescale);

                this.counter = 0;
                this.trackTimer = this.setupTrackTimer(routedata, this.timescale);
                return;

                var routelayers = {};
                routelayers['waypoints'] = this.setupTrackWaypoints(routedata);
                //routelayers['routes'] = this.setupTrackRoutes(routedata, this.trackTimer);
                //routelayers['tracks'] = this.setupTrackObjects(routedata, this.trackTimer);
                // console.log("RouteAppData Ready", this.routelayers, this.routedata);

                // Double assignment to trigger multi-parameter observer 
                this.routelayers = {};
                this.routelayers = routelayers; // triggers "dataToMap""
            },

            /**
             * Compile the some timeflags of animated tracks
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timeScale  The timeScale of animation
             * @return     {Object}  Descriptor of timeCtrls
             */
            setupTrackTimer: function(routedata, timeScale) {
                if (!timeScale) timeScale = this.timescale;
                if (!timeScale) timeScale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                var fpsmax = 60; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                this.frameTime = timeScale / fpsmax; // Bsp: frameTime: 6 s fuer scale = 360 und fps=60 !!
                // console.log("timeScale=" + timeScale, ", frameTime=" + this.frameTime + "sec");

                var routes = {},
                    route = [],
                    id, lat, lng, t;
                routedata.forEach(function(wp, j) {
                    id = wp.ID;
                    route = routes[id];
                    if (!route) {
                        route = [];
                        routes[id] = route;
                    }

                    var wpx = {};
                    wpx.t = mba.utcTime(wp.Date + "." + wp.Time);
                    wpx.lat = mba.dmtodd(wp.Lat);
                    wpx.lng = mba.dmtodd(wp.Lng);
                    route.push(wpx);
                });

                routedata = [];
                Object.keys(routes).forEach(function(id){
                    var rec = {"id":id, "waypoints":routes[id]};
                    routedata.push(rec);
                });
                console.log("routes", routes, routedata);

                var start, trackTimer = {};

                routedata.forEach(function(route, j) {
                    var starts = [],
                        stops = [],
                        passes = [];
                    route.waypoints.forEach(function(wp, p) {
                        if (wp.ab) starts.push(wp);
                        if (wp.an) stops.push(wp);
                        if (wp.t) passes.push(wp);
                    }.bind(this));
                    trackTimer[route.id] = [starts, stops, passes];
                }.bind(this));
                console.log("trackTimerRaw", trackTimer);
                return; 

                Object.keys(trackTimer).forEach(function(id) {
                    var starts = trackTimer[id][0],
                        stops = trackTimer[id][1],
                        wpstart = starts[0],
                        wpstop = stops[stops.length - 1],
                        routestart = this.utcTime(wpstart.ab, wpstart.coords, "h"),
                        routestop = this.utcTime(wpstop.an, wpstop.coords, "h");
                    trackTimer[id] = {
                        "start": routestart,
                        "stop": routestop
                    };
                    if (!start || (routestart < start)) start = routestart;
                }.bind(this));

                // 
                var routeStarts = {},
                    startTimes = [];
                for (let id in trackTimer) {
                    let t = trackTimer[id]["start"];
                    if (!startTimes.length || (startTimes[0] <= t)) startTimes.push(t);
                    else startTimes.splice(0, 0, t);
                }

                trackTimer["start"] = start;
                trackTimer["startList"] = startTimes;
                trackTimer["timeScale"] = timeScale;
                trackTimer["frameTime"] = this.frameTime;

                console.log("APPLIED trackTimer:", trackTimer);

                return trackTimer;
            },

            setupTrackWaypoints: function(routedata) {

                this.waypoints.features = [];
                var allwaypoints = this.waypoints;

                routedata.forEach(function(route, j) {
                    // locate plane at 'origin'
                    // console.log("route-" + j, route.waypoints);

                    route.waypoints.forEach(function(wp, p) {
                        allwaypoints.features.push(new Waypoint(wp.coords, wp.id, route.id));
                    });
                });
                // console.log("all waypoints collected", allwaypoints.features);

                // 
                var wpLayer = {};

                wpLayer['data'] = allwaypoints;

                wpLayer['layer'] = {
                    "id": "waypoints",
                    "type": "symbol",
                    "source": "waypoints",
                    "layout": {
                        "icon-image": "{icon}-15",
                        //"icon-image": "harbor-15",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-offset": [0, -0.6]
                    }
                };
                return wpLayer;
            },


            /**
             *  transform digitaldegree to d-m with 3 digits (last digit ca 1-2m)
             *  "maritime formatting"  
             */
            dmtodd: function(dm, lonflag, prec) {
                if (!prec) prec = 6;
                dm = dm.split("°");  // console.log("dm-array", dm);
                dd = parseInt(dm[0])+parseFloat(dm[1])/60;
                if (dm[1].slice(-1)=="W") dd = 0-dd;
                if (dm[1].slice(-1)=="S") dd = 0-dd;
                return dd ; 
            }


        })
    </script>

</dom-module>#