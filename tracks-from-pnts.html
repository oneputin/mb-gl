<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="routing-classes.html">
<link rel="import" href="mb-tools-behavior.html">

<!--<link rel="import" href="routing-behavior.html">-->

<!--
`tracks-from-pnts`
Interface for import/export of tracking data from handheld gps-devices

Optional: create quick-preview-data 

@demo demo/routinghandheld.html 
-->

<dom-module id="tracks-from-pnts">

<template>

    <style is="custom-style">
        :host {
            position: absolute;
            display: none; /*inline-block;*/
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <iron-ajax
        auto
        url="[[dataurl]]"
        handle-as="json"
        on-response="getRawData">
    </iron-ajax>

    <iron-ajax
        auto
        url="[[masterurl]]"
        handle-as="json"
        on-response="getRawData">
    </iron-ajax>

</template>

<script>
    Polymer({
        is: 'tracks-from-pnts',

        properties: {

            srcmeta: {
                type: Object,
            },

            dataurl : {
                type: String
            },

            masterurl : {
                type: String
            },

            // Required (also if empty)
            masterdata: {
                type: Object                
            },

            rawdata: {
                type: Object,
                value: {}
            },

            usepreview: {
                type: Boolean,
                value: false
            },

            // can be processed in "quickViewer"
            trackdata: {
                type: Object,
                notify: true
            },

            // can be processed in "quickViewer"
            quickmap: {
                type: Object,
                notify: true
            },

            // tobe processed in "trackAnimation"
            routedata: {
                type: Array,
                value: [],
                notify: true
            }

        },

        behaviors: [
            Polymer.ToolsBehavior,
        ],

        observers: [
            'triggerQuery(srcmeta.*)',
            'deriveTracks(rawdata, srcmeta, usepreview, masterdata)'
        ],

        attached: function() {
            // console.log("target attached");
        },

        // 
        triggerQuery: function(srcmeta) { // trigger new dataquery !!
            if (srcmeta.path == 'srcmeta') srcmeta = srcmeta.value;
            if (srcmeta.type.indexOf("table") < 0) {
                this.rawdata = null; // 
                return;
            }  
            // set parameters for data-fetch with <iron-ajax>
            this.dataurl = srcmeta.url;
            if (srcmeta.masterurl) this.masterurl = srcmeta.masterurl;
            else this.masterdata = {};
        },

        // Get rawdata from ajax-responses into element 
        getRawData: function(ajaxresponse) {
            if (!ajaxresponse || !ajaxresponse.detail) return;
            // console.log("getRawData, response", ajaxresponse); // .detail.response);
            var srcurl = ajaxresponse.detail.url;
            if (srcurl == this.dataurl) this.rawdata = ajaxresponse.detail.response;
            if (srcurl == this.masterurl) this.masterdata = ajaxresponse.detail.response;
        },
        
        // 
        deriveTracks: function(rawdata, srcmeta, usepreview) {
            if (!rawdata || !Object.keys(rawdata).length) return; 
            // console.log("table-data, raw:", rawdata);

            // 1. "DETECT"  the  "table-mode"" 
            var tablemode = (rawdata[0]["geometry"]) ? "json" : "nn";

            tablemode = (rawdata[0]["Header"] == "Trackpoint") ? 'table-vomue1' : tablemode;
            
            tablemode = rawdata[0]["Pnt"] ? 'table-vomue2' : tablemode;
            
            if (tablemode == "nn") {
                console.log("BREAK. Selected dataset cannot be analysed!!");
                return;
            }   // console.log("table-data, mode:", tablemode);   

            // 2. Extract raw tracks 
            //    by "very simple" segementation-algorithm 
            //    For animation abandon "short" segments 
            var mintracklength;
            if (!usepreview) mintracklength = srcmeta.mintracklength;
            
            var rawtracks = this.getRawTracks(rawdata, tablemode, mintracklength);

            // 3. Create Derivates of rawTracks 

            if (usepreview) {   // derive features for mb-visualization of rawTracks

                this.quickmap = this.createQuickview(rawtracks, srcmeta);
                
                console.log("Quickview TRACKS (from TPs):", this.quickmap);  
                
            } else {    // derive structures for mb-based animation of 'suitable' tracks

                var routedata = this.createTrackRoutes(rawtracks); // , rawdbdata);
                
                if (routedata) {
                    console.log("RAW ROUTEDATA (from TPs) :", routedata);  
                    this.routedata = routedata;
                } 
            }
        },

        // Convert tabular data into point-collections
        // to be used as tracks 
        getRawTracks: function(rawdata, tablemode, minTrackLength) {
            // console.log("getRawTracks: rawdata=", rawdata);

            // Dis-assemble rawdata-recordings that contain "separable tracks"  
            // with mode-specific algorithms - assigning a unique track-ID
            function handheldCoords(cc, targetformat, prec) {
                if (!targetformat) targetformat = "dd";
                if (!prec) prec = 6;
                // Split into 4 parts : 
                // latDeg, latMin, lngDeg, lngMin
                var coords = cc.split(" ");

                lat = coords[0];
                lat = lat[0] == "N" ? "+" + lat.slice(1) : "-" + lat.slice(1);

                lng = coords[2];
                lng = lng[0] == "E" ? "+" + lng.slice(1) : "-" + lng.slice(1);

                if (targetformat == "dd") {
                    lat = parseInt(lat) + (parseFloat(coords[1]) / 60);
                    lng = parseInt(lng) + (parseFloat(coords[3]) / 60);

                } else if (targetformat == "dm") {
                    lat = (parseInt(lat) * 60) + parseFloat(coords[1]);
                    lng = (parseInt(lng) * 60) + parseFloat(coords[3]);
                }
                coords = [lng, lat]; // console.log("dd-array", dd);
                return coords;
            };

            // 
            function handheldTime(traw, asdate) {
                // !! for (later) use of date-parser 
                // the MONTH must be numbered 0 .. 11 !!
                var t, a, aa, tstandard, tdate;
                if (typeof traw == "string") {

                    t = traw.split(":").join(".");
                    t = t.split(" ").join(".");
                    a = t.split(".");

                    aa = [a[2], a[1], a[0], a[3], a[4], a[5]]; // datum umordnen

                    tstandard = aa.join(".");

                    tdate = new Date(parseInt(aa[0]), parseInt(aa[1]) - 1, parseInt(aa[2]), parseInt(aa[3]), parseInt(aa[4]), parseInt(aa[5]));

                } else {
                    tdate = traw;
                    tstandard = traw
                } // console.log("handheldTime", traw, t, a, tunix)

                if (asdate) return tdate;
                return tstandard;
            };

            // tool STABW 
            function stabw(array) {
                var len = 0;
                var sum = array.reduce(function(pv, cv) {
                    ++len;
                    return pv + cv;
                }, 0);
                var mean = sum / len;
                var result = 0;
                for (var i = 0; i < len; i++)
                    result += Math.pow(array[i] - mean, 2);
                len = (len == 1) ? len : len - 1;
                return Math.sqrt(result / len);
            };

            var routes = {},
                routedata = [],
                tp, trackpoints;
            var t, dt, dx, dt_std, dx_std, v, dv_std,
                vprev = 0;

            if (tablemode.indexOf("vomue1") >= 0) 
                tablemode = "vomue1";
            else if (tablemode.indexOf("vomue2") >= 0) 
                tablemode = "vomue2";
            else {
                console.log("BREAK. tablemode not usable: ", tablemode);
                return;
            }

            // Step1: Analyse STDDEV of DT, DX-data (if available)   

            var dts = [],
                dxs = [],
                dvs = [];

            rawdata.forEach(function(tp, j) {

                if (tablemode == "vomue1") {
                    dt = tp["Leg Time"].split(":");
                    dx = tp["Leg Length"].split(" ");
                    v = tp["Leg Speed"].split(" ");
                }
                if (tablemode == "vomue2") {
                    dt = tp["dt"].split(":");
                    dx = tp["dx"].split(" ");
                    v = tp["v"].split(" ");
                }
                // console.log(dt,dx,v);
                // unit 
                dt = 3600 * parseInt(dt[0]) + 60 * parseInt(dt[1]) + parseInt(dt[2]); // always [s]
                dx = (dx[1] == "km") ? parseInt(dx[0]) * 1000 : parseInt(dx); // always in [m] 
                dv = parseFloat(v[0]) - vprev; // dv = is always km/h
                vprev = parseFloat(v[0]);
                // console.log("dv=" + dv, v);
                dts.push(dt);
                dxs.push(dx);
                dvs.push(dv);
            });

            if (dts.length) {
                dt_std = Math.round(stabw(dts));
                dx_std = Math.round(stabw(dxs));
                dv_std = Math.round(stabw(dvs));
                //console.log("dt-std [sec]:", dt_std);
                //console.log("dx-std [m]:", dx_std);
                //console.log("dv-std [km/h]:", dv_std);
            }

            // Step2 : Abschnittsweise zuordnen untersch. ids  

            var trackid = 1;
            rawdata.forEach(function(tp, j) {

                if (tablemode == "vomue1") {
                    dt = tp["Leg Time"].split(":");
                    dx = tp["Leg Length"].split(" ");
                    v = tp["Leg Speed"].split(" ");
                }

                if (tablemode == "vomue2") {
                    dt = tp["dt"].split(":");
                    dx = tp["dx"].split(" ");
                    v = tp["v"].split(" ");
                }

                // TEST-parameter 
                dt = 3600 * parseInt(dt[0]) + 60 * parseInt(dt[1]) + parseInt(dt[2]);                
                dx = (dx[1] == "km") ? dx[0] * 1000 : dx;

                // Neues segment (id), 
                // wenn TEST-parameter "zu groß" sind h
                if ((dt > dt_std) || (dx > dx_std)) 
                    trackid = trackid + 1;

                // Zuordnen der ID    
                tp.id = trackid;

            });

            // B. G R O U P  all TP-records 
            //    into track-objects by TP-id 

            rawdata.forEach(function(tp, j) {
                var tpx = {};

                Object.keys(tp).forEach(function(k) {

                    if (tablemode == "vomue1") {
                        if (k == "Position") {

                            coords = handheldCoords(tp[k]);
                            tpx["coords"] = coords;

                        } else if (k == "Time") {

                            time = handheldTime(tp[k]);
                            tpx["ab"] = time;
                            tpx["an"] = time; // 

                        } else {
                            tpx[k] = tp[k];
                        }
                    }

                    if (tablemode == "vomue2") {
                        if (k == "coords") {
                            coords = handheldCoords(tp[k]);
                            tpx["coords"] = coords;
                        } else if (k == "Date") {
                            time = handheldTime(tp[k]);
                            tpx["ab"] = time;
                            tpx["an"] = time; // 
                        } else {
                            tpx[k] = tp[k];
                        }
                    }

                })

                if (!tpx.coords) {
                    console.log("TP-record without coords", tp);
                } else {
                    // Distribute the trackpoints into "separable" tracks
                    // (if wpts are pre-grouped by track-id)  
                    if (tp.id) {
                        id = tp.id;
                        route = routes[id];
                        if (!route) {
                            route = [];
                            routes[id] = route;
                        }
                    } else {
                        route = routes["raw"];
                        if (!route) {
                            route = [];
                            routes["raw"] = route;
                        }
                    }
                    // console.log(tpx);
                    route.push(tpx);
                }
            }.bind(this));

            // C. "Sortieren innerhalb der Gruppen"
            //    und Zuordnen der "ab"-zeit des ersten TP als Key

            var alltracks = {}, trackpoints, trackid;

            Object.keys(routes).forEach(function(id) {
                
                trackpoints = routes[id];

                trackpoints.sort(function(wp1, wp2) {
                    return this.utcTime(wp1.ab) - this.utcTime(wp2.ab);
                }.bind(this));
                
                // console.log(id, trackpoints[0]);
                trackid = trackpoints[0].ab; 

                alltracks[trackid] = trackpoints;
                
            }.bind(this));    
            // console.log("raw route-tracks", tracks);

            // D. Option: Filtern "zu kurzer" tracks 
            //            (length < minTrackLength)

            var tracks = {} ;
            if (minTrackLength) {
                Object.keys(alltracks).forEach(function(trackid) {
                    if (alltracks[trackid].length >= minTrackLength)
                        tracks[trackid] = alltracks[trackid];
                });
            } else {
                tracks = alltracks;
            }

            return tracks; 
        },

        // Derive input-data-structures for my-animatation-api
        createTrackRoutes: function(routes, masterdata) {

            // C. Join temporary masters- and routes-objects 
            //    into array of api-conform routedata (wps sorted by time) 
            var routedata = [],
                trackpoints;

            Object.keys(routes).forEach(function(id) {

                trackpoints = routes[id];

                var title = trackpoints[0].ab;

                var route = {
                    "id": id,
                    "title": title,
                    // "icon": icon,
                    "unitsystem": "metric",
                    "nodes": trackpoints
                };

                // Optionally: include Stammdaten
                if (masterdata && masterdata[id] && this.connect) {
                    route["master"] = masterdata[id];
                }

                // *** Required ***  
                route.trackmode = true;

                routedata.push(route);

            }.bind(this));

            return routedata;
        },

        // Deribe quickmb-container of raw tracks
        createQuickview: function(trackdata, srcmeta, masterdata) {

            var scope = this;
            var prefix = ""; // tracks";
            var title = srcmeta.key;
            if (!title) title = srcmeta.title;
                        
            // 
            function srcDataCreate(trackdata) {
                var features = [],
                    starttime ;

                Object.keys(trackdata).forEach(function(id){
               
                    if (!starttime) starttime = id; 
                    var coords = [],
                        coordTimes = [],
                        nodes = trackdata[id];

                    nodes.forEach(function(node){
                        coords.push(node.coords);
                        if (node.ab) coordTimes.push(node.ab);
                        else coordTimes.push(node.an);
                    })

                    var properties = {
                            id: id,
                            color: scope.getRandomColor(),
                            time: id, // nodes[0].ab
                            coordTimes: coordTimes
                        };

                    var trace = new TraceSource(coords, id, properties);
                    
                    properties.length = scope.deltaL(trace); // console.log(trace);

                    features.push(trace);
                })
                
                var srcData = {
                    features: features,
                    time: starttime,
                    type: "FeatureCollection"
                } ;

                return srcData;
            } 

            // 
            function jsonTrackToQuickview(srcdata, title, prefix) {
                // if (!prefix) prefix = "tracks"
                if (!title) title = srcdata.time;

                var mapid = title;
                if (prefix) mapid = prefix + "-" + mapid;
                
                var quickmap = {};                
                quickmap[mapid] = {
                    "layer": {
                        "type": "line",
                        "id": mapid,
                        "source": mapid
                    },
                    "srcdata": srcdata,
                    "raw": 1
                };
                return quickmap; 
            }

            var srcData = srcDataCreate(trackdata);  // console.log("ok srcdata");
            
            var quickViewObj = jsonTrackToQuickview(srcData, title, prefix);  // console.log("ok quickMapObj");

            return quickViewObj; 
        },    

        // SPECIFIC import of specific vendee-data 
        // into datastructure of routing-API
        trackDataCreate: function(rawdata, rawdbdata) {
            if (!rawdata || !rawdbdata) return;

            var icontemplate;
            // icontemplate = "circle-stroked-11"; // this.icon;
            // icontemplate = "boat-blue"; // this.icon;

            /**
                *  transform digitaldegree to d-m with 3 digits (last digit ca 1-2m)
                *  "maritime formatting"  
                */
            function dmtodd(dm, lonflag, prec) {
                if (!prec) prec = 6;
                dm = dm.split("°"); // console.log("dm-array", dm);
                dd = parseInt(dm[0]) + parseFloat(dm[1]) / 60;
                if (dm[1].slice(-1) == "W") dd = 0 - dd;
                if (dm[1].slice(-1) == "S") dd = 0 - dd;
                return dd;
            }


            // A. Redistribute raw master-data and wp-records into temporary objects (masters, routes) 
            var routes = {},
                masterdata = {},
                route, master, id;

            // A. Restructure master-table into collection    
            rawdbdata.forEach(function(st, j) {
                //  
                id = st.id;
                id = id.replace("<br>", "/")

                master = masterdata[id];
                if (!master) {
                    masterdata[id] = st;
                }
            }.bind(this));

            if (!this.connect) {
                this.masterdata = masterdata;
            }
            // console.log("masters", masterdata);

            // B. GROUP all position-records by id 
            //    into objects for every resolved track
            rawdata.forEach(function(wp, j) {
                //  
                var wpx = {},
                    lng, lat;
                var pass = mba.utcTime(wp.date + "." + wp.time);
                wpx.ab = pass;
                wpx.an = pass;

                // Apply specific 
                lat = dmtodd(wp.lat);
                lng = dmtodd(wp.lng);

                wpx.coords = [lng, lat]; // { "lng": lng, "lat": lat };
                wpx.icon = this.wpicon;

                //  
                id = wp.id;
                route = routes[id];
                if (!route) {
                    route = [];
                    routes[id] = route;
                }
                route.push(wpx);
            }.bind(this));

            // C. Join temporary masters- and routes-objects 
            //    into array of api-conform routes with wps sorted by time 
            var routedata = [],
                menudata = [];

            Object.keys(routes).forEach(function(id) {

                var trackpoints = routes[id];
                trackpoints.sort(function(wp1, wp2) {
                    return wp1.ab - wp2.ab;
                });

                /*************************
                    * Resolve original id into better readable one 
                    * and a "good title"
                    */
                var title = id.split(">")[1];

                id = id.replace("<br>", "/");
                // *************************

                var icon = icontemplate; // + "-" + id; // ???? 
                var item = {
                    "id": id,
                    "title": title,
                };
                var route = {
                    "id": id,
                    "title": title,
                    // "icon": icon,
                    "unitsystem": "nautic",
                    "nodes": trackpoints
                };

                // optionally include Stammdaten
                if (masterdata[id] && this.connect) {
                    route["master"] = masterdata[id];
                }

                routedata.push(route);
                menudata.push(item)

            }.bind(this));
            // console.log("importVendee finaldata", routedata); // , rawdata);

            this.routedata = routedata;
            this.menudata = menudata;
        },



    });
</script>

</dom-module>