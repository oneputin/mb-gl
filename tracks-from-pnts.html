<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="routing-classes.html">
<link rel="import" href="mb-app-behavior.html">
<link rel="import" href="mb-map-behavior.html">

<!--
`tracks-from-pnts`
Interface for import/export of tracking data from handheld gps-devices

Optional: create quick-preview-data 

@demo demo/routingtracks.html 
-->

<dom-module id="tracks-from-pnts">

<template>

    <style is="custom-style">
        :host {
            position: absolute;
            display: none; /*inline-block;*/
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <iron-ajax
        auto
        url="[[_dataurl]]"
        handle-as="json"
        on-response="_getRawData">
    </iron-ajax>

    <iron-ajax
        auto
        url="[[_masterurl]]"
        handle-as="json"
        on-response="_getRawData">
    </iron-ajax>

</template>

<script>
    Polymer({
        is: 'tracks-from-pnts',

        properties: {

            // OUT: can be processed in "quickViewer"
            trackdata: {
                type: Object,
                notify: true
            },

            // IN: 
            srcmeta: {
                type: Object,
            },

            /**
             * Flags required format of track-output
             */
            logmode: {
                type: Boolean,
                value: false
            },

            _rawdata: {
                type: Object,
                value: {}
            },

            // Required (also if empty)
            _masterdata: {
                type: Object                
            },

            _dataurl : {
                type: String
            },

            _masterurl : {
                type: String
            },

        },

        behaviors: [
            Mbb.AppBehavior,
            Mbb.MapBehavior
        ],

        observers: [
            '_triggerQuery(srcmeta.*)',
            '_createTrackData(_rawdata, srcmeta, logmode, _masterdata)'
        ],

        attached: function() {
            // console.log("target attached");
        },

        // derive ajax-parameters from metadata
        _triggerQuery: function(srcmeta) { // trigger new dataquery !!
            if (srcmeta.path == 'srcmeta') srcmeta = srcmeta.value;

            if (srcmeta.type.indexOf("table") < 0) { // console.log("Cannot query data from:", srcmeta);  
                this._rawdata = null; // 
                return;
            }  
            // set parameters for data-fetch with <iron-ajax>
            this._dataurl = srcmeta.url;

            if (srcmeta.master) {
                this._masterurl = srcmeta.master;
            } else {
                this._masterdata = {};
            }    
        },

        // Update notified element-variables from ajax-responses   
        _getRawData: function(ajaxresponse) {
            if (!ajaxresponse || !ajaxresponse.detail) return;
            // console.log("_getRawData, response", ajaxresponse); // .detail.response);
            var srcurl = ajaxresponse.detail.url,
                response = ajaxresponse.detail.response;
            if (srcurl == this._dataurl)   this._rawdata = response;
            if (srcurl == this._masterurl) this._masterdata = response;
        },
        
        // Common SHELL for processing variants of pntdata 
        // Vomue, vendee 
        _createTrackData: function(rawdata, srcmeta, logmode, masterdata) {
            if (!rawdata || !Object.keys(rawdata).length) return; 
            // console.log(srcmeta, "RAW-data:", rawdata, "MASTER-data", masterdata); // return; 

            this.debounce('rawtracks', function() {

                // 1. Heuristik "DETECT the table-mode" of rawdata 

                var tablemode = (rawdata[0]["geometry"]) ? "json" : "nn";
            
                tablemode = (rawdata[0]["Header"] == "Trackpoint") ? 'table-vomue1' : tablemode;
            
                tablemode = rawdata[0]["Pnt"] ? 'table-vomue2' : tablemode;
            
                tablemode = rawdata[0]["lat"] ? 'table-vendee' : tablemode;

                // 2. Create RAW trackdata 
                var rawtracks, minTrackLength;

                if (tablemode.indexOf("vomue") > 0) {            

                    if (!logmode) minTrackLength = srcmeta.minTrackLength;
                    rawtracks = this.rawTracksDevice(rawdata, tablemode, minTrackLength);  // console.log("Raw GPSTracks. ", rawtracks); 
            
                } else if (tablemode.indexOf("vendee") > 0) {    
                    
                    rawtracks = this.rawTracksVendee(rawdata, masterdata);  // console.log("Raw VENDEETracks.",  rawtracks); 

                } else {

                }
                if (!rawtracks) {
                    console.log("BREAK. Selected dataset cannot be analysed!!", srcmeta);
                    return;
                }      

                // 3. Create DERIVATES  of rawTracks 

                if (logmode) {   // 3.1 derive features for mb-visualization of rawTracks

                    this.trackdata = this.trackLogCreate(rawtracks, srcmeta);
                    
                    // console.log("TRACK Logs (from TPs):", this.rawtracks);  
                    
                } else {    // 3.2 derive structures for mb-based animation of 'suitable' tracks

                    var trackdata = this.trackDataCreate(rawtracks, masterdata, srcmeta); 
                    if (trackdata) {    // console.log("RAW TRACK data (from TPs) :", routedata);  
                        this.trackdata = trackdata;
                    } 
                }
            }, 500); 

        },

        // Convert tabular ( point-collections) data created on gps-devices 
        // into point-collections to be used as tracks 
        // Use "very simple" segementation-algorithm of point-collections
        // !! For animation abandon "short" segments !! 
        rawTracksDevice: function(rawdata, tablemode, minTrackLength) {
            // console.log("rawTracksDevice: rawdata=", rawdata);

            // Dis-assemble rawdata-recordings that contain "separable tracks"  
            // with mode-specific algorithms - assigning a unique track-ID
            function handheldCoords(cc, targetformat, prec) {
                if (!targetformat) targetformat = "dd";
                if (!prec) prec = 6;
                // Split into 4 parts : 
                // latDeg, latMin, lngDeg, lngMin
                var coords = cc.split(" ");

                lat = coords[0];
                lat = lat[0] == "N" ? "+" + lat.slice(1) : "-" + lat.slice(1);

                lng = coords[2];
                lng = lng[0] == "E" ? "+" + lng.slice(1) : "-" + lng.slice(1);

                if (targetformat == "dd") {
                    lat = parseInt(lat) + (parseFloat(coords[1]) / 60);
                    lng = parseInt(lng) + (parseFloat(coords[3]) / 60);

                } else if (targetformat == "dm") {
                    lat = (parseInt(lat) * 60) + parseFloat(coords[1]);
                    lng = (parseInt(lng) * 60) + parseFloat(coords[3]);
                }
                coords = [lng, lat]; // console.log("dd-array", dd);
                return coords;
            };

            // 
            function handheldTime(traw, asdate) {
                // !! for (later) use of date-parser 
                // the MONTH must be numbered 0 .. 11 !!
                var t, a, aa, tstandard, tdate;
                if (typeof traw == "string") {

                    t = traw.split(":").join(".");
                    t = t.split(" ").join(".");
                    a = t.split(".");

                    aa = [a[2], a[1], a[0], a[3], a[4], a[5]]; // datum umordnen

                    tstandard = aa.join(".");

                    tdate = new Date(parseInt(aa[0]), parseInt(aa[1]) - 1, parseInt(aa[2]), parseInt(aa[3]), parseInt(aa[4]), parseInt(aa[5]));

                } else {
                    tdate = traw;
                    tstandard = traw
                } // console.log("handheldTime", traw, t, a, tunix)

                if (asdate) return tdate;
                return tstandard;
            };

            // tool STABW 
            function stabw(array) {
                var len = 0;
                var sum = array.reduce(function(pv, cv) {
                    ++len;
                    return pv + cv;
                }, 0);
                var mean = sum / len;
                var result = 0;
                for (var i = 0; i < len; i++)
                    result += Math.pow(array[i] - mean, 2);
                len = (len == 1) ? len : len - 1;
                return Math.sqrt(result / len);
            };

            var routes = {},
                // routedata = [],
                tp, trackpoints;
            var t, dt, dx, dt_std, dx_std, v, dv_std, z,
                vprev = 0;

            if (tablemode.indexOf("vomue1") >= 0) 
                tablemode = "vomue1";

            else if (tablemode.indexOf("vomue2") >= 0) 
                tablemode = "vomue2";
            
            else {
                console.log("BREAK. tablemode not usable: ", tablemode);
                return;
            }

            // Step1: Analyse STDDEV of DT, DX-data (if available)   

            var dts = [],
                dxs = [],
                dvs = [];
                zz  = [];
            rawdata.forEach(function(tp, j) {

                if (tablemode == "vomue1") {
                    dt = tp["Leg Time"].split(":");
                    dx = tp["Leg Length"].split(" ");
                    v = tp["Leg Speed"].split(" ");
                    z = tp["Altitude"].split(" ");
                }
                if (tablemode == "vomue2") {
                    dt = tp["dt"].split(":");
                    dx = tp["dx"].split(" ");
                    v = tp["v"].split(" ");
                    z = tp["z"].split(" ");
                }
                // console.log(dt,dx,v);
                // unit 
                dt = 3600 * parseInt(dt[0]) + 60 * parseInt(dt[1]) + parseInt(dt[2]); // always [s]
                dx = (dx[1] == "km") ? parseInt(dx[0]) * 1000 : parseInt(dx); // always in [m] 
                dv = parseFloat(v[0]) - vprev; // dv = is always km/h
                vprev = parseFloat(v[0]);
                // console.log("dv=" + dv, v);
                dts.push(dt);
                dxs.push(dx);
                dvs.push(dv);
                zz.push(z[0]);
            });

            if (dts.length) {
                dt_std = Math.round(stabw(dts));
                dx_std = Math.round(stabw(dxs));
                dv_std = Math.round(stabw(dvs));
                //console.log("dt-std [sec]:", dt_std);
                //console.log("dx-std [m]:", dx_std);
                //console.log("dv-std [km/h]:", dv_std);
            }

            // Step2 : Abschnittsweise zuordnen untersch. ids  

            var trackid = 1;
            rawdata.forEach(function(tp, j) {

                if (tablemode == "vomue1") {
                    dt = tp["Leg Time"].split(":");
                    dx = tp["Leg Length"].split(" ");
                    v = tp["Leg Speed"].split(" ");
                }

                if (tablemode == "vomue2") {
                    dt = tp["dt"].split(":");
                    dx = tp["dx"].split(" ");
                    v = tp["v"].split(" ");
                }

                // TEST-parameter 
                dt = 3600 * parseInt(dt[0]) + 60 * parseInt(dt[1]) + parseInt(dt[2]);                
                dx = (dx[1] == "km") ? dx[0] * 1000 : dx;

                // Neues segment (id), 
                // wenn TEST-parameter "zu groß" sind h
                if ((dt > dt_std) || (dx > dx_std)) 
                    trackid = trackid + 1;

                // Zuordnen der ID    
                tp.id = trackid;

            });

            // B. G R O U P  all TP-records 
            //    into track-objects by TP-id 

            rawdata.forEach(function(tp, j) {
                var tpx = {};

                Object.keys(tp).forEach(function(k) {

                    if (tablemode == "vomue1") {
                      
                        if (k == "Position") {

                            coords = handheldCoords(tp[k]);
                            tpx["coords"] = coords;

                        } else if (k == "Time") {

                            time = handheldTime(tp[k]);
                            tpx["ab"] = time;
                            tpx["an"] = time; // 

                        } else if (k == "Altitude") {

                            tpx["z"] = tp[k];

                        } else {
                            tpx[k] = tp[k];
                        }
                    }

                    if (tablemode == "vomue2") {
                      
                        if (k == "coords") {
                            coords = handheldCoords(tp[k]);
                            tpx["coords"] = coords;
                      
                        } else if (k == "Date") {
                            time = handheldTime(tp[k]);
                            tpx["ab"] = time;
                            tpx["an"] = time; // 

                        } else {
                            tpx[k] = tp[k];
                        }
                    }

                })

                if (!tpx.coords) {
                    console.log("TP-record without coords", tp);
                } else {
                    // Distribute the trackpoints into "separable" tracks
                    // (if wpts are pre-grouped by track-id)  
                    if (tp.id) {
                        id = tp.id;
                        route = routes[id];
                        if (!route) {
                            route = [];
                            routes[id] = route;
                        }
                    } else {
                        route = routes["raw"];
                        if (!route) {
                            route = [];
                            routes["raw"] = route;
                        }
                    }
                    // console.log(tpx);
                    route.push(tpx);
                }
            }.bind(this));

            // C. "Sortieren innerhalb der Gruppen"
            //    und Zuordnen der "ab"-zeit des ersten TP als Key

            var alltracks = {}, trackpoints, trackid;

            Object.keys(routes).forEach(function(id) {
                
                trackpoints = routes[id];

                trackpoints.sort(function(wp1, wp2) {
                    return this.utcTime(wp1.ab) - this.utcTime(wp2.ab);
                }.bind(this));
                
                // console.log(id, trackpoints[0]);
                trackid = trackpoints[0].ab; 

                alltracks[trackid] = trackpoints;
                
            }.bind(this));    
            // console.log("raw route-tracks", tracks);

            // D. Option: Filtern "zu kurzer" tracks 
            //            (length < minTrackLength)

            var tracks = {} ;
            if (minTrackLength) {
                Object.keys(alltracks).forEach(function(trackid) {
                    if (alltracks[trackid].length >= minTrackLength)
                        tracks[trackid] = alltracks[trackid];
                });
            } else {
                tracks = alltracks;
            }

            return tracks; 
        },


        // SPECIFIC import of specific vendee-data 
        // into datastructure of routing-API
        rawTracksVendee: function(rawdata, rawmasterdata) {
            if (!rawdata || !rawmasterdata) return;

            var icontemplate;
            // icontemplate = "circle-stroked-11"; // this.icon;
            // icontemplate = "boat-blue"; // this.icon;

            // Redistribute raw master-data and wp-records into temporary objects (masters, routes) 
           
            var tracks = {},
                masterdata = {},
                track, master, id;

            // A. Restructure master-table into collection    
            if (rawmasterdata.constructor === Array) {
                rawmasterdata.forEach(function(st, j) {
                    //  
                    id = st.id;
                    id = id.replace("<br>", "/")

                    master = masterdata[id];
                    if (!master) {
                        masterdata[id] = st;
                    }
                }.bind(this));

                if (!this.connect) { // ???  
                    // this._masterdata = masterdata;
                }
            }

            // console.log("MASTERS preprocessed:", masterdata);

            // B. GROUP all position-records by id 
            //    into objects for every resolved track
            rawdata.forEach(function(wp, j) {
                //  
                var wpx = {},
                    lng, lat;
                var pass = this.utcTime(wp.date + "." + wp.time);
                wpx.ab = pass;
                wpx.an = pass;

                // Apply specific 
                lat = this.dmtodd(wp.lat);
                lng = this.dmtodd(wp.lng);

                wpx.coords = [lng, lat]; // { "lng": lng, "lat": lat };
                wpx.icon = this.wpicon;

                //  
                id = wp.id;
                track = tracks[id];
                if (!track) {
                    track = [];
                    tracks[id] = track;
                }
                track.push(wpx);
            }.bind(this));

            // C. Join temporary masters- and tracks-objects 
            //    into array of api-conform "track"" with wps sorted by time 
            var trackdata = [];

            Object.keys(tracks).forEach(function(id) {

                var trackpoints = tracks[id];

                trackpoints.sort(function(wp1, wp2) {
                    return wp1.ab - wp2.ab;
                });

                /*************************
                * Resolve original id into better readable one 
                * and a "good title"
                */
                var title = id.split(">")[1];

                id = id.replace("<br>", "/");
                // *************************

                var icon = icontemplate; // + "-" + id; // ???? 
                var item = {
                    "id": id,
                    "title": title,
                };

                var track = {
                    "id": id,
                    "title": title,
                    // "icon": icon,
                    "unitsystem": "nautic",
                    "nodes": trackpoints
                };

                // optionally include Stammdaten
                var addmaster = masterdata[id]; //  && this.connect; 
                if (addmaster) {
                    track["master"] = masterdata[id];
                }
                trackdata.push(track);
            }.bind(this));

            this.routedata = trackdata; // *** ???? 

            // D. Convert into "mappable" tracks
            var tracks = {};
            trackdata.forEach(function(rrec){
                tracks[rrec.id] = rrec.nodes;
            }) 
            // console.log("importVendee rawdata", tracks); // , rawdata);

            return tracks; 
        },


        // Derive input-data-structures for my-animatation-api
        trackDataCreate: function(rawtracks, masterdata, metadata) {

            // C. Join temporary masters- and routes-objects 
            //    into array of api-conform routedata (wps sorted by time) 

            var trackdata = [],
                trackpoints;

            var unitsystem = metadata.units ? metadata.units : "metric";

            Object.keys(rawtracks).forEach(function(id) {

                trackpoints = rawtracks[id];

                var title = trackpoints[0].ab;

                var tracklog = {
                    "id": id,
                    "title": title,
                    "unitsystem": unitsystem,
                    "nodes": trackpoints
                };

                // Optionally: include Stammdaten
                if (masterdata && masterdata[id]) { // && this.connect) {
                    tracklog["master"] = masterdata[id];
                }

                // *** Required ***  
                tracklog.trackmode = true;

                trackdata.push(tracklog);

            }.bind(this));

            return trackdata;
        },

        // Derive contentBox of raw tracks
        trackLogCreate: function(trackdata, srcmeta) {
            // console.log("CREATEPREVIEW", trackdata, srcmeta ); 

            var scope = this;
            var prefix = ""; // tracks";
            var title = srcmeta.key;
            if (!title) title = srcmeta.title;
                        
            // Create 
            function traceDataCreate(trackdata) {
                var features = [],
                    starttime ;

                Object.keys(trackdata).forEach(function(id){
               
                    if (!starttime) starttime = id; 
                    var coords = [],
                        coordTimes = [],
                        coordZ = [],
                        nodes = trackdata[id];  // console.log("nodes", nodes);

                    nodes.forEach(function(node){
                        coords.push(node.coords);
                        coordZ.push(node.z);
                        if (node.ab) coordTimes.push(node.ab);
                        else coordTimes.push(node.an);
                    })

                    var properties = {
                            id: id,
                            color: scope.getRandomColor(),
                            time: id, // nodes[0].ab
                            coordTimes: coordTimes,
                            coordZ: coordZ
                        };

                    var trace = new TraceSource(coords, id, properties);
                    
                    properties.length = scope.deltaL(trace); // console.log("TraceLog", trace);

                    features.push(trace);
                })
                
                var traceData = {
                    features: features,
                    time: starttime,
                    type: "FeatureCollection"
                } ;

                return traceData;
            } 

            // 
            function traceContentCreate(srcdata, title, prefix) {
                // if (!prefix) prefix = "tracks"
                if (!title) title = srcdata.time;

                var mapid = title;
                if (prefix) mapid = prefix + "-" + mapid;
                
                var quickmap = {};                
                quickmap[mapid] = {
                    "layer": {
                        "type": "line",
                        "id": mapid,
                        "source": mapid
                    },
                    "srcdata": srcdata,
                    "raw": 1
                };
                return quickmap; 
            }

            var traceData = traceDataCreate(trackdata);  // console.log("ok srcdata");
            
            var traceContent = traceContentCreate(traceData, title, prefix);  // console.log("ok quickMapObj");

            return traceContent; 
        },    


    });
</script>

</dom-module>