<link rel="import" href="../polymer/polymer.html">

<script>
  /**
   * `Mbb.MapBehavior` 
   * Utilities, useful in geo-context 
   *
   * @polymerBehavior Mbb.MapBehavior
   * @demo demo/index.html
   **/
    window.Mbb = window.Mbb || {};

    Mbb.MapBehavior = {

        properties: {
            mbbtest: {
                value: 99
            },
            popup:{
                type: Object
            } 
        },

        // Utility for one-click re-orientation of a map  
        mapLocate: function(maporientation, minZoom, maxZoom) {
            if (!this.map) return; 
            if (!minZoom ) minZoom = 4; 
            if (!maxZoom ) maxZoom = 8; 

            var ma = maporientation,
                map = this.map, 
                mm = {};    

            mm.zoom = map.getZoom(),
            mm.center = map.getCenter(),
            mm.bearing = 360 + map.getBearing();
            mm.bearing = mm.bearing == 360 ? 0 : mm.bearing;

            Object.keys(ma).forEach(function(k){
                mm[k] = ma[k];
            }) 

            if (mm.align) {
                console.log("ALIGN mapOrientation with params=", mm);

                if (mm.zoom < minZoom) mm.zoom = minZoom;
                map.flyTo({
                    center: mm.center,
                    bearing: mm.bearing,
                    zoom: mm.zoom
                });

            } else if (mm.bearing > 0) {
                console.log("RESET mapOrientation to North with params ", mm);

                if (mm.zoom > 8) mm.zoom = 8; // ?

                map.easeTo({
                    bearing: 0,
                    zoom: mm.zoom
                    //speed: 0.2, // make the easeMove slower
                    //curve: 1,   // change the speed at which it changes zoom
                });
            }
        },    


        /**
            *  ??? 
            *
            */
        getSourceIdFeature: function(idfilter, contentlayer) {
            console.log("CHECK", idfilter, contentlayer);
            var contentsrc = contentlayer.srcdata,
                contentid = contentlayer.id,
                idname = idfilter.slice(1,2),
                idvalue = idfilter.slice(2,3),
                rrall = [];

            if (typeof contentsrc == "string") {
                var contentsrcdata = map.getSource(contentsrc); console.log("layersrc:", contentsrc, contentsrcdata);
                if (contentsrcdata) {
                    rrall = contentsrcdata.features;  
                }    
            } else {
                rrall = contentsrc.features;
            }
            
            if (!idvalue || !rrall.length) {
                console.log("NO Features queried for filter=" + idfilter, rrall);
                return rrall;
            }   // console.log("routeSrces for [" +fid+ "] from 'contentbox'", contentbox, rrall); 

            // A. 
            var rr = [];
            console.log("content-applyFilter:", idname, idvalue, rrall);

            rrall.forEach(function(r) {
                if (r[idname] == idvalue) {
                    rr.push(r);
                }
            });
            console.log("queried raw routeData for filter=",idfilter, idname,idvalue,rr);
    
            // B. Zoom to features in actual viewframe
            if (map && (!rr.length)) {
                rr = map.querySourceFeatures(contentid, {
                    filter: idfilter
                });
                console.log("mapbox-applyFilter:", idfilter, rr, rrall);
            }
            
            return rr;
        },


        // Get the geometry of sourceFeature "below" a tile-feature
        getSourceFeature:  function (tileFeature, layerid) {

            var srcLayer = map.getLayer(layerid),
                srcInfo = {}, keyname, keyvalue ; 

            if (srcLayer) {

                var keys = this.guessFeatureKeys(tileFeature);
                if (keys.length) {
                    keyname  = keys[0];  
                    keyvalue = keys[1];  
                }

                var theSource = map.getSource(srcLayer.source),
                    srcFeatures = theSource._data.features;
                // console.log("DEBUG", tileFeature, keys, srcFeatures);

                srcFeatures.some(function(f){
                    if (f.properties[keyname] == keyvalue) {   // console.log("DETECTED", f);
                        srcInfo.srcfeature = f;
                        srcInfo.keyname  = keyname;  
                        srcInfo.keyvalue = keyvalue;  
                        srcInfo.id = keyvalue;
                        return true;

                    }
                });
            }
            return srcInfo; 
        }, 


        tileFeatureContent: function(tileFeature, layerid) {
            if (!map) return; 
            //if (!this.map) return; // not declared in behavior !! 

            // A. GENERIC: Get SOURCE-properties for identified feature !!!
            var tileInfo = this.objectClone(tileFeature.properties);

            // B. GENERIC: SOURCE FEATURE (untiled)
            var srcInfo = this.getSourceFeature(tileFeature, layerid);  // console.log("srcInfo", srcInfo);  

            Object.keys(srcInfo).forEach(function(k){
                tileInfo[k] = srcInfo[k];
            }) 

            return tileInfo;
        },     

        // Get Info about "complete track", not only features in actually "visible" tile(s)
        guessFeatureKeys: function(feature, keyNames) {
            // Heuristik to identify suitable filter-key  
            if (!feature) return; 
            if (!keyNames) keyNames = ["id", "name", "key", "time"];

            var fInfo = feature.properties, // console.log("trackInfo", trackInfo, srcFeatures); 
                keyname
            keyNames.some(function(nom) {
                if (fInfo[nom]) {
                    keyname = nom;
                    return true;
                }
            });
            if (!keyname) return; 

            return [keyname, fInfo[keyname]]; 
        },    

        // Refresh content && location 
        // of an app-specific mapbox-popup 
        // default: html at map-center  
        popupOnMap: function(popupcontent) {
            // if (!this.map) return;
            // console.log("popupcontent",popupcontent);
            var html, lnglat, bbox, openflag;
            // map = this.map; // popup = this.popup;

            // Prepare a "" Info-Popup
            // to be closed on x-mark
            if (!this.popup) {
                this.popup = new mapboxgl.Popup({
                    closeButton: false,
                    closeOnClick: true
                });
            }

            if (typeof popupcontent == "object") {
                html = popupcontent.html;
                lnglat = popupcontent.lnglat;
                bbox = popupcontent.bbox;
                openflag = popupcontent.open;
            } else if (popupcontent) {  // String
                html = popupcontent;
            }
            if (!popupcontent || !html || (openflag == false) || this.trackmapmode) {
                this.popup.remove();
                return;
            }

            // Refresh popup contet and location
            if (!lnglat) {
                if (bbox) { // console.log("bbox", bbox);
                    lnglat = bbox.bounds.getCenter();
                } else { // console.log("map.getCenter", map.getCenter);
                    lnglat = map.getCenter();
                }
            }

            if (!this.popup.isOpen()) this.popup.addTo(map);

            this.popup
                .setLngLat(lnglat)
                .setHTML(html);
        },

        /**
         * formats lonlat into [180W - 180E] if requested from "extended" mapview 
         */
        formatlonlat: function(lnglat, format, zoom) {
            if (!lnglat) return "";
            if (!zoom) zoom = 5;
            // console.log("apply formatlonlat on:", lnglat, zoom);

            var prec = zoom > 10 ? 1 : 0;
            var lon, lat;
            var trafo = format == "dms" ? this.ddtodms : this.ddtodm; // ddtodms;

            if (typeof lnglat == "string") {
                lon = lnglat.split(",")[0];
                lat = lnglat.split(",")[1]
            } else {
                lon = lnglat.lng;
                lat = lnglat.lat;
            }

            var lonunit = ((lon < 0) && (lon > -180)) || (lon > 180) ? "W" : "E",
                latunit = lat < 0 ? "S" : "N";

            var lonx = trafo(lon, "lon"),
                latx = trafo(lat, "lat");
            // console.log("lon,lat",lon,lat,"lonx,latx",lonx,latx)

            return lonx + lonunit + "  " + latx + latunit;
        },

        /**
         *  transform digitaldegree to dms
         */
        ddtodms: function(dd, prec) {
            if (!prec) prec = 0;
            dd = parseFloat(dd);
            if (dd < 0) dd = 0 - dd;
            let d = Math.floor(dd), // console.log("dd,d=", dd, d)
                mm = (dd - d) * 60, // [minutes]
                m = Math.floor(mm), // [minutes]
                ss = ((mm - m) * 60).toFixed(prec);
            if (ss == "60") {
                m = m + 1;
                ss = "00";
            }
            return d + "°" + m + "'" + ss + '"';

        },

        /**
         *  transform digitaldegree to d-m with 3 digits (last digit ca 1-2m)
         *  "maritime formatting"  
         */
        ddtodm: function(dd, lonflag, prec) {
            if (!prec) prec = 3;
            dd = parseFloat(dd);

            // lon only
            if (dd > 180) dd = 360 - dd;
            if (dd < -180) dd = 360 + dd;
            // lon and lat
            if (dd < 0) dd = 0 - dd;

            let d = Math.floor(dd), // console.log("dd,d=", dd, d)
                mm = (dd - d) * 60; // [minutes]
            m = mm.toFixed(3);

            if (d < 10) d = "0" + d;
            if (d < 100 && lonflag) d = "0" + d
            if (mm < 10) m = "0" + m;

            return d + "°" + m;
        },

        /**
         * Back-transform of "formatted" dm into raw dd
         * (fi vendee-data: "lat": "49°43.00'S", 
         *                  "lng": "162°32.42'E"
         */
        dmtodd: function(dm, lonflag, prec) {
                if (!prec || prec > 6) prec = 6;
            dm = dm.split("°"); // console.log("dm-array", dm);
            dd = parseInt(dm[0]) + parseFloat(dm[1]) / 60;
            if (dm[1].slice(-1) == "W") dd = 0 - dd;
            if (dm[1].slice(-1) == "S") dd = 0 - dd;
            return dd;
        },


        // ZoomTo
        setFeatureBounds: function(features) {
            // console.log("SFB:", features); // return

            if (features.features) features = features.features; 
            if (!features.length) return; //console.log(features); 

            // UNIFY coordsets (x,y) and (x,y,z) into (x,y)
            function concatcoords(coordinates, segment) {
                segment.forEach(function(cc) {
                    cc = [cc[0], cc[1]];
                    coordinates.push(cc);
                })
                return coordinates;
            }

            // Transform into list of coordinate-lists
            var coordinates = [],
                segments, coords, pnt, latitude, longitude, bb = {};

            for (var i = 0; i < features.length; i++) {
                t = features[i].geometry.type;
                segments = features[i].geometry.coordinates;
                if (t == "LineString") {
                    // coordinates = coordinates.concat(segments);
                    coordinates = concatcoords(coordinates, segments);
                } else if (t == "MultiLineString") {
                    for (var j = 0; j < segments.length; j++) {
                        // coordinates = coordinates.concat(segments[j]);
                        coordinates = concatcoords(coordinates, segments[j]);
                    }
                }
            };

            var bounds; 

            if (coordinates.length) {

                // Correctur DatumsGrenze
                coordinates.forEach(function(coord) {
                    if (coord[0] > 180) coord[0] = coord[0] - 360;
                    if (coord[0] < -180) coord[0] = coord[0] + 360;
                });
                // console.log("2-coordinates", coordinates);

                // ZOOM to bounds
                if (map) {
                    // Pass the first coordinates to `lngLatBounds` 
                    // & wrap each coordinate pair in `extend` to include them in the bounds result. 
                    bounds = coordinates.reduce(function(bounds, coord) {
                        return bounds.extend(coord);
                    }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
                    //console.log("4-totalbounds", bounds);

                    map.fitBounds(bounds, {
                        padding: 20
                    });
                }

            }

            // useful in case of sigleFeatureZoom  
            return {
                "bounds": bounds,
                "features": features,
                "id" : features[0].id
            }

        },

        // (geo)id-list of slide-features
        getFeatureKeys: function(data) {
            if (data.features) data = data.features; //console.log(data); // return
            if (!data.length) return; // console.log("getFeatureKeys", data); 
            var props, id, keys = [];
            for (var i = 0; i < data.length; i++) {
                id = data[i].id;
                props = data[i].properties;
                if (!id) {
                    id = props.id;
                    if (!id) id = props.name;
                    if (!id) id = i;
                }
                keys.push(id);
            }
            keys = keys.toString(); // 
            return keys;
        },

        // analysing slide-geometries
        getBoundingBox: function(data) {
            
            if (data.features) data = data.features; //console.log(data); // return
            if (!data.length) return; //console.log(data); 

            var segments, coords, pnt, latitude, longitude, bb = {};
            for (var i = 0; i < data.length; i++) {
                if (data[i].geometry.geometries) {
                    segments = data[i].geometry.geometries; //console.log("segments", segments);
                } else {
                    segments = [data[i].geometry];
                }

                for (var k = 0; k < segments.length; k++) {
                    
                    coords = segments[k].coordinates[0];

                    if (!bb.xMin) {
                        pnt = coords[0];
                        bb = {
                            "xMin": pnt[0],
                            "xMax": pnt[0],
                            "yMin": pnt[1],
                            "yMax": pnt[1]
                        };
                    }

                    for (var j = 0; j < coords.length; j++) {
                        longitude = coords[j][0];
                        latitude = coords[j][1];
                        bb.xMin = bb.xMin < longitude ? bb.xMin : longitude;
                        bb.xMax = bb.xMax > longitude ? bb.xMax : longitude;
                        bb.yMin = bb.yMin < latitude ? bb.yMin : latitude;
                        bb.yMax = bb.yMax > latitude ? bb.yMax : latitude;
                    }
                }
            }

            var bb = [
                [bb.xMin, bb.yMin],
                [bb.xMax, bb.yMax]
            ]; //console.log(bb);
            return bb;
        }

    };
</script>