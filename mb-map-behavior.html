<link rel="import" href="../polymer/polymer.html">

<script>
  /**
   * `Mbb.MapBehavior` 
   * Utilities, useful in geo-context 
   *
   * @polymerBehavior Mbb.MapBehavior
   * @demo demo/index.html
   **/
    window.Mbb = window.Mbb || {};

    Mbb.MapBehavior = {

        properties: {
            mbbtest: {
                value: 99
            },
            popup:{
                type: Object
            } 
        },

        // Specific initialization-(sync-)trigger 
        // after a new route-dataset was loaded
        onMapdataLoad : function(mapcontent, dataName){
            if (this.disable || (typeof map == "undefined")) return;
            var scope = this;
            var reacted = false;

            // Check applicability
            mapcontent = mapcontent.value; // Polymer !! 
            if (!dataName) dataName = Object.keys(mapcontent)[0] ; // 'routes';
            if (!dataName) return; 
            
            if (!mapcontent[dataName]) {
                console.log("MAPDATALOAD BREAK. NO content: "+dataName, mapcontent); 
                return;
            }     
            mapcontent = mapcontent[dataName];
            // console.log("MAPDATALOAD NEW ["+dataName+"]-content of mapcontent", mapcontent);  
            
            /**
                * load-event-action 
                * checks loaded tiles for features of source 
                */
            function onFeatureLoaded(e){ // console.log("onFeatureLoad", dataName, e);

                if (e.sourceId == dataName) {
                    // console.log("features of src ["+dataName+"] are loaded into actual map-port"); // , features); 
                    var features = map.querySourceFeatures(dataName);  

                    if (features.length) {
                        // console.log("FEATURES FOUND in MAPE", features); // , features); 

                        var startfeature = preAction(features);
                        
                        reAction(startfeature, mapcontent); 

                        // STOP listener on success
                        map.off("data", onFeatureLoaded); 

                        reacted = true;                      
                    }
                }
            }
            // "Detect desired" route in map-Context
            function preAction(features){

                function compareTrackTime(route, r) {
                    var tmax = route.properties.stop - route.properties.start,
                        t = r.properties.stop - r.properties.start;
                    if (t > tmax) {
                        route = r;
                    }
                    return route; 
                }

                // Sonderfall :
                function checkEndpoints(r) {
                    var routesLayer = map.getLayer(dataName);
                    if (!routesLayer) return; 
                    var rnodes;
                    var bbox = map.getBounds();
                    if (!r.properties.nodes) {
                        console.log("BREAK at", r.properties);	
                        rnodes = r.geometry.coordinates;
                        return;
                    } else {
                        rnodes = JSON.parse(r.properties.nodes); 
                    }      

                    var p0 = turf.point(rnodes[0].coords),
                        pn  = turf.point(rnodes[rnodes.length - 1].coords);
                        poly = turf.polygon([[
                            bbox.getSouthWest().toArray(), 
                            bbox.getNorthWest().toArray(), 
                            bbox.getNorthEast().toArray(), 
                            bbox.getSouthEast().toArray(), 
                            bbox.getSouthWest().toArray()
                        ]]); // console.log(r.properties.id, p0, pn, poly);
                    // console.log(turf.inside(p0, poly),turf.inside(pn, poly));
                    var isInside = turf.inside(p0, poly) && turf.inside(pn, poly);
                    return isInside;  
                }

                // Check FULL containment of feat-bbox in map-bbox
                function checkFeature(r, poly) {
                    var fbox = r.properties.bbox;
                    if (!fbox) return; 
                    if (typeof fbox == "string") fbox = JSON.parse(fbox);

                    var pll = fbox.slice(0,2),
                        pur  = fbox.slice(2);  // console.log(fbox, "LL", pll, "UR", pur);
                    var isok = turf.inside(turf.point(pll), poly) && turf.inside(turf.point(pur), poly);
                    return isok;
                }

                // 1. Extracts features compeletely(partially) within bbox (if any)
                var ff = [];
                if (map)  {
                    var bbox = map.getBounds(),
                        poly = turf.polygon([[
                            bbox.getSouthWest().toArray(), 
                            bbox.getNorthWest().toArray(), 
                            bbox.getNorthEast().toArray(), 
                            bbox.getSouthEast().toArray(), 
                            bbox.getSouthWest().toArray()
                        ]]); // console.log(r.properties.id, p0, pn, poly);
                    // console.log("PREACTION: check "+features.length+" candidates in poly", features, poly);

                    features.forEach(function(f){
                        if (checkFeature(f, poly)) ff.push(f)  
                        // if (checkEndpoints(f))  ff.push(f); 
                    });
                }

                if (!ff.length) ff = features; // console.log("PREACTION: candidate start-features: n="+ff.length, ff);

                var fstart = ff[0];

                // 2. SPECIAL ROUTES-Heuristic: Select feature with "longest" track-time
                if (fstart.properties.start) {
                    ff.forEach(function(f){
                        fstart = compareTrackTime(fstart, f);
                    });
                } 

                return fstart; 
            }     

            // Activate selected feature in "correct" app-context(=scope)
            function reAction(tilefeature, mapcontent){
                if (!tilefeature || !tilefeature.properties) return; 
                // internal and external trigger

                var props = tilefeature.properties,
                    fid = props.id,
                    startfeature; 
                if (fid) {
                    mapcontent.features.some(function(f){  // console.log(fid, f)
                        if (f.id == fid ){
                            startfeature = f;
                            return true; 
                        } 
                    })
                    if (!startfeature) {
                        startfeature = tilefeature;
                        startfeature.id = fid; // to enable "feedback" to contentBrowser
                    }                            
                    // console.log("LOAD-start REACTION with Feature, id=" + fid, startfeature, scope);
                    if (props.nodes) { 
                        scope.routeselected = startfeature;
                        scope.set("model.routeid", fid); 
                    } else {
                        scope.trackselected = startfeature;
                    }
                }
            }

            // START Listener to feature-loading
            map.on("data", onFeatureLoaded);

            // Pending Listener 
            setTimeout(function () { 
                // RETRY and STOP Listener after max pending time (Fi. 1 sec) 
                if (!reacted) { // console.log("AFTER timeOut TRY reAction();");
                    reAction(); // default "empty" reaction 
                }
                map.off("data", onFeatureLoaded); 

            }, 1000);

        },


        // Utility for one-click re-orientation of a map  
        mapLocate: function(maporientation, minZoom, maxZoom) {
            if (!this.map) return; 
            if (!minZoom ) minZoom = 4; 
            if (!maxZoom ) maxZoom = 8; 

            var ma = maporientation,
                map = this.map, 
                mm = {};    

            mm.zoom = map.getZoom(),
            mm.center = map.getCenter(),
            mm.bearing = 360 + map.getBearing();
            mm.bearing = mm.bearing == 360 ? 0 : mm.bearing;

            Object.keys(ma).forEach(function(k){
                mm[k] = ma[k];
            }) 

            if (mm.align) {
                console.log("ALIGN mapOrientation with params=", mm);

                if (mm.zoom < minZoom) mm.zoom = minZoom;
                map.flyTo({
                    center: mm.center,
                    bearing: mm.bearing,
                    zoom: mm.zoom
                });

            } else if (mm.bearing > 0) {
                console.log("RESET mapOrientation to North with params ", mm);

                if (mm.zoom > 8) mm.zoom = 8; // ?

                map.easeTo({
                    bearing: 0,
                    zoom: mm.zoom
                    //speed: 0.2, // make the easeMove slower
                    //curve: 1,   // change the speed at which it changes zoom
                });
            }
        },    


        /**
         *  filter some srcdata from a contentbox-layer
         *
         */
        filterContentSources: function(contentlayer, idfilter) {
            var contentsrc = contentlayer.srcdata,
                rrall = [], rr = [];
            // console.log("filterContentSources. CHECK filter, layer, src", idfilter, contentlayer, contentsrc);

            if (map && (typeof contentsrc == "string")) {    // map-source
                // 
                var contentsrcdata = map.getSource(contentsrc);  console.log("layersrc:", contentsrc, contentsrcdata);
                if (contentsrcdata) {
                    rrall = contentsrcdata.features;  
                }    
            } 
            if (!rrall.length) {                                // content-source
                rrall = contentsrc.features;
                // console.log("1", rrall);                 
            } 
            
            if ((idfilter.length > 2)  && rrall.length) {
                // FIRST: try to get raw sources from contentlayer 
                var idname = idfilter.slice(1,2)[0],
                    idvalue = idfilter.slice(2,3)[0];               

                rrall.forEach(function(r) {
                    // console.log("2", r, idname, idvalue);                 
                    if (r[idname] == idvalue) {
                        rr.push(r);
                    }
                });
            }
            // console.log("3", rr, rrall);                 

            if ((!rr.length) && map &&  map.getSource(contentlayer.id)) {
                // ALTERNATIVELY. Get sources from mapLayer 
                rr = map.querySourceFeatures(contentlayer.id, {
                    filter: idfilter
                });
                console.log("FILTERED tiled featuresources:", idfilter, rr);
            } else if (rr.length) {
                // console.log("FILTERED raw srcdata ", idfilter, rr); // , rrall);
            } else {
                console.log("NO Features queried for filter=", idfilter);
                rr = rrall;
            }   // console.log("routeSrces for [" +fid+ "] from 'contentbox'", contentbox, rrall); 

            return rr;
        },

        /** Get a 'universal' appFeature combining
         *   - the geometry of srcFeature
         *   - the properties of tileFeature
         *   - the layer of tileFeature
         *   - a unique identification derived by id-heuristic (guessFeatureIdent)
         */  
        mapFeatureGet:  function (feature) { // console.log("mapFeatureGet", feature);

            var mapFeature = {};

            // A. from menuFeature
            if (feature.type != "Feature") {
                mapFeature = feature.feature;
                mapFeature.layer = feature.layer
                mapFeature.id = feature.id; 
                mapFeature.idproperty = "id";  
                return mapFeature;
            } 

            var keys = this.guessFeatureIdent(feature.properties);
            keyname  = keys[0],  
            keyvalue = keys[1];  

            var theSource = map.getSource(feature.layer.source),
                srcFeatures = theSource._data.features;

            srcFeatures.some(function(f){
                if (f.properties[keyname] == keyvalue) {   // console.log("DETECTED", f);
                    mapFeature = f; 
                    return true;
                }
            });  // console.log("OK mapFeatureGet", mapFeature);

            // layer from tilefeature
            mapFeature.layer = feature.layer;

            // id from heuristics
            mapFeature.id = keyvalue;
            mapFeature.idproperty = keyname;  

            return mapFeature; 
        }, 

        // Join vector properties and mapVector into one object
        mapFeatureGetlog: function(tileFeature) {
            if (!map) return; 

            // A. mapFEATURE combines srcFeature and tileFeature
            var mapFeature = this.mapFeatureGet(tileFeature);
            // console.log("mapFeatureGetlog, feature:", tileFeature, mapFeature);
            
            // B. mapFeatureLog = properties of mapFeature
            var mapFeatureLog = mapFeature.properties;  //console.log("mapVector of ", tileFeature, mapVector);  
            Object.keys(mapFeature).forEach(function(k){
                if (k != 'properties') mapFeatureLog[k] = mapFeature[k];
            }); // console.log("OK mapFeatureGetLog", mapFeatureLog); 

            return mapFeatureLog;
        },     

        // Get Info about "complete track", not only features in actually "visible" tile(s)
        guessFeatureIdent: function(props, keyNames) {
            // console.log("guessFeatureIdent", props); 
            // Heuristik to identify suitable filter-key  
            if (!props) return; 
            if (!keyNames) keyNames = ["id", "name", "key", "time"];

            if (props.properties) props = props.properties;

            var keyname = "";
            keyNames.some(function(nom) {
                if (props[nom]) {
                    keyname = nom;
                    return true;
                }
            });
            if (!keyname) return []; 

            return [keyname, props[keyname]]; 
        },    

        // Refresh content && location 
        // of an app-specific mapbox-popup 
        // default: html at map-center  
        popupOnMap: function(popupcontent, options) {
            // if (!this.map) return;
            // console.log("popupcontent",popupcontent);
            var html, lnglat, bbox, openflag;
            if (!options) { // 
                options = {
                    closeButton: false,
                    closeOnClick: true
                };
            }    
            var setcenter = options["center"];
            
            // Prepare a "" Info-Popup
            // to be closed on x-mark
            if (!this.popup) {
                this.popup = new mapboxgl.Popup(options);
            }

            if (typeof popupcontent == "object") {
                html = popupcontent.html;
                lnglat = popupcontent.lnglat;
                bbox = popupcontent.bbox;
                openflag = popupcontent.open;
            } else if (popupcontent) {  // String
                html = popupcontent;
            }

            if (!popupcontent || !html || (openflag == false) || this.trackmapmode) {
                if (this.popup) {
                    this.popup.remove();
                    this.popup = null;
                }    
                return;
            }

            // Refresh popup contet and location

            if (!lnglat || setcenter) {
                if (bbox && bbox.bounds) { // console.log("bbox", bbox);
                    lnglat = bbox.bounds.getCenter();
                } else { // console.log("map.getCenter", map.getCenter);
                    lnglat = map.getCenter();
                }
            }

            if (!this.popup.isOpen()) this.popup.addTo(map);

            this.popup.setLngLat(lnglat)
                      .setHTML(html);

        },

        /**
         * formats lonlat into [180W - 180E] if requested from "extended" mapview 
         */
        formatlonlat: function(lnglat, format, zoom) {
            if (!lnglat) return "";
            if (!zoom) zoom = 5;
            // console.log("apply formatlonlat on:", lnglat, zoom);

            var prec = zoom > 10 ? 1 : 0;
            var lon, lat;
            var trafo = format == "dms" ? this.ddtodms : this.ddtodm; // ddtodms;

            if (typeof lnglat == "string") {
                lon = lnglat.split(",")[0];
                lat = lnglat.split(",")[1]
            } else {
                lon = lnglat.lng;
                lat = lnglat.lat;
            }

            var lonunit = ((lon < 0) && (lon > -180)) || (lon > 180) ? "W" : "E",
                latunit = lat < 0 ? "S" : "N";

            var lonx = trafo(lon, "lon"),
                latx = trafo(lat, "lat");
            // console.log("lon,lat",lon,lat,"lonx,latx",lonx,latx)

            return lonx + lonunit + "  " + latx + latunit;
        },

        /**
         *  transform digitaldegree to dms
         */
        ddtodms: function(dd, prec) {
            if (!prec) prec = 0;
            dd = parseFloat(dd);
            if (dd < 0) dd = 0 - dd;
            var d = Math.floor(dd), // console.log("dd,d=", dd, d)
                mm = (dd - d) * 60, // [minutes]
                m = Math.floor(mm), // [minutes]
                ss = ((mm - m) * 60).toFixed(prec);
            if (ss == "60") {
                m = m + 1;
                ss = "00";
            }
            return d + "°" + m + "'" + ss + '"';

        },

        /**
         *  transform digitaldegree to d-m with 3 digits (last digit ca 1-2m)
         *  "maritime formatting"  
         */
        ddtodm: function(dd, lonflag, prec) {
            if (!prec) prec = 3;
            dd = parseFloat(dd);

            // lon only
            if (dd > 180) dd = 360 - dd;
            if (dd < -180) dd = 360 + dd;
            // lon and lat
            if (dd < 0) dd = 0 - dd;

            var d = Math.floor(dd), // console.log("dd,d=", dd, d)
                mm = (dd - d) * 60; // [minutes]
            m = mm.toFixed(3);

            if (d < 10) d = "0" + d;
            if (d < 100 && lonflag) d = "0" + d
            if (mm < 10) m = "0" + m;

            return d + "°" + m;
        },

        /**
         * Back-transform of "formatted" dm into raw dd
         * (fi vendee-data: "lat": "49°43.00'S", 
         *                  "lng": "162°32.42'E"
         */
        dmtodd: function(dm, lonflag, prec) {
                if (!prec || prec > 6) prec = 6;
            dm = dm.split("°"); // console.log("dm-array", dm);
            dd = parseInt(dm[0]) + parseFloat(dm[1]) / 60;
            if (dm[1].slice(-1) == "W") dd = 0 - dd;
            if (dm[1].slice(-1) == "S") dd = 0 - dd;
            return dd;
        },


        // (Create&)ZoomTo FeatureBounds 
        setFeatureBounds: function(features, padding) {

            if (features.features) features = features.features; 
            if (!features.length) return; //console.log(features);
            // console.log("SFB:", features, padding); // return

            // UNIFY coordsets (x,y) and (x,y,z) into (x,y)
            function concatcoords(coordinates, segment) {
                segment.forEach(function(cc) {
                    cc = [cc[0], cc[1]];
                    coordinates.push(cc);
                })
                return coordinates;
            }

            // Transform into list of coordinate-lists
            var coordinates = [],
                segments, coords, pnt, latitude, longitude, bb = {};

            for (var i = 0; i < features.length; i++) {
                t = features[i].geometry.type;
                segments = features[i].geometry.coordinates;
                if (t == "LineString") {
                    // coordinates = coordinates.concat(segments);
                    coordinates = concatcoords(coordinates, segments);
                } else if (t == "MultiLineString") {
                    for (var j = 0; j < segments.length; j++) {
                        // coordinates = coordinates.concat(segments[j]);
                        coordinates = concatcoords(coordinates, segments[j]);
                    }
                }
            };

            var bounds; 

            if (coordinates.length) {

                // Correctur DatumsGrenze
                coordinates.forEach(function(coord) {
                    if (coord[0] > 180) coord[0] = coord[0] - 360;
                    if (coord[0] < -180) coord[0] = coord[0] + 360;
                });
                // console.log("2-coordinates", coordinates);

                // ZOOM to bounds
                if (map) { 
                    if (!padding) padding = 40; 
                    // Pass the first coordinates to `lngLatBounds` 
                    // & wrap each coordinate pair in `extend` to include them in the bounds result. 
                    bounds = new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]);
                    bounds = coordinates.reduce(function(bounds, coord) {
                        return bounds.extend(coord);
                    }, bounds);  

                    map.fitBounds(bounds, {
                        padding: padding
                    });

                } else {  // selfmade bounds-extend
                    var x = coordinates[0][0], y = coordinates[0][1];
                    bounds = {xmin:x,xmax:x,ymin:y,ymax:y};
                    
                    function extendbounds(bounds, coord){ // console.log(bounds, coord);
                        x = coord[0], y = coord[1];
                        if (x < bounds.xmin) bounds.xmin = x;
                        if (y < bounds.ymin) bounds.ymin = y;
                        if (x > bounds.xmax) bounds.xmax = x;
                        if (y > bounds.ymax) bounds.ymax = y;
                        return bounds; 
                    }
                    bounds = coordinates.reduce(function(bounds, coord) {
                        return extendbounds(bounds, coord);
                    }, bounds);  
                }   // console.log("TRACK bbox", bounds);

            }

            // useful in case of sigleFeatureZoom  
            return {
                "bounds": bounds,
                "features": features,
                "id" : features[0].id
            }

        },

        // (geo)id-list of slide-features
        getFeatureKeys: function(data) {
            if (data.features) data = data.features; //console.log(data); // return
            if (!data.length) return; // console.log("getFeatureKeys. from", data); 
            var props, id, keys = [];
            for (var i = 0; i < data.length; i++) {
                id = data[i].id;
                props = data[i].properties;
                if (!id) {
                    id = props.id;
                    if (!id) id = props.name;
                    if (!id) id = i;
                }
                keys.push(id);
            }
            keys = keys.toString(); // 
            return keys;
        },

        // analysing bbox of slide-geometries
        // polygons optionally with multiple segments
        getBoundingBox: function(data) {
            
            if (data.features) data = data.features; //console.log(data); // return
            if (!data.length) return; // console.log("getBoundingBox. from", data); 

            var segments, coords, pnt, latitude, longitude, bb = {};
            for (var i = 0; i < data.length; i++) {

                if (data[i].geometry.geometries) {
                    segments = data[i].geometry.geometries; //console.log("segments", segments);
                } else {
                    segments = [data[i].geometry];
                }

                for (var k = 0; k < segments.length; k++) {
                    
                    coords = segments[k].coordinates[0];

                    if (!bb.xMin) {
                        pnt = coords[0];
                        bb = {
                            "xMin": pnt[0],
                            "xMax": pnt[0],
                            "yMin": pnt[1],
                            "yMax": pnt[1]
                        };
                    }

                    for (var j = 0; j < coords.length; j++) {
                        longitude = coords[j][0];
                        latitude = coords[j][1];
                        bb.xMin = bb.xMin < longitude ? bb.xMin : longitude;
                        bb.xMax = bb.xMax > longitude ? bb.xMax : longitude;
                        bb.yMin = bb.yMin < latitude ? bb.yMin : latitude;
                        bb.yMax = bb.yMax > latitude ? bb.yMax : latitude;
                    }
                }
            }

            var bb = [
                [bb.xMin, bb.yMin],
                [bb.xMax, bb.yMax]
            ]; // console.log("getBoundingBox got:", bb);
            return bb;
        }

    };
</script>