
<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-app-behavior.html">

<script>
  /**
   * `Mbb.ContentBehavior` 
   * 
   *
   * @polymerBehavior Mbb.ContentBehavior
   * @demo demo/index.html
   **/
    window.Mbb = window.Mbb || {};

    Mbb.ContentBehavior = {

        properties: {
            /* featureselected: {
                type: Object,
                notify : true
            }*/
        },    

        behaviors: [
            Mbb.AppBehavior
        ],
    
        // Shell for diverse select-functions  
        featuresSelect: function(features, layerid) {
            // console.log("F's in "+ layerid, features); 
            var selectObj,
                f = features[0], 
                fprops = f.properties; 
            if (!fprops) return ; 

            if (fprops && fprops.coordTimes && map)  {  // SPEC-CASE : trackLogs 
                // temporarily enhance theme 'layerid' by HILITE-presentation
                selectObj = this.tracksHilite(features, layerid); 

            } else if (false)  {  // SPEC-CASE : Other 


            } else { // SIMPLE GeometryZoom 
                if (f.feature) {
                    f = f.feature;
                }
                selectObj = this.setFeatureBounds([f]);
            }    

            return selectObj; 
        },

        // Special "permanent" HILITE of selected tracks
        // by HILITE-TRACE + "commented" end-nodes  
        //   - zooms to the feature
        //   - show start/stop based on "id-Filter"	
        tracksHilite: function(features, layerid) {
            // by now for 1 feature onyl
            // var map = this.map; 

            if (!features || !features.length) return;  
        
            // this.debounce("track", function(){
            var trackFeature = features[0]; 
            
            // MB-Function for trackContent: 
            // 1. Create trackEndMarkers-layer
            function showTrackNodes(layerid, trackInfo) {
                // layer of nodes symbols with text in HALO
                var hilayerid = layerid + "-nodes",
                    hilayer = map.getLayer(hilayerid);
                if (!hilayer) return; 
                
                var fromicon = "toilet"; // "monument",
                    toicon = "harbor";

                var fromnode = trackInfo.fromnode.slice(0,2),
                    tonode   = trackInfo.tonode.slice(0,2),
                    fromtime = trackInfo.von,
                    totime = trackInfo.bis,
                    nodedata = { // for nodes-source = 2 points
                        "type": "FeatureCollection",
                        "features": [{
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": fromnode
                            },
                            "properties": {
                                "title": fromtime,
                                "icon": fromicon
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": tonode
                            },
                            "properties": {
                                "title": totime,
                                "icon": toicon
                            }
                        }]
                    } ;

                // map.addSource(layerid, node);    
                var src = map.getSource(hilayerid); 
                if (src)  {
                    // console.log("set nodes-data into ", hilayerid, nodedata, src); 
                    src.setData(nodedata);                     
                }    
            } 

            // 2. HILITE the TRACE of the track (Filtering-Layer)
            function showTrackLine(layerid, trackInfo) {
                // 
                var hilayerid = layerid + "-trace", // ?
                    hilayer = map.getLayer(hilayerid),  
                    keyname = trackInfo.keyname,
                    hifilter = ["==", keyname, trackInfo[keyname]];
                if (!hilayer) return ;

                // console.log("set trace-filter in " + hilayerid, hifilter, hilayer); 
                map.setFilter(hilayerid, hifilter);
            } 

            var trackInfo = this.trackGetInfo(trackFeature, layerid);  // console.log("Selected track(s)", trackInfo);  

            // APPLY start- and stop-nodes of track
            showTrackNodes(layerid, trackInfo); 

            // APPLY trace-overlay (gestrichelt) on track
            showTrackLine(layerid, trackInfo); 

            // Triggersignal to enable ZOOM & SYNC with sibling elements (fi. with menues )
            if (trackInfo.id)  {
                // console.log("tracksHilite: featureselected", trackInfo) ; 
                // this.featureselected = trackInfo;
            }    

            // ZOOM to complete track
            map.fitBounds(trackInfo.bbox, {
                padding: 40
            });

            // Prepare info-popup after mapFit
            map.once('moveend', function() {
                this.popupOnMap(trackInfo.html);
            }.bind(this));
        
            // }, 100);     
            return trackInfo; 
        },

        // Get Info about "complete track", not only features in actually "visible" tile(s)
        trackGetInfo: function(aLine, layerid) {
            if (!this.map) return; 
            
            var scope = this,
                map = this.map;

            var trackInfo = aLine.properties; // console.log("trackInfo", trackInfo, srcFeatures); 

            // Get SOURCE-properties for identified feature !!!
            var keys = this.guessFeatureKeys(aLine); 
            if (keys) {
                trackInfo.keyname = keys[0];  
                trackInfo.keyvalue = keys[1];  
                trackInfo.id = keys[1];

                var trackLayer = map.getLayer(layerid),
                    trackSource = map.getSource(trackLayer.source),
                    srcFeatures = trackSource._data.features;

                var keyname = trackInfo.keyname; 
                srcFeatures.some(function(f){
                    if (f.properties[keyname] == trackInfo[keyname]) {
                        // console.log("detected", trackInfo[keyname], f);
                        trackInfo.bbox = scope.setFeatureBounds([f]);
                        trackInfo.coords = f.geometry.coordinates;
                        trackInfo.fromnode = trackInfo.coords[0];
                        trackInfo.tonode = trackInfo.coords[trackInfo.coords.length - 1];
                        trackInfo.length = scope.deltaL(f);
                        return true;
                    }
                });
            }
            
            // Get time parameters from trackLog 
            if (trackInfo.coordTimes) { 

                var trackTimes = trackInfo.coordTimes; // console.log("trackTimes", typeof trackTimes, trackTimes);
                if (typeof trackTimes == "string") trackTimes = JSON.parse(trackTimes);
                // console.log(trackInfo, trackTimes);
                
                var n = trackTimes.length, // equal to number of coords
                    tvon = scope.trackTime(trackTimes[0]);
                    tbis = scope.trackTime(trackTimes[n - 1])
                    von = scope.utcTime(tvon, null, "h"),
                    bis = scope.utcTime(tbis, null, "h"),
                    dt = bis - von;
                // console.log(trackTimes[0],trackTimes[n-1], tvon, tbis, von,bis,dt);

                trackInfo.duration = scope.deltaT(dt);
                trackInfo.count = n;
                trackInfo.von = scope.logTime(von, "h");
                trackInfo.bis = scope.logTime(bis, "h");
            }

            // compile basic parameters as HTML 
            trackInfo.html = trackInfo.time +
                "<br>Length: " + trackInfo.length +
                "<br>Duration: " + trackInfo.duration +
                "<br>TP's: " + trackInfo.count;

            return trackInfo;
        }

    }

</script>