<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="mb-api.html">

<link rel="import" href="routing-classes.html">

<link rel="import" href="tracks-behavior.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="routing-behavior.html">

<!--<link rel="import" href="mb-behavior-info-vendee.html">-->

<!--
`routing-api`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="routing-api">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        Polymer({
            is: 'routing-api',

            properties: {

                // disable events originating 
                // from multipurpose content-browser
                disable : {
                    type: Boolean
                },    

                datasetlabel: "Animated Tracks",

                /**
                 * IN: raw data of all routes to be animated
                 */
                routedata: {
                    type: Object
                },
                
                /**
                 * Mapbox-js map to place routing elements 
                 */
                map: {
                    type: Object
                },

                /**
                 * Container of animation components 
                 */ 
                model : {
                    type: Object
                },

                /**
                 * Container for animation-status-parameters
                 * (timescale, start and stop in utcTime)
                 */
                timer: {
                    type: Object,
                    notify: true
                },

                /**
                 * Container with metadata of primary dataset 
                 */
                metadataset: {
                    type: Object,
                    // observer: '_checkObject'
                },

                /**
                 * Container for animation-data
                 */
                contentbox: {
                    type: Object,
                    notify: true
                    // observer: '_checkObject'
                },

                /**
                 * Container for animation-data
                 */
                mapcontent: {
                    type: Object,
                    // observer: '_checkObject'
                },

                /**
                 * Ctrl- and StatusFlag of Animation
                 */
                trackctrl: {
                    type: String,
                    notify: true
                },

                // Route-ExchangeObject to app-components 
                routeselected: {
                    type: Object,
                    observer: 'routeseletedApply',
                    notify: true
                },

                /**
                 * Make trackobj (incl some meta) available to external services 
                 * processing the data for presentation u.Ã¤.  
                 */
                trackdata: {
                    type: Object,
                    notify: true   //, observer: '_checkTrackdata'
                },

                /**
                 * User-defined Text generated from actual trackObj-properties
                 * z.B. for use in popups !!
                 */
                trackinfo: {
                    type: Object // ,  observer: '_checkTrackinfo'
                },

                /**
                 * Default symbol for map-display of selected trackObj 
                 */
                tracksymbol: {
                    type: String,
                    value: ""
                },

                /**
                 * StatusFlag toggling TrackingMap--NorthMap 
                 */
                trackalignmap: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                // INTERNAL variables

                /**
                 *  Counter of active animation step
                 */
                _counter: {
                    type: Number,
                    observer: 'animationReset'
                },

                /**
                 * contentbox for layers created for route-visualization by map-animation 
                 */
                _animationbox: {
                    type: Object,
                    notify: true
                },

                /**
                 * Basic mapbox-Info-popup 
                 */
                /*popup: {
                    type: Object
                },*/

                /**
                 * temp. copy of trackctrl during animation-interrupt
                 */
                _trackctrl: {
                    type: Boolean
                },

                /**
                 * Container of animation-ids
                 */
                _requestframeref: {
                    type: Array,
                    value: []
                },

            },

            behaviors: [
                Mbb.TracksBehavior,
                Mbb.MapBehavior,
                Mbb.RoutingBehavior
            ],

            observers: [
                '_animationSetup(routedata, metadataset, disable)', //, map)', // creates _animationbox
                '_animationMapSetup(map, _animationbox.*)',  // creates 'contentbox' for 
                '_mapAlignChange(trackalignmap, model.trackobj)',
                'onMapdataLoad(mapcontent.*, "routes")',
                'routeActivate(model.routeid, disable)',
                'trackCtrlAction(trackctrl)',
                'trackInfoPopup(trackinfo.*)',
                '_checkTimer(timer.*)'
            ],

            /**
             * set a 'quasiglobal' this-context for recursive calls during animation 
             * and setup track-features
             */
            ready: function() {
                mba = this;  // console.log("mba is set!", mba); 
                mba.model = {
                    data : {
                        routes : {},
                        tracks: {},
                        traces : {},
                        nodes : {}
                    },
                    loaded: false,
                    routeid: "",  // Unique id of route to be "processed" (fi. animated)
                    trackobj: {},
                    trackid: "",
                    trackdata: {} 
                }
            }, 

            /**
             *  Generic shell triggering an appAction requiring userdata (vector features)
             *  after these features are successfully loaded into map for actual map-tiles
             *  name: 
             *  preAction
             *  reAction: 
             */ 
            onFeatureLoad : function(dataName, preAction, reAction) {  

                var reacted = false;

                /**
                 * load-event-action 
                 * checks loaded tiles for features of source 
                 */
                function onFeatureLoaded(e){ // console.log("onFeatureLoad", e);
                    if (e.sourceId == dataName) {
                        // console.log("features of src ["+dataName+"] are loaded into actual map-port"); // , features); 
                        var features = map.querySourceFeatures(dataName);  

                        if (features.length) {
                            // console.log(features.length+" features loaded"); // , features); 

                            var status = preAction(features);

                            reAction(status); 

                            // STOP listener on success
                            map.off("data", onFeatureLoaded); 
                            reacted = true;                      
                        }
                    }
                }

                // START Listener to feature-loading
                map.on("data", onFeatureLoaded);

                // Pending Listener 
                setTimeout(function () { 
                    if (!reacted) { // console.log("NO featurs on map TILES!");
                        // STOP Listener after max pending time (Fi. 1 sec) 
                        reAction(); // default "empty" reaction 
                        map.off("data", onFeatureLoaded); 
                    }
                }, 1000);
            },

            // Derive and notify id and timer-interval of selectzed route/track  
            routeseletedApply: function(routeselected){
                // console.log("routeselectedApply, raw", routeselected, this.routedata);  
                if (this.disable) return;
                if (!routeselected || !this.routedata) return;
                if (routeselected.wait) return; 

                var routeid = routeselected.id;  
                if (routeselected.feature) {
                    routeselected = routeselected.feature;
                    if(routeselected.id) routeid = routeselected.id; 
                }   // console.log("routeselected, id=" + id, routeselected);  
                    
                var props = routeselected.properties;
                if (props && props.id) routeid = props.id; 
                if (!routeid) return;
                // console.log("START. routeselectedApply, ", id, props, routeselected ); // TraceSource ???

                // A. Triggers "routeActivate" for routeid on the map 

                this.set("model.routeid", routeid); 

                // B. Triggers reset of timer-bounds
                if (props && (props.start || props.stop)) {
                    // console.log("ID,PROPS: routeselectedApply:", id, props);
                    this.set("timer.start", props.start);
                    this.set("timer.stop", props.stop);
                }    

            },

            /** Prepare all map- and animationdata 
             *  required to view animated tracks on the map 
             *  - if routedata changed
             *  - if basic timescale of animation changed
             *  _animationSetup: function(routedata, map) {
             */
            _animationSetup: function(routedata, metadata, disable, timer) { 
                if (disable) return; 
                if (!routedata || !routedata.length || !routedata[0].nodes) return;
                if (!timer) timer = this.timer;
                // console.log("_animationSetup routedata/metadata/timer:", routedata, metadata, timer);
                this.set("metadata.datasetlabel", this.datasetlabel); 
                var scope = this,
                    map = this.map; 

                // RESET CTRL and 
                this.ctrlflag = false;
                // Remove existing mapThemes(&sources), that are named like the new ones 
                if (map)  {
                    this.trackFeaturesReset(map);
                }

                // A. Setup data-specific TIMER-properties  
                this.trackTimerSetup(routedata, timer); //  , timescale);

                // B. SETUP MAP for animation 

                this._animationBoxSetup(routedata); 

                // Trigger SETUP of 
                this._counter = 0;
                // this._counter = 1; // 0;
            },

            // Create a contentBox with SpaceTime-objects: ROUTEs- and TRACEs-, TRACKs-content
            // = (Meta)Layers, describing mapContent but not not adding to map yet          
            _animationBoxSetup: function(routedata) {
                // Order(REIHENFOLGE) important, as wp-reduction in routedata possible during route-setup  

                function checkContent(contentbox) {
                    // check if content-arrays are simultan ??
                    // console.log("checkContentBox", contentbox);
                    var n, ncheck, kcheck, kmsg, msg, 
                        keys = Object.keys(contentbox) ;

                    keys.every(function(k){

                        n = contentbox[k].srcdata.features.length;
                        if (!ncheck) {
                            ncheck=n;
                            kcheck=k;
                        }                         
                        if (n < ncheck) {
                            msg = " less entries at "+k+":"+n+", "+kcheck+":"+ncheck;
                            kmsg = k;
                            return false;
                        } else if (n > ncheck) {
                            msg = " more entries at "+k+":"+n+", "+kcheck+":"+ncheck;
                            kmsg = k;
                            return false
                        }
                        return true; 
                    })
                    if (msg) {
                        var ffcheck = contentbox[kcheck].srcdata.features,
                            ff = contentbox[kmsg].srcdata.features,
                            msg2;
                        console.log(msg, ffcheck, ff);
                        ffcheck.every(function(v,i) { 
                            if (v.id !== ff[i].id) {
                                msg2 = "first diff at index " + i + ", id=" + v.id; 
                                return false; 
                            } 
                            return true;
                        });    
                        console.log(msg2);
                        return false; 
                    }
                    return true ;
                }

                // A. Setup Timer for animation 
                var contentbox = {},
                    timer = this.timer, 
                    metadata = this.objectClone(this.metadataset);

                // B. Setup contentBox for animation-Objects

                // routes and traces
                contentbox = this.animationRoutesSetup(routedata, timer, metadata);  
                // console.log("basic contentbox from  route-data", routedata, contentbox);
                // track(point)s
                contentbox['tracks'] = this.animationTrackerSetup(routedata, timer, metadata);

                // contentbox['nodes'] = this.animationNodesSetup(routedata, metadata); // wayPoints or trackPoints

                if (!checkContent(contentbox)) return; 

                // ??? Doubled assignment of sourceData to trigger PM1-multi-parameter observer  ???
                this._animationbox = {};
                this._animationbox = contentbox; // triggers data-binding "refresh-action"

            } ,

            // Create a contentBox with Userdata-objects (fi. not animated waypoints)
            _bgBoxSetup: function(bgdata) {

            },

            /**
             * Create/Refresh mapLayers for changed content (routed Data)
             *
             * @param      {object}  contentbox  The iimapslayers for animation-apps 
             * @param      {object}  map         The map to show routetracker
             */
            _animationMapSetup: function(map, contentbox) {
                var debounceTime = 200;

                this.debounce('tomap', function() {

                    if (contentbox.path == '_animationbox') contentbox = contentbox.value;
                    if (!contentbox || !Object.keys(contentbox).length) return;

                    // console.log("SET/REFRESH animationMap from contentbox: ", contentbox);

                    // 1. Specify baselayer to use for feature-ctrl 

                    contentbox["routes"]["usefeatures"] = true; 

                    // 2. Setup Map-Events ("mouseover")
                    //  - to query track-features 
                    //  - or show info-popup etc  

                    Object.keys(contentbox).forEach(function(lname){
                        contentbox[lname]["events"] = {};
                    })

                    var mapevents = mba._animationMapEvents(map); 

                    if (mapevents)  {
                        contentbox["routes"]["events"] = mapevents; 
                    }
                    // console.log("contentbox", contentbox); 

                    // 4. Triggers the STANDARD add(refresh)layer-action off a contentbox 
                    //    (in <mb-content-manager>)

                    mba.contentbox = contentbox;
                    //*************************

                    // 3. (Re)Start- and StartZoom-action(s) 

                    mba._counter = 1;

                    if (0) {    // zoom to ALL features after Setup

                        mba.trackRoutesZoomTo();
                        mba._animationMapRefresh(mba.timer["start"], "FIRST START");

                    } else {    // to FIRST feature, if no feature found in bbox
                        // console.log("_animationMapSetup START with", contentbox) ;
                        // this.routeActivate(contentbox); // "visible", startid); 
                    }

                }, debounceTime);
            },


            // Events are related to the contentobject "routes" 
            // and are activated/deactivated when "routes"-contentobject is loaded/unloaded   
            _animationMapEvents: function(map) {
                // Move over (with mouse OR WISH)
                function f_mmove(e) {   
                    if (mba.trackctrl) { // acts during animation only (trackctrl != false!! 
                        mba.trackObjSelect(e);
                    }    
                };

                function f_click(e) {   
                    mba.trackObjSelect(e, true);
                    mba.routeNodeSelect(e);
                };

                // f3,f4 act in DEFAULT mapmode only (NORTH-map)   
                // triggering the _animationPause
                function f_movestart(e) {    // console.log("MAP - movestart. ","alignflag=" +  mba.trackalignmap);
                    if (!mba.trackalignmap) {
                        mba._animationPause(true); 
                    }
                };
                function f_moveeend(e) {   // console.log("MAP - moveend","alignflag=" +  mba.trackalignmap);
                    if (!mba.trackalignmap) { 
                        mba._animationPause(false); 
                    }
                };

                var events = {
                    'mousemove': f_mmove, 
                    'click': f_click, 

                    'movestart': f_movestart, 
                    'moveend': f_moveeend 
                }

                return events; 

            }, 

            // Manages START/STOP-Flag (trackctrl) of animation 
            // if map-move events (map moved by user) are fired during animation 
            _animationPause: function(mapismoved) {
                // console.log("map is moving:", mapismoved, "ctrl=", mba.trackctrl );
                if (mapismoved) {
                    // debouncing needless, becouse repeated movestart-events around first movend !!
                    // this.debounce('movestarted', function() {
                    if (mba.trackctrl == true) {
                        mba.trackctrl = false;
                        mba._trackctrl = true;
                        //console.log("PAUSED data-animation"); // , mba.trackctrl, mba._trackctrl);
                    }
                    //}, 200);
                } else {

                    this.debounce('movestopped', function() { 
                        // console.log("After INTERRUPTED", mba.trackctrl, mba._trackctrl);
                        if ((mba.trackctrl == false) && (mba._trackctrl == true)) {
                            // Resume animation, if it was stopped by PAUSER temporarily (_trackCtrl = true)  
                            mba.trackctrl = true;
                            mba._trackctrl = false;
                            // console.log("RESUMED data-animation");
                        }
                    }, 100);
                }
            },


            // Create a contentbox-Object for basic Layers related to animation-datasrces 
            // id : "routes", "traces", "nodes", "tracks"
            _animationContentSetup: function(id, type, srcdata, metas, mapstyle) { //paintprops, layoutprops) {
                if (!mapstyle) mapstyle = {};
                // if (!srcdata) ; 
                // A. DEFAULT presentation-props (layout,paint) 
                //    can be over-written later 
             
                var paints = {},
                    layouts = {};

                if (id == "routes") {
                    paints = {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        //"line-dasharray": [4, 4]
                        //"line-color": linecolor
                    }
                }

                if (id == "traces") { // C.2 TRACE
                    paints = {
                        "line-width": 2,
                        "line-opacity": 0.5,
                        //"line-color": linecolor
                    }
                }

                if (id == "nodes") {
                    layouts = {
                        // "icon-image": "{icon}",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 10,
                        "text-offset": [0, 0.3]
                    };
                }

                // B. Join with SPECIFIC props suppplied by app
                if (mapstyle.paints) paints = Object.assign({}, paints, mapstyle.paints);
                if (mapstyle.layouts) layouts = Object.assign({}, layouts, mapstyle.layouts);

                // C. Create mb-Layer
                
                var layerObj = new ContentItem(id, type, srcdata, paints, layouts, metas);

                return layerObj;
            },

            /*_timerFilterCreate: function(routeids) {
            },*/


            /**
             * SETUP the app for a given route (or specialAction filterkey)  
             * ( key = routeid or specific ctrl)
             */ 
            routeActivate: function(filterkey, disable) {
                if (disable) return; 
                var dataName = "routes";
                var timer = this.timer;
                if (!timer || !timer[dataName]) return;
                // console.log("ACTIVATE route, filterkey=", filterkey); // , "timer", timer); 
                // if (!map.getLayer(dataName)) return;

                var routeid, timerFilter, timerEntry, startTime, msg = "Apply route";

                // A. Eval filterkey-cases  

                if (filterkey == "all") {
                    // reset timer to "ALL"
                    this.trackTimerRefresh();

                } else if (filterkey == "clear") {
                    console.log("NOT implemented: CLEAR all features"); 
                    return; 

                } else if (typeof filterkey == "string") { // DEFAULT case : routeid is given 

                    routeid = filterkey;
                
                } else {
                    // B. Get the id of first route in contentbox-srcdata
                    var contentbox;
                    
                    if (filterkey) { // DEFAULT case : routeid is given 
                        contentbox = filterkey;
                    } else {         // Default(fallback, if no key) !! 
                        contentbox = this.contentbox;
                    }

                    if (contentbox && contentbox[dataName])  {
                        msg = "Get a FIRST Route from RAW srces";
                        var allfeatures = contentbox[dataName].srcdata.features; 
                        if (allfeatures.length) {
                            routeid = allfeatures[0].properties.id; 
                        }
                    }
                } 

                // B. SPATIAL and TEMPORAL ZOOM 
                //    + create Visibility-Filter of tracks

                if (routeid) {
                    // B.1 Refresh app-timer (triggers sync with related elements, fi. timer-ctrl) 
                    timerEntry = timer.routes[routeid];
                    startTime = timerEntry.start; 
                    // console.log("ROUTE ACTIVATE routeid=", routeid, "timerEntry", timerEntry); 

                    this.trackTimerRefresh(timerEntry);

                    // B.2 Zoom to "original/complete" route-geometry
                    this.trackRoutesZoomTo(null, routeid);

                    // B.3 Filter all trackpoint-related map-layers 
                    this._trackFilterApply(routeid);

                    // B.4 Prepare syncFilter
                    timerFilter = this._timerFilterCreate(routeid);

                    console.log("ROUTING ACTIVATED (id, key, timerEntry, timerFilter): ["+ routeid+"]", filterkey, timerEntry, timerFilter); 

                } else {

                    this.trackRoutesZoomTo();

                    this._trackFilterApply("");

                    timerFilter = this._timerFilterCreate("all");

                }   // console.log("routeActivate: Setup route(s) ["+routeid+"]", timerFilter); 

                // C. Apply timerFilter 

                // C1. Store/replace syncFilter in timer-object

                if (!timerFilter) {
                    delete timer.filter;
                } else {
                    timer.filter = timerFilter;
                }   
                // console.log("Setup animation for ["+ routeid+"], VON " + this.logTime(timer.start, "h"), "BIS " + this.logTime(timer.stop, "h")); 
                // console.log("with filter, timer:", timerEntry, timer ); 

                // D. Activate/Locate "filtered" animationFeature(s) on map and timeSlider 
        
                if (map) {
                    var animationFeatures = this._animationMapRefresh(null, null,  timerFilter);
                    // TEMPORAL Location at START of selected routes
                    if (animationFeatures && animationFeatures.routes) {   //console.log("running the FIRST animation-step");
                        // console.log("animationFeatures filtered for:" + routeid, srcFeatures, this.timer);
                        if (startTime ) this.trackStepAction(null, startTime); 
                        else this.trackStepAction(0);
                    }
                } 
            },


            // A. 

            /**
             * Compile a timer from animated routes
             *
             * @param      {Object}  routedata  The raw routedata
             * @param      {Number}  timescale  The timescale of animation
             * @return     {Object}  Collection of timeCtrls
             */
            trackTimerSetup: function(routedata, timer, timescale) {

                // A.**** Get Frametime ****
                // Bsp: frametime: 6 s fuer scale = 360 und fps=60 !!
                // Animationszeit 1s=6*60s=6min, 10s=1h Echtzeit 
                if (!timer) {
                    return ;
                }   

                // Option: using parameters from outside timer     
                timescale = timescale ? timescale : timer.timescalestart; 
                timescale = timescale ? timescale : timer.timescalemax; 
                
                var fpsstart = timer.fpsstart ? timer.fpsstart : timer.fpsmax; 
                fpsstart = fpsstart ? fpsstart : 60;  // DEFAULT

                timer.frametime = timescale / fpsstart; 
                // console.log("FRAMETIME[min]="+ timer.frametime, "from scale,fps", timescale, fpsstart); 


                // B. Express "tracelength"-time as number of animation steps

                if (timer.tracelength) {
                    if (typeof timer.tracelength == "string") {
                        var tl = this.utcTime(timer.tracelength, "s"),
                            nn = Math.round(tl / timer.frametime);
                        // console.log("trackTimerStart", this.timer, tl, nn);
                        timer.tracelength = nn;
                    }
                }

                // C.1 Assemble  start&stop for all waypoint-times 
                //   of every route 

                var wptimer = {};

                routedata.forEach(function(route, j) {
                    // console.log("route-" + j, route);
                    if (route.nodes) {

                        var starts = [],
                            stops = [];

                        route.nodes.forEach(function(wp, p) {
                            if (wp.ab) starts.push(wp);
                            if (wp.an) stops.push(wp);
                        }.bind(this));

                        // Collect 
                        wptimer[route.id] = {
                            "starts": starts,
                            "stops": stops
                        }; // [starts, stops, passes];
                    }
                }.bind(this));


                // C.2 Assemble start&stop times  
                //  - per route (and) 
                //  - for overall animation period
                // var start, stop;

                timer.routes = {};
                timer.traces = {};

                Object.keys(wptimer).forEach(function(id) {

                    var wpstart, wpstop, routestart, routestop;

                    var starts = wptimer[id]["starts"],
                        stops = wptimer[id]["stops"];

                    if (starts.length) {
                        wpstart = starts[0];
                        wpstop = starts[starts.length - 1];
                    }
                    if (stops.length) wpstop = stops[stops.length - 1];

                    if (wpstart && wpstop) {
                        routestart = this.utcTime(wpstart.ab, "h", wpstart.coords, "h");
                        routestop = wpstop.an ? wpstop.an : wpstop.ab;
                        routestop = this.utcTime(routestop, "h", wpstop.coords);
                    }

                    timer.routes[id] = {
                        "id": id,
                        "start": routestart,
                        "stop": routestop,
                    };

                    if (routestart) {
                        timer.routes[id]["date"] = this.logTime(routestart, "h", "/");
                    }    

                    //if (!start || (routestart < start)) start = routestart;
                    //if (!stop || (routestop > stop)) stop = routestop;

                }.bind(this));
                // console.log("timer for waypoints:", wptimer, timer);


                // D. OPTION: Get sorted sequences of start- and stop-times
                //   
                var startTimes = [],
                    stopTimes = [],
                    routes = timer.routes;
                for (let key in routes) {
                    startTimes.push(routes[key]["start"]);
                    stopTimes.push(routes[key]["stop"]);
                }
                startTimes.sort();
                stopTimes.sort();
                timer["starts"] = startTimes;
                timer["stops"] = stopTimes;

                // E. // Setup timer for complete routeset 
                this.timer = timer; 
                
                this.trackTimerRefresh(); // Setup timer for 

            },

            // Update timer-entries to FORCE databinding-events to timer-ctrls
            trackTimerRefresh: function(timerEntry) {
                var start, stop, 
                    n = this.timer.stops.length - 1;

                if (!timerEntry) {
                    start = this.timer.starts[0];
                    stop = this.timer.stops[n];
                    timerEntry = "all routes"; 
                } else {
                    start = timerEntry.start;
                    stop = timerEntry.stop;
                }

                // ** SET explicitely to notify changes for data-binding to ctrl-elements
                this.set("timer.start", start);
                this.set("timer.stop", stop);
                this.set("timer.time", start);
                // console.log("Timer refreshed for ", timerEntry, this.timer);
            },

            // B. TrackCtrls

            /**
             *  Actions after main animation ctrl changes 
             *
             * @param      {any basic type}  trackctrl  Main animation Ctrl
             */
            trackCtrlAction: function(trackctrl) {
                // var ctrlflag = "STOP";
                var ctrlflag = this._trackctrl;
                var scope = this;
                // console.log("LOG: trackctrl", trackctrl);

                // 1. Check CSQ-data
                function checkCSQ() {
                    if (!mba.timer) {
                        mba.popupOnMap("OOPS. AnimationTimer not prepared!");
                        mba.trackctrl = false;
                        return "STOP";
                    }
                    var modeldata = mba.model.data,
                        tracks = modeldata.tracks;
                    // console.log("modeldata", modeldata) ;
                    if (!tracks || !tracks.features || !tracks.features.length) {
                        mba.popupOnMap("OOPS. TrackData n.a.");
                        mba.trackctrl = false;
                        return "STOP";
                    }
                    return "START";
                }; 

                if (typeof trackctrl == "number") {  // A. trackctrl is a mapTime 
                    // console.log("ctrltime[h] set (slider o.Ã¤.)", trackctrl)
                    var tracktime = trackctrl,
                        located = this.trackStepAction(null, tracktime);
                    if (!located) {
                        ctrlflag = "STOP";
                        trackctrl = scope.logTime(trackctrl,"h",".")
                    }

                } else if (trackctrl) {
                    // console.log("trackCtrlActn:", typeof trackctrl, trackctrl);
                    
                    if (trackctrl == "reset") { // B. 
                        
                        this.trackctrl = false;     // triggers this function (trackCtrlAction) again 
                        this.trackalignmap = false; // 
                        this._trackId = undefined; 

                        this._counter = 0;

                        this.trackRoutesZoomTo();
                        
                        ctrlflag = "STOP";
                    
                    } else { // 

                        ctrlflag = checkCSQ(); // "STOP" or "START";

                    }

                } else {

                    if (this._counter) {
                        var trackObjs = [];
                        if (this.map) {
                            trackObjs = this.map.querySourceFeatures({
                                layers: ['tracks']
                            });
                        }  // console.log("STOPPED track at cnt=" + this._counter + " with objs", trackObjs);
                    }

                    ctrlflag = "STOP";
                }

                this._trackctrl = ctrlflag; 

                console.log("ctrlAction: " + ctrlflag +", [", trackctrl+"]" ); 

                this.trackStepCtrl(ctrlflag);
                // ******************************
            },

            // Reassign animation data (w h y ) 
            animationReset: function(_counter) {

            },    	


            /**
             *   Swing-switch of map-orientation between north and track-aligned
             *   maporientation: true = aligned along bearing of trackObject
             */
            _mapAlignChange: function(mapalign, geojson) {
                if (!this.map || !geojson || !geojson.geometry) return;

                var minZoom = 4;
                var mm = {};
                mm.center = geojson.geometry.coordinates;
                mm.bearing = geojson.properties.bearing;
                if (!mm.bearing) return; // not given or = 0 

                this.trackctrl = false; // STOP animation

                if (mapalign) {
                    mm.align = true; 
                }   // console.log("_mapAlignChange", mm); 
                this.mapLocate(mm, minZoom);
            },

            // C. TrackStep-Animation 

            /**
             *  
             */
            trackStepCtrl: function(flag) {
                if (!mba) return;
                
                // 1. Remove OLD animationRef(s) (if existing)

                var rfr = mba._requestframeref;
                // console.log("CTRL " + flag, rfr, "timer=", mba.timer);
                if (rfr && rfr.length) {
                    rfr.forEach(function(r) {
                        cancelAnimationFrame(r);
                    })
                }

                if (flag == "STOP") {
                    return;
                }

                // 2. Start new animationFrame

                mba._requestframeref = [];
                // let timer = mba.timer;
                if (mba.timer.fps && (mba.timer.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                    setTimeout(function() {
                        mba._requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                    }, 1000 / mba.timer.fps);
                } else { // system-based Recall-frequency 
                    mba._requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                }

            },

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {
                
                function generateCtrlMsg(counter) {    
                    
                    var mapTime = (mba.timer["start"]) + (counter * mba.timer.frametime / 3600),
                        nextStartTime = mba.getNextStart(mapTime),
                        msg;

                    if (nextStartTime) {
                        var dt = nextStartTime - mapTime;
                        msg = "Continue at: " + mba.logTime(nextStartTime, "h", ".") 
                        + "<hr>Time left: " + mba.deltaT(dt, "");
                    } else {
                        msg = "IDLE: " + mba.logTime(mapTime, "h", "t");
                    }
                    mba.popupOnMap(msg);
                }

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.

                // ******************************
                var located = mba.trackStepAction(mba._counter);
                // ******************************

                // B. OPTION: Generate ctrlMsg

                if (!located) {
                    generateCtrlMsg(mba._counter);
                }

                // C. PREPARE request of next trackStepAction (animationFrame) 
                mba._counter = mba._counter + 1;

                // D. Animation RECALL 
                if (mba.trackctrl) { // was set in function 'trackStepCtrl'
                    mba.trackStepCtrl("CONT");
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function updates location and properties of trackThemes (trackPoints and/or trackTraces)
                // at animationstep 'counter'  
                //  - passed as parameter directly  or   
                //  - recalculated from 'mapTime' 
                var trackname = "tracks";
                // Themes to be updated during animation 
                var trackThemes = [trackname]; // ['tracks', 'traces']

                var timer = mba.timer,
                    model = mba.model,
                    modeldata = mba.model.data,
                    map = mba.map;

                // Search location of (animation-)counter 
                // on one of the routes legs                     	
                function getLegLocation (counter, route) { 
                    var legLocation; 

                    var geotype = route.geometry.type,
                        legCoordSet = route.geometry.coordinates;
                    if (geotype == "MultiLineString") { // multiple legs ?? 
                    } else { // one leg only 
                        legCoordSet = [legCoordSet];
                    }

                    // Iterate along the positions of the route-legs 
                    // until the track-counter is "located" within one of the legs. 
                    // Get coords and legInfo of the leg selected.

                    var routeProps = route.properties,
                        legdata = routeProps.legs,
                        legStartAt = routeProps.startCounter,
                        legStopAt, cc;

                    legCoordSet.every(function(legPositions, i) {
                        cc = null;
                        legStopAt = legStartAt + legPositions.length;
                        if (counter < legStopAt) {
                            cc = legPositions[counter - legStartAt];
                            if (cc) {
                                legLocation = {
                                    "leg": legdata[i],
                                    "coords": cc
                                };
                                return false;
                            }
                        }
                        // move to next leg
                        legStartAt = legStartAt + legPositions.length;
                        return true; // wichtig !!
                    });
                    return legLocation; 
                }

                // Map-Updates related to HILITED tracker
                function refreshTrackObject(trackObj, legLocation) {

                    var model = mba.model;

                    var coords = legLocation["coords"],
                        legInfo = legLocation["leg"];

                    var trackBearing = trackObj.properties.bearing;

                    if (mba.trackalignmap) {
                        // In track-align-map-orientation 
                        // The map is continuously 
                        //  - rotated to bearing 
                        //  - centered at trackObj 
                        // NO mapInfo is shown   
                        
                        console.log("Map-Bearing aligned to track:", trackBearing);

                        // Trigger CLOSE of trackInfo (fi. on map)
                        model.trackdata = {
                            "open": false
                        };

                        let map = mba.map;
                        map.easeTo({
                            center: coords,
                            bearing: trackBearing
                        });

                        map.setLayoutProperty(trackname+'-select', 'icon-rotate', 0);

                    } else {
                        // - REFRESH trackdata to trigger INFO-element(-popup) 
                        // - Align trackObj-symbol with track-bearing
                        model.trackdata = {
                            "id": model.trackid,
                            "lnglat": coords,
                            "trackobj": trackObj
                        }
                        if (map.getLayer(trackname+'-select')) { 
                            map.setLayoutProperty(trackname+'-select', 'icon-rotate', trackBearing);
                        }    
                    }

                    // optional specAction if selectedObj "arrived"  
                    if (trackObj.properties.arrived) {
                        // mba.trackalignmap = false;
                    }

                } 

                // Update routing-themes from new sources
                function refreshTrackedSrcData(themes, modeldata) {
                    if (typeof themes == 'string') themes = [themes];

                    var contentsrc, contentdata;
                    themes.forEach(function(theme){
                        contentsrc = map.getSource(theme);
                        contentdata = modeldata[theme];
                        if (contentsrc && contentdata.features.length) {
                            contentsrc.setData(contentdata);
                        }   
                    })
                } 

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

                // A.0 Sync alternative animation-time-sources 

                if (!counter) { 
                    if (mapTime) {
                        counter = (mapTime - timer["start"]) * 3600 / timer.frametime;
                        counter = Math.round(counter);
                    } else {
                        counter = 0;
                    }
                    // ??? WHY 
                    // if (counter == 0)  counter = 1;
                    mapMsg += "mapTIME"
                }

                if (counter && !mapTime) {
                    mapTime = (timer["start"]) + (counter * timer.frametime / 3600);
                }

                // A. Set GLOBAL animation ctrls 

                //                 
                mba._counter = counter;
                // Export Timesignal to trigger (sync) related gui-elements  
                mba.set('timer.time', mapTime);
                // ****************************

                // B. REFRESH the srcdata of animated objects (trackers and/or trackTraces) 
                //    whose start and stop surround actual mapTime  
                // ctrl-parameters 
                var located = [], // list of routes anumated during timeStep
                    mapMsg = "";  // flag that is set at "specific" animation-situations (start,stop, ...)

                var tracks = modeldata.tracks, // console.log("tracks", mapTime, tracks); 
                    routes = modeldata.routes,
                    traces = modeldata.traces;

                var nn = tracks.features.length; 

                for (j = 0; j < nn; j++) {
                    // Easyly find route and trace for trackObj 
                    // as routes, traces and track(Obj)s are equally indexed 
                    
                    var route = routes.features[j],
                        trackObj = tracks.features[j];
                        trackTrace = traces.features[j];

                    var routeProps = route.properties, 
                        routeid = routeProps.id,
                        routeStartCounter = routeProps.startCounter;

                    if (mapTime > routeProps.stop) {       // A. BREAK "what?" after end of this route 

                        if (routeStartCounter != null) {   // must be valid for 0 too
     
                            routeProps.startCounter = null; // 

                            mba.refreshTrace("STOP", trackTrace);

                            mapMsg += ",STOP: " + routeid;

                            // console.log("STOPPED tracking for", routeProps) ; 
                        }

                    } else if (mapTime >= routeProps.start) {  // B. Try to refresh the      

                        if (routeStartCounter == undefined) { // 
                            // FIRST access to this route during animation
                            routeStartCounter = Math.round((routeProps.start - (timer["start"])) / (timer.frametime / 3600));
                            routeProps.startCounter = routeStartCounter;
                            mapMsg += ",START: " + routeid;
                        }

                        // Find the legLocation of animation-counter 
                        var legLocation = getLegLocation(counter, route) ; 

                        // Update dynamic features according to its location on the route
                        if (legLocation) {

                            // A. Update list of actually animated routes   
                            located.push(route);
                            
                            // B. REFRESH DATA
                            var coords = legLocation["coords"];
                           
                            // B.1 Set new POSITION of trackObject 
                            trackObj.geometry.coordinates = coords; 
                            // B.2 EXTEND/MOVE the trackTrace 
                            mba.refreshTrace(coords, trackTrace);

                            // C. Option: HILITE/SYNC content (and location) of the info-popup 
                            //    if the trackObj of this route was selected as "selected-Object" 
                            
                            if (model.trackid == routeid) {

                                // Eval DynamicSTATUS (properties) of trackObj between 2 animation-points 
                                if (trackObj.properties.lastPos) { // not at first tp
                                    mba.getTrackStatus(trackObj, legLocation["leg"], mapTime);
                                }

                                refreshTrackObject(trackObj, legLocation) ; 

                            } else {
                            }

                            // D. MARK this location as "lastLocation" 
                            //    to compare with in next animationStep 
                            trackObj.properties.lastPos = legLocation['coords'];
                        }
                    }
                };
                
                // C. APPLY the updated sources of the animation-layers      
                //    if trackers on one or more routes were updated          
                if (located.length) {                    
                    refreshTrackedSrcData(trackThemes, modeldata);
                }

                // D. If flag "mapMsg" was created  
                if (mapMsg) { // console.log(mapMsg);
                    mba._animationMapRefresh(mapTime, mapMsg, timer.filter);
                } 
                return located;
            },

            // Calc status-parameters at mapTime and save as trackObj-properties
            getTrackStatus: function(trackObj, legInfo, mapTime) {

                var speedFlag = true;

                var routeunitsystem = trackObj.properties.unitsystem;
                // console.log("getTrackStatus with " + routeunitsystem + " unitsystem from ", legInfo, trackObj);

                trackObj.properties.time = this.logTime(mapTime, "h");

                var nowPos = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos;

                // calc the bearing between "actual" and 'last' Position of trackObj 
                var bearing = turf.bearing(new TrackSource(lastPos), trackObj);
                
                if (bearing < 0) bearing = bearing + 360;
                if (bearing > 360) bearing = bearing - 360;

                // Use temporary Leg to calculate DTA
                var legTarget = legInfo.to;
                var legToArrival = new LegSource([nowPos, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers"); // console.log("dta", dta); 

                var v = legInfo.speed,
                    dist = legInfo.dist,
                    speedUnit, distUnit ;

                // if (v && Math.round(dta / 10)) { 
                if (v && dta) { // TrackObj is "Moving" 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.tta = tta;
                    trackObj.properties.bearing = Math.round(bearing); // Â°
                    trackObj.properties.arrived = null;
                    trackObj.properties.ttt = null;

                    if (routeunitsystem == "nautic") {
                        speedUnit = "nds";
                        distUnit = "nm";

                        trackObj.properties.speed = Math.round(v / 1.856); // nds
                        trackObj.properties.dist = Math.round(dist / 1.856); // nm
                        trackObj.properties.dta = Math.round(dta / 1.856); // nm

                    } else if (routeunitsystem == "angloamerican") {
                        speedUnit = "mph";
                        distUnit = "mil";

                        trackObj.properties.speed = Math.round(v / 1.609); // mph
                        trackObj.properties.dist = Math.round(dist / 1.609); // miles
                        trackObj.properties.dta = Math.round(dta / 1.609); // miles

                    } else {
                        speedUnit = "kmh";
                        distUnit  = "km";

                        trackObj.properties.speed = Math.round(v); // km/h
                        trackObj.properties.dist = Math.round(dist); // km
                        trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    }

                    if (speedFlag) {
                        trackObj.properties.title = trackObj.properties.speed + speedUnit;
                        // console.log("speed=", trackObj.properties.title);
                    }

                } else { // Resting(pausing) objects 

                    if (!v) trackObj.properties.bearing = 0; // stÃ¶rend on track-animation
                    trackObj.properties.speed = 0;
                    trackObj.properties.dist = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;

                    if (legTarget.ab && (legTarget.ab != legTarget.an)) {

                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        trackObj.properties.arrived = "Stopover: " + stoptime;

                        let cntdwn = this.deltaT(legTarget.dep - mapTime, ":");
                        trackObj.properties.ttt = cntdwn;

                    } else {

                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },

            // Get the trace of a route at a mapTime
            // 
            refreshTrace: function(coords, trackTrace){
                return; // disabled!!
                var timer = this.timer,
                    routeid = trackTrace.properties.id,
                    tracelength = timer.tracelength,
                    mapTime = timer.time;
                // console.log(coords, trackTrace,timer);

                if (coords == "STOP") {
                    trackTrace.geometry.coordinates = traceCoords;
                    return;
                } 

                function trackStepTracer(coords, routeid) {
                    //console.log()
                    var startTime = timer.routes[routeid].start,
                        traceCounter = Math.round((timer.time - startTime) / (timer.frametime / 3600)),
                        first = 0,
                        last = traceCounter;

                    //  SPECIAL  
                    if (tracelength && (traceCounter > tracelength) ) {
                        first = traceCounter - tracelength;
                    }

                    var tracetemplate = timer.traces[routeid];
                    return tracetemplate.slice(first, last);
                }

                var traceCoords = trackStepTracer(coords, routeid);

                trackTrace.geometry.coordinates = traceCoords;

            },


            // D. SETUP elements ctrling and/or illustrating the tracking 

            // Initialisierung der animation-feature(collections)
            trackFeaturesReset: function(map) {
                // if (!mba || !mba.map) return;  
                var lnames = ["routes", "traces", "tracks", "nodes"];
                // console.log("trackFeaturesReset for objects:", lnames);
                lnames.forEach(function(lname) {
                    // console.log("RES:", lname);
                    if (map.getLayer(lname)) map.removeLayer(lname);
                    if (map.getLayer(lname + "-select")) map.removeLayer(lname + "-select");
                    if (map.getLayer(lname + "-glow")) map.removeLayer(lname + "-glow");
                    if (map.getLayer(lname + "-glow-strong")) map.removeLayer(lname + "-glow-strong");
                    if (map.getLayer(lname + "-bg")) map.removeLayer(lname + "-bg");

                    if (map.getSource(lname)) map.removeSource(lname);

                    this[lname] = {
                        "type": "FeatureCollection"
                    };
                }.bind(this));

            },

            /**
             * Setup "routes" optimized for animation with "requestAnimationFrame (60 fps)"
             * Optional + "traces" (= route-geometries "behind" the tracker ) 
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationRoutesSetup: function(routedataset, timer, metadataset) {
                // console.log("animationRoutesSetup, configdata:", routedataset, timer, metadataset);

                mba.model.data.routes.features = [];
                mba.model.data.traces.features = [];

                var routemetas = {};  // separate collection of all routes metadata


                // Preprocessing of tracks dependent on 
                //  - DOP of tracking device   
                //    ABANDON points closer as DOP  
                //  - animation timescale (alias frametime) 
                //    ABANDON wp, if smaller then timeframe 
                function rawTrackFilter(data, timer, metadataset) {

                    // guess measure for spatial accuracy of track-device
                    if (!metadataset)  metadataset = this.metadataset;   // console.log("_rawTrackFilter with metadataset",metadataset) ;
                    var dop = 10, 
                        device = metadataset.device;
                    if (device && device.dop) dop = device.dop;  

                    // Get frametime to use for  
                    if (!timer) timer = this.timer; 
                    var frametime = timer.frametime;

                    var trackpoints = [],
                        routeNodes = data.nodes, // waypoints/trackpoints 
                        legspeed, legTimeSec, wp, nextNode;
                    // console.log("original trackpoints", routeNodes);

                    var n1 = routeNodes.length, n2;

                    var p = 0;
                    while (p < routeNodes.length) {
                        wp = routeNodes[p];
                        i = 1;
                        while (i > 0) {

                            nextNode = routeNodes[p + i];
                            // Calculate leg-properties
                            if (nextNode) {
                                // console.log("routeNodes:" + p, wp, nextNode);
                                // A. Check 
                                if (nextNode.an && wp.ab) {
                                    let dep = mba.utcTime(wp.ab, "s", wp.coords),
                                        arv = mba.utcTime(nextNode.an, "s", nextNode.coords);
                                    legTimeSec = (arv - dep);
                                } else {
                                    legTimeSec = wp.stopover;
                                }

                                // CHECK time-diff between wps
                                // ABANDON wp, if smaller then timeframe 
                                if (legTimeSec > frametime / 2) {
                                    // B. Check DIST between routeNodes
                                    //    ABANDON wp, if smaller then dop
                                    var leg = new LegSource([wp.coords, nextNode.coords]),
                                        useNode = true;   

                                    if (typeof turf != "undefined") {
                                        legDistance = turf.lineDistance(leg, 'kilometers'),
                                        legDistMeters = Math.round(legDistance * 1000);
                                        useNode = (legDistMeters > dop); 
                                    }    

                                    if (useNode) {
                                        // Time and number of animation-steps to travel between routeNodes in legTimeSec
                                        // legTimeSec = legDistance / legSpeed * 3600;
                                        // legStepCount = Math.round(legTimeSec / frametime);
                                        // console.log("leg-data ", "dx=" + legDistance, "dt=" + legTimeSec, "steps=" + legStepCount); // , frametime);
                                        // return;

                                        p = p + i;
                                        trackpoints.push(wp)
                                        i = 0;

                                    } else {
                                        i = i + 1;
                                    }

                                } else {
                                    i = i + 1;
                                }

                            } else {
                                p = routeNodes.length;
                                i = 0;
                            }
                        }
                    }

                    if (nextNode) trackpoints.push(nextNode);
                    // console.log("checked trackpoints", trackpoints);

                    data.nodes = trackpoints;
                    n2 = trackpoints.length;
                    if (n2 != n1) {
                        // console.log("trackData filtered", n1, n2); // , metadataset.device); 
                    }
                    return data;
                }

                /** Basic routeCreate-action   
                 *  compile coords of all route-legs into one coordinatecollection 
                 */
                function animationRouteCreate(routedata, timer) {
                    // console.log("Initialize a routeContent from", routedata, timer);

                    var routeNodes = routedata.nodes; // wps as given
                    if (!routeNodes.length > 1)  return; // 

                    var frametime = timer.frametime;

                    var nextNode, legDistance, legStepCount;

                    var routeid = routedata.id,
                        legsData = [], // mean props of every leg    
                        legsCoords = [], // coords of every leg
                        legTimeSec, legStopSec, legSpeed, routespeed;

                    var props = {
                        "id": routeid,
                        "start": timer.routes[routeid]["start"],
                        "stop": timer.routes[routeid]["stop"]
                    };

                    if (routedata.speed) {
                        props.speed = routedata.speed;
                    }

                    // console.log("Initialize route from", data, timer, props);

                    var srcCollection = {};


                    // A. Create route-object consisting of 1-n legs

                    // Create route-legs between 2 waypoints at any one time 

                    routeNodes.forEach(function(wp, p) {

                        legStopSec = 0;
                        nextNode = routeNodes[p + 1];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("waypoints:" + p, wp, nextNode);
                            // Calculate the distance in kilometers between waypoints
                            var leg = new LegSource([wp.coords, nextNode.coords]),
                                legDistance = turf.lineDistance(leg, 'kilometers');
                                // legDistance = 0.1; 

                            // legDistance = Math.round(legDistance);

                            // Calculate a mean leg-speed between wp's with ab/an times
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, "h", wp.coords),
                                    arv = mba.utcTime(nextNode.an, "h", nextNode.coords);
                                legSpeed = legDistance / (arv - dep);
                                nextNode.arv = arv;
                            } else if (nextNode.speed) {
                                legSpeed = nextNode.speed;
                            }
                            // legSpeed = Math.round(legSpeed);
                            //console.log("leg-speed-calc", legDistance, legSpeed, nextNode, wp);

                            // Calculate arv and dep at "stopover"
                            if (nextNode.an && nextNode.ab) {
                                let arv = mba.utcTime(nextNode.an, "h", nextNode.coords),
                                    dep = mba.utcTime(nextNode.ab, "h", nextNode.coords);
                                legStopSec = (dep - arv) * 3600;
                                nextNode.arv = arv;
                                nextNode.dep = dep;
                            } else if (nextNode.stopover) {
                                legStopSec = nextNode.stopover;
                            }
                            // 3. Calc leg-animation 

                            // Time and number of animation-steps to travel between waypoints in legTimeSec
                            legTimeSec = legDistance / legSpeed * 3600;
                            legStepCount = Math.round(legTimeSec / frametime);

                            // console.log(p + ". leg-data for dx=" + legDistance, "n=" + legStepCount);

                            // Assign basic leg-properties
                            var legInfo = {};
                            legInfo.from = wp;
                            legInfo.to = nextNode;

                            legInfo.dist = legDistance;
                            legInfo.speed = legSpeed;

                            legInfo.time = legTimeSec;
                            legInfo.steps = legStepCount;

                            // Assign time-properties
                            var h = Math.floor(legTimeSec / 3600),
                                m = Math.round((legTimeSec - (h * 3600)) / 60);
                            legInfo.timetext = h + "h" + m + "min";

                            // Insert animation-positions along the leg
                            var startPosition = 0;
                            var legPositions = [];

                            for (let i = 0; i < legStepCount; i++) {
                                let dist = i * (legDistance / legStepCount);
                                let position = turf.along(leg, dist, 'kilometers');
                                let pos = position.geometry.coordinates; 
                                // let pos = [1,2]; 
                                legPositions.push(pos);
                            }

                            // 4. Append "STOPOVER-animation" 
                            //    into 
                            if (legStopSec) { // INSERT some "zero-steps" at stopover waypoint 
                                // console.log("INSERT STOPover at ", nextNode, legStopSec);
                                h = Math.floor(legStopSec / 3600);
                                m = Math.round((legStopSec - (h * 3600)) / 60);
                                legInfo.stopTime = h + "h" + m + "min";
                                var n = Math.round(legStopSec / frametime);
                                legInfo.stopSteps = n;
                                // append the "stop-coordinates" to the leg 
                                for (let i = 0; i < n; i++) {
                                    legPositions.push(legPositions[legPositions.length - 1]);
                                }
                            }

                            // 4. Compile leg-data in route-collections of legs  
                            // console.log("leg-data ", legInfo, legPositions);
                            legsData.push(legInfo);
                            legsCoords.push(legPositions);
                        }
                    }.bind(this));

                    srcCollection["routeSrc"] = new RouteSource(routeid, props, legsCoords, legsData, routeNodes);

                    // B. Save a template for dynamic traces 
                    //  - the complete trace of a route as
                    //  - the first node 
                    //  - an empty trace

                    //if (timer.tracelength == undefined) timer.tracelength = 10 ;
                    //if (timer.tracelength) {

                    var traceCoords = [];
                    // collect coordinates of complete route
                    legsCoords.forEach(function(legcoords) {
                        traceCoords = traceCoords.concat(legcoords);
                    });
                    // Optional: Create "initial" trace-object with startpoint only
                    // if (traceCoords.length > 2) traceCoords = traceCoords.slice(0, 2);

                    timer.traces[routeid] = traceCoords; // .length;

                    srcCollection["traceSrc"] = new TraceSource(traceCoords, routeid);
                    //}

                    // console.log("New routeSrces: " + routeid, srcCollection);
                    return srcCollection;
                }; 

                function setupRouteStyling(routemetas) {

                    // Unique color 
                    var linecolorProp = "#007cbf";

                    // Option: Prepare differentiated linecolor-styling for every route
                    // as mb-lookup on "id" with "stops"-table  
                    var metakeys = Object.keys(routemetas);
                    if (metakeys.length) {
                        // optional: ddr-styling based on routeid
                        var ddrLinecolors = {
                            property: 'id',
                            type: 'categorical',
                            stops: []
                        };

                        metakeys.forEach(function(id) {
                            var col = routemetas[id].color;
                            if (!col) col = linecolorProp;
                            if (!col) col = this.getRandomColor();
                            ddrLinecolors.stops.push([id, col]);
                        }.bind(this));

                        linecolorProp = ddrLinecolors;
                    }

                    var routePaintProps = {
                        "line-color": linecolorProp
                    };  // console.log("routePaintProps", routePaintProps); 
                    
                    return { "paints": routePaintProps} ; 
                }
                
                // A. Interpolate the Routes between trackpoints (waypoints of the track) 
                //    based on info about speed and/or arrival-/departure-times at waypoints
                var nn = routedataset.length,
                    rr, r, t, m,
                    modelroutes = mba.model.data.routes,
                    modeltraces = mba.model.data.traces;

                routedataset.forEach(function(routedata, j) {
                    
                    // A.1 track-based routes should be filtered to remove some "gps-noise" 
                    if (routedata.trackmode) {
                        metadata = this.metadataset;
                        routedata = rawTrackFilter(routedata, timer, metadata);
                    } // console.log(j, routedata);  

                    if (routedata.nodes && (routedata.nodes.length > 1)) { // minimum 2 points required 
                        
                        // A.2 Create srcObjects 
                        rr = animationRouteCreate(routedata, timer);
                        // **********************

                        // A.3  Include srcObjects into api-Context
                        if (rr) { // console.log("setupAnimationRoute:" + j, rr);
                            
                            // A. ROUTE
                            r = rr.routeSrc;

                            if (!routedata.meta) routedata.meta = {};
                            if (!routedata.meta.color) routedata.meta.color = this.getRandomColor();
                            r.properties = Object.assign({}, r.properties, routedata.meta);

                            routemetas[r.id] = routedata.meta;

                            modelroutes.features.push(r);
                            // **************************

                            // B. TRACE, if prepared, add trace-features (with same properties as routes) 
                            t = rr.traceSrc;
                            
                            if (t) {
                                t.properties = r.properties;
                                modeltraces.features.push(t);
                                //*********************
                            }
                        }
                    }

                }.bind(this));
                // console.log("Srces:", this.routes.features, this.traces.features);
                // return;

                // B. Setup (differentiated) STYLING of routes (and traces) 

                var routeStyling = setupRouteStyling(routemetas); 

                // C. FINAL mb-Objects

                var routesContent = this._animationContentSetup("routes", "line", modelroutes, routemetas, routeStyling);
                var tracesContent = this._animationContentSetup("traces", "line", modeltraces, routemetas, routeStyling);

                // console.log("Content:", routesContent, tracesContent);

                return {
                    "routes": routesContent,
                    "traces": tracesContent
                };
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationNodesSetup: function(routedata) {
                // console.log("setupAnimationNodes. srcdata:", routedata);
                
                mba.model.data.nodes.features = [];
                
                var nodemetas = {};

                function setupBgLayer(nodemetas) {
                    // Prepare ddr-styling (circle-size of symbol-bg)
                    // fi. to visualize size of airport-nodes 

                    var nodesize = 2,
                        size, smin, smax;

                    Object.keys(nodemetas).forEach(function(id) {
                        size = nodemetas[id].size;
                        if (size) {
                            if (!smin || (size < smin)) smin = size;
                            if (!smax || (size > smax)) smax = size;
                        }
                    })

                    if (smin && smax && (smin < smax)) {
                        nodesize = {
                            property: 'size',
                            stops: [
                                [smin, 4],
                                [smax, 12]
                            ]
                        }
                    }

                    var bglayer = {
                        "id": "nodes-bg",
                        "type": "circle",
                        "source": "nodes",
                        "paint": {
                            "circle-radius": nodesize,
                            "circle-opacity": 0.5,
                            "circle-color": "red"
                        }
                    };

                    return bglayer; 
                }

                // A. Collect nodes into features
                var modelnodes = mba.model.data.nodes,
                    id;

                routedata.forEach(function(route, j) {
                    // locate trackObj at 'origin'
                    if (route.nodes && (route.nodes.length>1)) {
                        // console.log("route-" + j, route.nodes);
                        route.nodes.forEach(function(wp, p) {
                            var key,
                                coords,
                                newNode,
                                props = {},
                                meta = wp.meta;

                            if (wp.id) key = wp.id;
                            else if (meta && meta.id) key = meta.id;
                            else key = p;

                            allnodes.features.forEach(function(nod) {
                                // do NOT add nodes multiple times (fi airports of different flights)
                                if ((key != p) && (nod.id == key)) {
                                    // console.log("doubling routenode", key, route.id);
                                    newNode = nod;
                                }
                            });

                            if (!newNode) {
                                if (wp.coords) coords = wp.coords;
                                else if (meta.coords) coords = meta.coords;
                                else key = p;

                                Object.keys(wp).forEach(function(k) {
                                    if (k != "coords") props[k] = wp[k];
                                });

                                // console.log("wp-" + p, key, wp, props);
                                newNode = new NodeSource(coords, key, route.id, props);
                                if (wp.meta) {
                                    newNode.properties = Object.assign({}, newNode.properties, wp.meta);
                                    nodemetas[key] = wp.meta;
                                }

                                allnodes.features.push(newNode);
                            }
                        });
                    }
                });
                // console.log("all waypoints collected", allwaypoints.features);

                // B. Create object 
                var mapObjNodes = this._animationContentSetup("nodes", "symbol", modelnodes, nodemetas);

                // C. additional layer as node-background to the same src
                // mapObjNodes['bglayer'] = setupBgLayer(nodemetas) ;

                //console.log("nodeLayer", nodeLayer);
                return mapObjNodes;
            },

            /**
             * create the contentBoxObj for trackLayer
             *
             * @param      {object}  routedata     The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationTrackerSetup: function(routedataset, timer, metadataset) {
                // console.log("routedata at setupAnimationTracker", routedata);
                // the trackLayerObj contains the data, the styling of the baseLayer AND the styling for the selectLayer
                if (!timer) timer = this.timer;
                if (!metadataset) metadataset = this.metadataset; // console.log("animationTrackerSetup metadata", metadataset); // metadata of primary datasrc 
                
                function guessRouteMeta(routedata) {
                    // HEURISTIC to alternatively(?) query from different properties 
                    var routeMeta = routedata.item; // 
                    if (!routeMeta) routeMeta = routedata.meta;
                    if (!routeMeta) routeMeta = routedata.master;
                    if (!routeMeta) routeMeta = {};

                    if (!routeMeta["id"]) routeMeta["id"] = routeid;
                    return routeMeta;
                }

                function guessTrackStyle(routemetas) {
                    // includes options for 
                    //  - different icon(color) per tracker 
                    //  - data-driven rotation of the icon

                    var trackStyle = {}, 
                        type, layouts, paints;
                    const metas = Object.keys(routemetas).map(key => routemetas[key]);  // JS2015
                   
                    const hasIcon = metas && metas[0] && metas[0].icon; 
                    
                    if (hasIcon) { //  EITHER: Symbol 
                        // - with rotating-property 
                        // - NOT be sized or colored byNow (17.02.17)  

                        trackStyle.type = "symbol";

                        // ddr styling enables  
                        // A. in Quick-Mode: variable Icon and text 
                        // ---

                        // B. in LUT-Mode: symbol-rotation according to bearing 
                        // var symbolrotation = 0;
                        var symbolrotation = {
                            property: 'bearing',
                            stops: [
                                [0, 0],
                                [360, 360]
                            ]
                        };

                        trackStyle.layouts = {
                            "icon-image": "{icon}",
                            "icon-rotate": symbolrotation,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        };

                    } else { // OR : ColorableCircle-Layer 

                        trackStyle.type = "circle";

                        // ddr styling enables different colors for every tracker
                        var symbolcolor = "red";
                        
                        if (routemetas && Object.keys(routemetas).length) {
                            var ddrSymbolcolor = {
                                property: 'id',
                                type: 'categorical',
                                stops: []
                            };

                            Object.keys(routemetas).forEach(function(id) {
                                var col = routemetas[id].color;
                                // if (!col) col = symbolcolor;
                                if (!col) col = this.getRandomColor();
                                ddrSymbolcolor.stops.push([id, col]);
                            }.bind(this))

                            if (ddrSymbolcolor.stops.length) {
                                symbolcolor = ddrSymbolcolor;
                            }
                        } 

                        trackStyle.paints = {
                            'circle-radius': 6,
                            'circle-stroke-width': 2,
                            'circle-stroke-color': "#000",
                            'circle-color': symbolcolor
                        }; // console.log("trackStyle", trackStyle); 
                    }

                    // console.log("guessTrackStyle", trackStyle, "from", routemetas); 
                    return trackStyle; 
                }

                function setupSelectLayer(metadataset) {
                    // A meaningful TrackPoint-presentation built from 3 symbol(Layer)s 
                    var selectsymbol = "airport-15";
                    if (metadataset.symbol) selectsymbol = metadataset.symbol; 

                    var selectLayer =  [
                        {
                            "id": "tracks-glow-strong",
                            "type": "circle",
                            "source": "tracks",
                            "paint": {
                                "circle-radius": 18,
                                "circle-color": "#ff0",
                                "circle-opacity": 0.6
                            }
                        }, 
                        
                        {
                            "id": "tracks-glow",
                            "type": "circle",
                            "source": "tracks",
                            "paint": {
                                "circle-radius": 40,
                                "circle-color": "#ff0",
                                "circle-opacity": 0.2
                            }
                        }, 
                        
                        {
                            "id": "tracks-select",
                            "type": "symbol",
                            "source": "tracks",
                            "layout": {
                                "icon-image": selectsymbol,
                                "icon-rotate": 0,
                                "text-field": "{title}",
                                "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                "text-size": 12,
                                "text-offset": [0, 0.6],
                                "text-anchor": "top"
                            }
                        }
                    ];
                    return selectLayer; 
                }  
                
                // A. setup data 
                mba.model.data.tracks.features = [];
                
                var routemetas = {};

                var modeltracks = mba.model.data.tracks,
                    // modeltracks.features = [],
                    routedata, routeid, startort, trackmeta,
                    nn = routedataset.length;

                for (var j = 0; j < nn; j++) {

                    routedata = routedataset[j];  
                    routeid = routedata.id; // console.log(routeid, routedata);

                    if (routedata.nodes && (routedata.nodes.length > 1)) {
                        
                        trackmeta = guessRouteMeta(routedata);
                        routemetas[routeid] = trackmeta;  
                        // console.log(route,trackmeta);

                        var props = {
                            "routeid": routeid,
                            "id": trackmeta.id,
                            "title": trackmeta.id,
                            "unitsystem": routedata.unitsystem,
                            "bearing": 0,
                            "start": timer.routes[routeid]["start"],
                            "stop": timer.routes[routeid]["stop"]
                        };

                        // Optional: master-data-properties
                        props["master"] = trackmeta;

                        // Required : icon; 
                        if (trackmeta.icon) props.icon = trackmeta.icon;

                        // Optional: 
                        if (trackmeta.iconsize) props.iconsize = trackmeta.iconsize;

                        // Create Tracker located at route-start 
                        startort = routedata.nodes[0].coords;

                        var aTrack = new TrackSource(startort, routeid, props);
                        
                        modeltracks.features.push(aTrack);

                    } else {
                        // console.log("ALERT.", "No nodes in routedata" + routeid, routedata.nodes ) 
                    }

                };  

                // B. Setup ONE Layer for multiple trackers (DynamicPoints)
                
                // guess from last track-props used to build a Track
                var mbStyle = guessTrackStyle(routemetas); // , routedataset);

                var trackLayerObj = this._animationContentSetup("tracks", mbStyle.type, modeltracks, routemetas, mbStyle); // paints, layouts);
                // console.log("trackLayerObj", trackLayerObj);

                // C. ADD SPECIFIC "multiSymbol" presentation 
                // of one!! "observed" trackObj (app-specific)

                trackLayerObj['selectlayer'] = setupSelectLayer(metadataset);

                // console.log("trackLayerObj", trackLayerObj);
                
                return trackLayerObj;
            },

            // E. Additional Function(s) to ctrl SELECT-Track-symbol 
            // - SHOW for feature with id=[idvalue]
            // - HIDE (idvalue="")
            _trackFilterApply: function(idvalue) {
                if (typeof idvalue == "undefined") return; 
                if (!map) return;  // if (!mba.map) return; 

                var trackLayers = ["tracks-select", "tracks-glow", "tracks-glow-strong"];
                trackLayers.forEach(function(lname) {
                    if (map.getLayer(lname)) { 
                        //console.log("_trackFilterApply ["+idvalue+"] to layer", lname);  
                        map.setFilter(lname, ["==", "id", idvalue]);
                    }
                });
            },

            // SYNC mapcontent (visibility of TrackObjects and "related" map-layers) 
            //   - primarely at "mapTime" (FIRST) 
            //   - or for (combined with) "routeFilter" (SECOND) 
            _animationMapRefresh: function(mapTime, syncflag, routeFilter) {
                
                var stopDelay = 2000, // time to let last situation "visible" before reset 
                    trackname = "tracks",
                    tracklayer = map.getLayer(trackname), 
                    scope = this; 
                if (!tracklayer) {
                    console.log("REFRESH _animationMap BREAK", mapTime, syncflag, routeFilter); 
                    return;
                } 
                console.log("REFRESH _animationMap", mapTime, syncflag, routeFilter);

                // 
                function checkNextRoutes (mapTime, routeFilter) {
                    //  STOP animation, if no further track-Start is pendig 
                    var nextTime = mba.getNextStart(mapTime);
                    if (nextTime) return nextTime; 

                    var trackContent = mba._animationbox[trackname]; 

                    mba.trackctrl = false;

                    mba.trackalignmap = false;
                    // trackFilter = null; 

                    // SHOW ALL trackObjects 
                    if (trackContent) {  // console.log("trackContent",trackContent);
                        trackObjs = mba._contentGetSrcFeatures(trackContent, {
                            filter: null
                        });
                    } else {  //  (? present at actual mapextent ?) 
                        trackObjs = mba.map.querySourceFeatures(trackname, {
                            filter: null
                        });
                    } 

                    var msgTime = mba.logTime(mapTime, "h"),
                        msg = "STOPPED. No data after: " + msgTime; // console.log(msg, trackObjs);
                    mba.popupOnMap(msg);
                }

                // TIME filter: applied, on every maptime ??
                function applyTrackFilter(mapTime, routeFilter, flag) {
                    if (!flag) flag = "noflag";
                    // if (!routeFilter) routeFilter = mba.timer.filter;
                    
                    var routeids = [],
                        routeid,
                        trackFilter,
                        msg;

                    // A. Apply TIME-FILTER on "ALL" trackObjects 
                    //    with start- and stop-properties  
                    //    (is applied on sourcedata)
                    if (mapTime) {
                        trackFilter = [
                            'all', ['>=', 'start', mapTime],
                            ['<=', 'stop', mapTime]
                        ];
                        if (routeFilter) {
                            trackFilter.push(routeFilter); 
                        }    

                    } else if (routeFilter) {

                        trackFilter = routeFilter

                    } else {
                        trackFilter = null;
                    }

                    // Refresh tracks on map
                    var trackObjs = [];
                   
                    if (tracklayer) {

                        trackContent = mba._animationbox[trackname]; 

                        // A.2 Query the trackObj - src-Features 
                        if (trackContent) {  // console.log("trackContent",trackContent);
                            trackObjs = mba._contentGetSrcFeatures(trackContent, {
                                filter: trackFilter
                            });
                        
                        } else {  //  (? present at actual mapextent ?) 
                            trackObjs = this.map.querySourceFeatures(trackname, {
                                filter: trackFilter
                            });
                        } 
                        // console.log("trackObjs at time="+mapTime, trackFilter, trackObjs, trackContent); 
                    }

                    if (mapTime && !trackObjs.length) {

                        scope.trackctrl = false; 

                        var nextTime = checkNextRoutes(mapTime, routeFilter); 

                        if (!nextTime)  return; // !!!!!  

                        msg =" NEXT track starts at: <br>" + mba.logTime(nextTime, "h", ".");

                    } 

                    // B.2 Some trackObjs animated at filter-time  
                    if (flag.indexOf('TIME') >= 0) {
                        // console.log("trackObjs filtered at ", msgTime, trackObjs, startStopFilter);
                    }

                    // C. Get route-ids of active trackers
                    //    to prepare a "SECONDARY FILTER"" 
                    //    to Sync the filters for "related" layers (traces, routes, waypoints)  

                    // collect ROUTES of all actually "active" trackObjs    
                    if (trackObjs.length) {
                        // console.log("Active track(s): Layer, Filter, objs", trackLayer, trackFilter, trackObjs);

                        // A. Filter the visibility of tracks-theme-elements
                        mba.map.setFilter(trackname, trackFilter);

                        // B. Prepare the 
                        trackObjs.forEach(function(to) {
                            routeid = to.properties.routeid;
                            if (routeid) routeids.push(routeid);
                        });

                        // remove possible "DUPLICATES" ? 
                        routeids = routeids.filter(function(item, pos, self) {
                            return self.indexOf(item) == pos;
                        })
        
                        var info = flag.substring(0, 15) + "...";

                        msg = "<b>" + info + "</b>" + "<br>Active track(s): " + routeids.length ;
                    }

                    if (mapTime) {
                        msg = "TrackingMSG at: " + mba.logTime(mapTime, "h", ".")+ "<hr>" + msg;
                    }
   
                    mba.popupOnMap(msg);

                    return routeids;
                };

                // 1. Optional BREAK! 
                //    SYNC trackObjects (and it's routes) 
                //    only as long as they are "tracked on map" 
                // if ((!mba.map || !mba.map.getLayer("tracks")) && mapTime) {
                if (!tracklayer && mapTime) {
                    var syncTime = this.logTime(mapTime, "h"); // , "t"),
                        msg = "<b>No trackers on map to track</b>" + " at " + syncTime;
                    if (mba.map) mba.popupOnMap(msg);
                    else console.log("ALERT", msg); 
                    return;
                }
                // 3. Filter for mapTime&&routeFilter (not for flag STOP) 
                
                var trackids = applyTrackFilter(mapTime, routeFilter, syncflag);
                //console.log("REFRESH: ids of trackFeatures", trackids, routeFilter);

                // 4. 
                var timerFilter = mba._timerFilterCreate(trackids);
                //console.log("timerFilter of", trackids, timerFilter);

                var srcFeatures = mba._timerFilterSync(timerFilter); // ,trackids);
                // console.log("REFRESH: srcFeatures with", routeFilter, srcFeatures);

                // 2. Additional "HIDE"-Filters after STOP-action
                if (syncflag && syncflag.indexOf("STOP") >= 0) {
                    // Apply "stopfilter" after some "stopDelay" only
                    // to let user observe arrived tracker during this delay before removing the tracker and related features 
                    // console.log("Should STOP after stopDelay", stopDelay, "[ms]"); 
                    setTimeout(function() {
                        // console.log("Clear TrackObj decoration!", syncflag, mapTime); //  after stopDelay  
                        mba._trackFilterApply("");
                    }, stopDelay);
                } 

                return srcFeatures;
            },

            // Create an idFilter for idname (routeid) with 'routeids'
            _timerFilterCreate: function(routeids, idfldname) {
                if (!idfldname) idfldname = "routeid";

                var idFilter = ["==", idfldname];

                if (typeof routeids == "string") { // select one or none ("") 

                    if (routeids == "none") {   // EMPTY filter 
                        idFilter.push("");

                    } else if (routeids == "all") {  // FULL filter
                        idFilter = null;

                    } else { // SINGLE filter

                        idFilter.push(routeids);
                    }

                } else if (!routeids || !routeids.length) { // FULL filter
                    //syncFilter = null; //n = "all";
                    idFilter.push("");

                } else {   // MULTIPLE filter 
                    idFilter = ["in", idfldname];
                    routeids.forEach(function(id) {
                        idFilter.push(id);
                    });
                    // syncFilter = syncFilter.concat(routeids);
                }

                return idFilter;
            },

            // SYNC animationLayers "related" with tracker of active route
            _timerFilterSync: function(syncFilter) { // , boxflag) {
                // Filter  mapFeatures "related"  to animating trackers (identified by routeid-property) 
                // or none 
                // or all 

                // 1. Generate "syncfilter" 
                var modeldata = mba.model.data,
                    srcNames = Object.keys(modeldata);
                    // srcNames = ["tracks", "traces", "routes", "nodes"],
                    srcFeatures = {},
                    msg = 0;
                // console.log("_timerFilterSync", syncFilter, srcNames);

                if (!syncFilter) { // select one or none ("") 
                    msg = "all";
                } else {
                    msg = "???"
                }

                // 2. Get (?src-)features of "visible" animationThemes 
                //    related to syncFilter 

                srcNames.forEach(function(sname) {
                    var src = map.getSource(sname);
                    // console.log("srcname:"+sname, "src", src);
                    if (src) {
                        var features = mba.map.querySourceFeatures(sname, {
                            filter: syncFilter
                        }); 
                        if (features.length) { // console.log(sname, syncFilter, features);
                            srcFeatures[sname] = features;
                        }    
                    }
                });


                // 3. Update the "related" mapLayers

                var srcKeys = Object.keys(srcFeatures);
                
                if (srcKeys.length) {
                    // console.log("_timerFilterSync with ["+syncFilter+"]", srcFeatures); 
                    srcNames.forEach(function(sname) {
                        if (mba.map.getLayer(sname)) {
                            mba.map.setFilter(sname, syncFilter);
                            // Special case airport-nodes
                            if (sname == "nodes") {
                                mba.map.setFilter(sname + '-bg', syncFilter);
                            }
                        }
                    })
                } 
                return srcFeatures;
            },

            // Zoom to bbox of all raw route-nodes (waypoints, trackpoints) 
            // fitting the 
            trackRoutesZoomTo: function(routeFeatures, routeid, filter, msg) {
                // console.log("trackRoutesZoomTo. DEBUG", routeFeatures, routeid, filter, msg); 

                if (!msg) msg = "ZOOMTO Route-Feature(s)";
               
                var zoomFilter = null, routeContent, layerid; 

                if (!routeFeatures) {

                    // option: extract routeid from 'filter'-parameter
                    if (filter && !routeid) {
                        zoomFilter = filter;
                    } else if (routeid) {
                        // zoomFilter = ["in", "routeid", routeid];
                        zoomFilter = ["in", "id", routeid];
                    } else {
                        zoomFilter = [];
                    }

                    // A. Select a route from "Rawfeatures"
                    // SPECIAL
                    if (zoomFilter) {
                        routeContent = this._animationbox.routes,
                        routeFeatures = this.filterContentSources(routeContent, zoomFilter);
                        // routeFeatures = this._trackRouteGetSrcFeatures(routeid, contentlayer);
                    }   // console.log("ZWI of "+ routeid, bboxFilter, routeFeatures);
                }

                if (!routeFeatures || !routeFeatures.length) {
                    console.log(msg);
                    console.log("BREAK. No routefeatures available to ZOOM! // filter=", zoomFilter);
                    return;
                }   
               
                var ffbounds = mba.setFeatureBounds(routeFeatures);

                // console.log(msg, ffbounds); // , routeFeatures, routeid, filter ); // .getCoordinates());
            },

            /*
             *  ??? 
            _trackRouteGetSrcFeatures: function(routeid) {
                var routesrc = this._animationbox.routes.srcdata,
                    rrall = [];
                if (typeof routesrc == "string") {
                    var routesrcdata = mba.map.getSource(routesrc); console.log("routesrc:", routesrc, routesrcdata);
                    if (routesrcdata) rrall = routesrcdata.features;  
                } else {
                    rrall = routesrc.features;
                }
                if (!routeid || !rrall.length) {
                    console.log("NO Features queried for id=" + routeid);
                    return rrall;
                }   // console.log("routeSrces for [" +routeid+ "] from '_animationbox'", this._animationbox.routes, rrall); 

                var rr = [];
                rrall.forEach(function(r) {
                    if (r.id == routeid) {
                        rr.push(r);
                    }
                });
                // console.log("_trackRouteGetSrcFeatures. queried raw routeData for id=" + routeid, rr);
                return rr;
            },
            */

            // Generic function to filter on contentSrcFeatures
            _contentGetSrcFeatures: function(boxcontent, query) {
                // console.log("GetSrcFeatures for ", boxcontent, query);  

                var contentsrc = boxcontent.srcdata,
                    ffall = contentsrc.features;
                // console.log("_contentGetSrcFeatures - 0", boxcontent, query, ffall); 

                if (!query || !query.filter) {
                    // as well if no filter or filter = null;
                    return ffall;     
                }

                var filter = query.filter,
                    filter0 = filter[0],
                    logic, 
                    qq = [];

                if ( filter0 == "all") { // AND 
                    qq = filter.slice(1); 
                    logic = "and"
                
                } else if (filter0 == "in")  { // OR 
                    qq = [filter];   
                    logic = "or"
                
                } else {    
                    qq = [filter]; 
                }
                // console.log("_contentGetSrcFeatures - 1", filter, qq); // , logic);

                var ff = [];

                // SIMULATES MB-filtering on src-data
                // running all filter conditions ob every feature
                ffall.forEach(function(f) {

                    var expr, op, prop, value, test, isin, 
                        found = true,
                        props = f.properties;

                    qq.forEach(function(q){
                        op = q[0]; 
                        value = props[q[1]]; 
                        test = q[2]; 
                        // console.log("q-parts:",test,op,value);

                        if (op == "in") {  // Specialca
                            isin = (test.indexOf(value) >= 0);
                            found = found && isin; 
                            // console.log("IN", isin, found, test, value);
                        } else {
                            if (typeof value == "string") {
                                value = JSON.stringify(value);
                                test = JSON.stringify(test);
                            } 
                            expr = test + " "+op+" " + value;   // console.log("EXPR:",expr);
                            found = eval(expr) ? (found && true) : false;  // console.log(found, q); 
                            // found = expr ? (found && true) : false;  console.log(found, q, expr); 
                        }
                    });  // console.log("filtered", found, qq, props); 

                    if (found) {
                        ff.push(f);
                    }    
                });
                // console.log("_contentGetSrcFeatures. filtered rawRoute for q=", query, ff.length);
                return ff;
            },


            // Check if more starts  
            // (??? or before end of animated routeSet (timer.stop)???)
            getNextStart: function(mapTime) {
                var starts = mba.timer.starts,
                    stops = mba.timer.stops,
                    nextStart,
                    lastStop = stops[stops.length - 1];
                // lastStop = mba.timer.stop; 
                if (!starts) return;
                starts.some(function(start) {
                    if (mapTime <= start) {
                        nextStart = start;
                        return true;
                    }
                }); // console.log("getNextStart at t=", mapTime, "nextStart=", nextStart, mba.timer, lastStop);
                if (nextStart && (nextStart < lastStop)) { 
                    return nextStart;
                }
            },

            // updates "popupOnMap" if a trackinfo-property changes
            trackInfoPopup: function(trackinfo) {
                // console.log("LOG", trackinfo.value, trackinfo);
                if (!trackinfo.value) return;

                // trackinfo = trackinfo.value;
                this.popupOnMap(trackinfo.value);
            },


            /**
             * Activate a trackObject driven by mouse-event ;
             * (move-over, click, ...) 
             * with activity on background to enhance usability 
             */
            trackObjSelect: function(e, clickevent) {
                
                var features = [],
                    model = mba.model;
                var trackLayers = ["tracks", "tracks-select", "tracks-glow", "tracks-glow-strong"];

                if (map.getLayer('tracks') || map.getLayer('tracks-select')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: trackLayers 
                    });
                }

                // Try nodes if no tracks selected
                if (!features.length) {
                    // Check waypoints/trackpoints    
                    if (map.getLayer('nodes')) {
                        features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes']
                        });
                    }
                    if (!features.length) return;

                    // popup-strategy 1: 
                    // Remove popup if pointer not on any feature
                    this.popupOnMap();

                    let wp = features[0];
                    if (this.wpid != wp.properties.id) {
                        this.wpid = wp.properties.id;
                        var msg = "WP/TP " + wp.properties.ab;
                        this.popupOnMap(msg); // console.log(msg, wp);
                    }
                    return;
                }
                // console.log("evented "+features[0].properties.id, features);
                
                if (model.trackid == features[0].properties.id) {

                    // toggle popup with click 
                    if (clickevent) {
                        // console.log("CLEAR trackObj", model.trackid, features[0]);
                        mba.popupOnMap()
                        mba._trackFilterApply("");
                        model.trackobj = null;
                        model.trackid = null;
                    }
                    // NO further info-popup on "mouseover"
                    return;
                }

                // 
                this.trackObjDecorate(features[0]); 
            },    

            // Show global mapPopup 
            trackObjDecorate: function(feature) {
                // Update GLOBAL objects
                var model = mba.model;
                model.trackobj = feature;
                model.trackid = feature.properties.id;

                // temporary debug function 
                function toHtml(obj, title) {
                    var val, html = "" ; 
                    if (title) html = "<h3>"+title+"</h3>";
                    Object.keys(obj).forEach(function(key){
                        if (typeof obj[key] != "object") {
                            html = html + key + " : " + obj[key] + "</br>";
                        }  
                    })
                    return html;
                }

                // popup-strategy 2: 
                // Update and reconnect the this.popup to the map at new object
                // Trackdata with "Override dirty checking" 
                // if (model.trackobj) {
                if (model.trackid) {
                    // console.log("TRACKOBJ DECORATE: " + model.trackid, model.trackobj);

                    mba._trackFilterApply(model.trackid);

                    model.trackdata = {
                        "lnglat": model.trackobj.geometry.coordinates,
                        "trackobj": model.trackobj,
                        "open": true
                    }
                    var html = toHtml(model.trackobj.properties, model.trackid);
                    mba.popupOnMap(html);

                } else {

                    mba.popupOnMap();
                }


            },

            /*
             *   get wp-(tp-) info on CLICK-query
             */
            routeNodeSelect: function(e) {
                // Check waypoints(trackpoints)    
                var features = [];
                if (map.getLayer('nodes')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['nodes']
                    });
                }
                if (!features.length) return;
                // popup-strategy 1: 
                // Remove popup if pointer not on any feature
                let wp = features[0];
                if (this.wpid != wp.properties.id) {
                    this.wpid = wp.properties.id;
                    var msg = "WP/TP " + wp.properties.ab;
                    this.popupOnMap(msg); // console.log(msg, wp);
                } else {
                    this.popupOnMap();
                }
                return;
            },

            // DEBUG-utilities

            _checkObject: function(obj) {
                // console.log("CHECK", obj);
            },
            
            _checkTimer: function(timer) {
                // console.log("CHECK animationTIMER", timer.value);
            },
            _checkTrackdata: function(data) {
                //console.log("CHECK TRACKdata", data);
            },
            _checkTrackinfo: function(trackinfo) {
                // console.log("CHECK TRACKinfo", trackinfo);
            }
        });
    </script>

</dom-module>