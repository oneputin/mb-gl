<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="mb-api.html">

<link rel="import" href="routing-classes.html">

<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="routing-behavior.html">

<!--<link rel="import" href="mb-behavior-info-vendee.html">-->

<!--
`routing-api`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="routing-api">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        Polymer({
            is: 'routing-api',

            properties: {
                /**
                 * Mapbox-js map to place routing elements 
                 */
                map: {
                    type: Object
                },

                /**
                 * Container with metadata of primary dataset 
                 */
                metadataset: {
                    type: Object,
                    // observer: '_checkObject'
                },

                /**
                 * Container for animation-data
                 */
                contentbox: {
                    type: Object,
                    notify: true
                    // observer: '_checkObject'
                },

                /**
                 * Container for animation-ctrls
                 * timescale, 
                 */
                timer: {
                    type: Object,
                    notify: true,
                },

                /**
                 * Ctrl- and StatusFlag of Animation
                 */
                trackctrl: {
                    type: String,
                    notify: true
                },

                /**
                 * IN: raw data of all routes to be  
                 */
                routedata: {
                    type: Object
                },
                
                /**
                 * IN: Unique id of route to be processed
                 */
                routeid: {
                    type: String,
                    observer: 'routeFilterApply'
                },

                /**
                 * Status of trackobj avilable to external services 
                 * processing the data for presentation u.Ã¤.  
                 */
                trackdata: {
                    type: Object,
                    notify: true,
                    observer: '_checkTrackdata'
                },

                /**
                 * User-defined Text generated from actual trackObj-properties
                 * z.B. for use in popups !!
                 */
                trackinfo: {
                    type: Object,
                    observer: '_checkTrackinfo'
                },

                /**
                 * Default symbol for map-display of selected trackObj 
                 */
                tracksymbol: {
                    type: String,
                    value: ""
                },

                /**
                 * StatusFlag toggling TrackingMap--NorthMap 
                 */
                trackalignmap: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                // INTERNAL variables

                /**
                 *  Counter of active animation step
                 */
                _counter: {
                    type: Number,
                    observer: 'animationReset'
                },

                /**
                 * contentbox for layers created for route-visualization by map-animation 
                 */
                _animationbox: {
                    type: Object,
                    notify: true
                },

                /**
                 * Basic mapbox-Info-popup 
                 */
                /*popup: {
                    type: Object
                },*/

                /**
                 * temp. copy of trackctrl during animation-interrupt
                 */
                _trackctrl: {
                    type: Boolean
                },

                /**
                 * tmp. Flag indicating move/zoom-status of map 
                 */
                _mapismoved: {
                    type: Boolean,
                    observer: '_animationTrigger'
                },


                /**
                 * { item_description }
                 */
                _trackObj: {
                    type: Object,
                    observer: '_checkObject'
                },

                /**
                 * id of trackObj
                 */
                _trackId: {
                    type: String,
                    value: ""
                },

                /**
                 * Container of animation-ids
                 */
                _requestframeref: {
                    type: Array,
                    value: []
                },

                tracks : {
                    type: Object,
                    value: {}
                },
                routes : {
                    type: Object,
                    value: {}
                },
                traces: {
                    type: Object,
                    value: {}
                },
                nodes : {
                    type: Object,
                    value: {}
                }

            },

            behaviors: [
                Mbb.MapBehavior,
                Mbb.RoutingBehavior
            ],

            observers: [
                '_animationSetup(routedata, timer.timescale, map)', // creates _animationbox
                '_animationMapSetup(map, _animationbox.*)',  // creates 'contentbox' for 
                'mapAlignChange(trackalignmap, _trackObj)',
                'trackCtrlAction(trackctrl)',
                'trackInfoPopup(trackinfo.*)',
                '_checkTimer(timer.*)'
            ],

            /**
             * set 'quasiglobal' this-context for recursive calls during animation 
             * and setup track-features
             */
            attached: function() {
                // 1. setup global namespace 
                mba = this;
            },



            // prepare all map- and animationdata required to view tracks on the map 
            //  - for altered routedata
            //  - if basic(=max) timescale of animation changed
            _animationSetup: function(routedata, timescale, map) {
                if (!routedata || !routedata[0] || !routedata[0].nodes) return;
                // console.log("ROUTESET rawdata:", routedata);

                this.ctrlflag = false;

                // Remove old mapThemes, that are named like the new ones 
                this.trackFeaturesReset();

                this.trackTimerSetup(routedata, timescale);
                console.log("ROUTESET timer=", this.timer); // , routedata);

                this._animationBoxSetup(routedata); 

                // Trigger SETUP of 
                this._counter = 0;
                // this._counter = 1; // 0;

            },

            _animationBoxSetup: function(routedata) {
                // Order(REIHENFOLGE) important, as wp-reduction in routedata possible during route-setup  

                function checkContent(contentbox) {
                    // check if content-arrays are simultan ??

                    // console.log("checkContentBox", contentbox);
                    var n, ncheck, kcheck, kmsg, msg, keys = Object.keys(contentbox) ;
                    keys.every(function(k){

                        n = contentbox[k].srcdata.features.length;
                        if (!ncheck) {
                            ncheck=n;
                            kcheck=k;
                        }                         
                        if (n < ncheck) {
                            msg = " less entries at "+k+":"+n+", "+kcheck+":"+ncheck;
                            kmsg = k;
                            return false;
                        } else if (n > ncheck) {
                            msg = " more entries at "+k+":"+n+", "+kcheck+":"+ncheck;
                            kmsg = k;
                            return false
                        }
                        return true; 
                    })
                    if (msg) {
                        var ffcheck = contentbox[kcheck].srcdata.features,
                            ff = contentbox[kmsg].srcdata.features,
                            msg2;
                        console.log(msg, ffcheck, ff);
                        ffcheck.every(function(v,i) { 
                            if (v.id !== ff[i].id) {
                                msg2 = "first diff at index " + i + ", id=" + v.id; 
                                return false; 
                            } 
                            return true;
                        });    
                        console.log(msg2);
                        return false; 
                    }
                    return true ;
                }

                var contentbox = {},
                    timer = this.timer,
                    metadata = this.objectClone(this.metadataset); // metadata of original dataset

                // Create ROUTES and TRACE (Meta)Layers (not adding yet)          
                contentbox = this.animationRoutesSetup(routedata, timer, metadata); // console.log("checked route-data", routedata);
                contentbox['tracks'] = this.animationTrackerSetup(routedata, timer, metadata);
                // contentbox['nodes'] = this.animationNodesSetup(routedata, metadata); // wayPoints or trackPoints

                if (!checkContent(contentbox)) return; 

                // ??? Doubled assignment of sourceData to trigger PM1-multi-parameter observer  ???
                this._animationbox = {};
                this._animationbox = contentbox; // triggers polymer-based "refresh-action""
            } ,


            /**
             * Create/Refresh mapLayers for changed content (routed Data)
             *
             * @param      {object}  contentbox  The iimapslayers for animation-apps 
             * @param      {object}  map         The map to show routetracker
             */
            _animationMapSetup: function(map, contentbox) {
                var debounceTime = 200;

                this.debounce('tomap', function() {

                    if (contentbox.path == '_animationbox') contentbox = contentbox.value;
                    if (!contentbox || !Object.keys(contentbox).length) return;

                    console.log("SET/REFRESH contentbox of animationMap: ", contentbox);

                    // 1. Specify baselayer to use for feature-ctrl 
                        
                    contentbox["routes"]["usefeatures"] = true; 


                    // 2. Setup Map-Events to query track-features on "mouseover" ( or show info-popup etc)  

                    Object.keys(contentbox).forEach(function(lname){
                        contentbox[lname]["events"] = {};
                    })

                    var mapevents = mba._animationMapEvents(map); 
                    if (mapevents)  {
                        contentbox["routes"]["events"] = mapevents; 
                    }

                    // 3. (Re)Start-action(s) 

                    mba._counter = 1;

                    // Primary Zoom to ALL features after Setup
                    var mapfeatures  = contentbox["routes"].srcdata.features; // console.log("f's at start", mapfeatures); 
                    
                    mba.trackRoutesZoomTo(mapfeatures);

                    // Set Route and RouteCtrl for first "start-time" of animation-routes   
                    mba._animationMapRefresh(mba.timer["start"], "FIRST START");

                    // 4. Triggers the STANDARD addlayer-action off a quickmap-content ( in <mb-content-view>)
                    console.log("contentbox", contentbox); 

                    mba.contentbox = contentbox;
                    //*************************

                }, debounceTime);
            },


            // Events related to animation elements on map
            _animationMapEvents: function(map) {

                    function f_mmove(e) {   
                        if (mba.trackctrl) { // acts during animation only !! 
                            mba.trackObjSelect(e);
                        }    
                    };

                    function f_click(e) {   
                        mba.trackObjSelect(e, true);
                        mba.routeNodeSelect(e);
                    };

                    // f3,f4 act in DEFAULT mapmode only (NORTH-map)   
                    function f_movestart(e) {   
                        if (!mba.trackalignmap) { // console.log("movestart");
                            this._mapismoved = true;
                        }
                    };
                    function f_moveeend(e) {   
                        if (!mba.trackalignmap) { // console.log("moveend");
                            mba._mapismoved = false;
                        }
                    };

                    var events = {
                        'mousemove': f_mmove, 
                        'click': f_click, 
                        'movestart': f_movestart, 
                        'moveend': f_moveeend 
                    }

                    return events; 
                /*    
                    map.off('mousemove', f_mmove); 
                    map.off('click', f_click); 
                    map.off('movestart', f_movestart); 
                    map.off('moveend', f_moveeend); 

                    if (status) { console.log("Resetting animation events!"); 
                        map.on('mousemove', f_mmove); 
                        map.on('click', f_click); 
                        map.on('movestart', f_movestart); 
                        map.on('moveend', f_moveeend); 
                    }
                */    
            }, 


            // Manages START/STOP-Flag (trackctrl) of animation 
            // if map-move events (map moved by user) are fired during animation 
            _animationTrigger: function(mapismoved) {
                // console.log("mapismoved", mapismoved, old);
                if (mapismoved) {
                    //this.debounce('movestarted', function() {
                    mba._trackctrl = false;
                    if (mba.trackctrl == true) {
                        mba.trackctrl = false;
                        mba._trackctrl = true;
                        console.log("INTERRUPTED track-animation");
                    }
                    //}, 200);
                } else {

                    this.debounce('movestopped', function() {
                        if ((mba.trackctrl == false) && (mba._trackctrl == true)) {
                            mba.trackctrl = true;
                            mba._trackctrl = false;
                            console.log("RESUME track-animation");
                        }
                    }, 100);
                }
            },

            // Create a contentbox-Object for basic Layers related to animation-datasrces 
            // id : "routes", "traces", "nodes", "tracks"
            // 
            _animationContentSetup: function(id, type, srcdata, metas, mapstyle) { //paintprops, layoutprops) {
                if (!mapstyle) mapstyle = {};

                // A. GENERIC presentation-props (layout,paint)  for different animation  layers
                var paints = {},
                    layouts = {};

                if (id == "routes") {
                    paints = {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        "line-dasharray": [4, 4]
                            //"line-color": linecolor
                    }
                }

                if (id == "traces") { // C.2 TRACE
                    paints = {
                        "line-width": 2,
                        "line-opacity": 0.5,
                        //"line-color": linecolor
                    }
                }

                if (id == "nodes") {
                    layouts = {
                        // "icon-image": "{icon}",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 10,
                        "text-offset": [0, 0.3]
                    };
                }

                // B. Join with SPECIFIC props suppplied by app
                if (mapstyle.paints) paints = Object.assign({}, paints, mapstyle.paints);
                if (mapstyle.layouts) layouts = Object.assign({}, layouts, mapstyle.layouts);

                // C. Create mb-Layer
                
                var layerObj = {};

                if (1) { // NEW : use standard Qickmap

                    layerObj = new QuickMap(id, type, srcdata, paints, layouts, metas);

                } else { // REPLACED !!
                   
                    var mbLayer = {
                        "id": id,
                        "source": id,
                        "type": type
                    };
                    layerObj['layer'] = mbLayer;
                    layerObj['meta'] = metas;
                    layerObj['srcdata'] = srcdata;
                    if (paints.length) mbLayer["paint"] = paints;
                    if (layouts.length) mbLayer["layout"] = layouts;
                }

                return layerObj;
            },

            /*_idFilterCreate: function(routeids) {
            },*/

            // reset app conform with selected routeid  
            routeFilterApply: function(routeid) {
                var routeFilter, srcFeatures,
                    timer = this.timer;
                if (!timer || !timer.routes) return;

                // A. Eval routeid-cases and reset timer 
                var timerEntry; 
                if (routeid == "all") {
                    this.trackTimerRefresh();
                } else if (routeid == "clear") {
                    console.log("NOT implemented: CLEAR all features"); 
                    return; 
                } else {
                    timerEntry = timer.routes[routeid];
                    this.trackTimerRefresh(timerEntry);
                }

                // B. SPATIAL ZOOM and Query
                if (!timerEntry) { // 
                    this.trackRoutesZoomTo();
                    this.trackFilterApply("");
                    routeFilter = this._idFilterCreate("all");
                } else {
                    this.trackRoutesZoomTo(null, routeid);
                    this.trackFilterApply(routeid);
                    routeFilter = this._idFilterCreate(routeid);
                }

                // routeFilter (if any) is stored in timer-object
                if (!routeFilter) {
                    delete this.timer.filter;
                } else {
                    this.timer.filter = routeFilter;
                }
                console.log("Setup animation for ["+ routeid+"], timer, filter:", timerEntry, timer); 

                // 
                srcFeatures = this._animationMapRefresh(null, null,  routeFilter);
                // console.log("srcFeatures filtered for:" + routeid, srcFeatures, this.timer);

                if (srcFeatures.routes) {
                    // C. TEMPORAL Location at START of selected routes
                    console.log("running FIRST animation-step");
                    this.trackStepAction(1);
                }
            },


            // A. 

            /**
             * Compile a timer from animated routes
             *
             * @param      {Object}  routedata  The raw routedata
             * @param      {Number}  timescale  The timescale of animation
             * @return     {Object}  Collection of timeCtrls
             */
            trackTimerSetup: function(routedata, timescale) {

                if (!this.timer) this.timer = {};
                this.timer.routes = {};
                this.timer.traces = {};

                // A. Setup basic animation-parameters          

                var fpsmax = this.timer.fpsmax ? this.timer.fpsmax : 60; // Animationszeit 1s=6*60s=6min, 10s=1h Echtzeit 
                if (!timescale) timescale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                this.timer["timescale"] = timescale;

                this.timer.frametime = timescale / fpsmax; // Bsp: frametime: 6 s fuer scale = 360 und fps=60 !!

                // B. Convert tarcelength from time to number of animation steps
                if (this.timer.tracelength) {
                    if (typeof this.timer.tracelength == "string") {
                        var tl = this.utcTime(this.timer.tracelength, null, "s"),
                            nn = Math.round(tl / this.timer.frametime);
                        // console.log("trackTimerStart", this.timer, tl, nn);
                        this.timer.tracelength = nn;
                    }
                }


                // C.1 Assemble start&stop 
                //      for all waypoint-times 
                //      of every route 
                var wptimer = {};

                routedata.forEach(function(route, j) {
                    // console.log("route-" + j, route);
                    if (route.nodes) {

                        var starts = [],
                            stops = [];

                        route.nodes.forEach(function(wp, p) {
                            if (wp.ab) starts.push(wp);
                            if (wp.an) stops.push(wp);
                        }.bind(this));

                        // Collect 
                        wptimer[route.id] = {
                            "starts": starts,
                            "stops": stops
                        }; // [starts, stops, passes];
                    }

                }.bind(this));
                console.log("trackTimerSetup. wptimes=", wptimer); // return;

                // C.2 Assemble start&stop times for timer 
                //   - per route 
                //   ( - and for overall animation period )
                // var start, stop;
                Object.keys(wptimer).forEach(function(id) {

                    var wpstart, wpstop, routestart, routestop;

                    var starts = wptimer[id]["starts"],
                        stops = wptimer[id]["stops"];

                    if (starts.length) {
                        wpstart = starts[0];
                        wpstop = starts[starts.length - 1];
                    }
                    if (stops.length) wpstop = stops[stops.length - 1];

                    if (wpstart && wpstop) {
                        routestart = this.utcTime(wpstart.ab, wpstart.coords, "h");
                        routestop = wpstop.an ? wpstop.an : wpstop.ab;
                        routestop = this.utcTime(routestop, wpstop.coords, "h");
                    }

                    this.timer.routes[id] = {
                        "id": id,
                        "start": routestart,
                        "stop": routestop,
                    };

                    if (routestart) {
                        this.timer.routes[id]["date"] = this.logTime(routestart, "h", "/");
                    }    

                    //if (!start || (routestart < start)) start = routestart;
                    //if (!stop || (routestop > stop)) stop = routestop;

                }.bind(this));
                // console.log("timer for waypoints:", wptimer, timer);


                // D. OPTION: Get sorted sequences of start- and stop-times
                //   
                var startTimes = [],
                    stopTimes = [],
                    routes = this.timer.routes;
                for (let key in routes) {
                    startTimes.push(routes[key]["start"]);
                    stopTimes.push(routes[key]["stop"]);
                }
                startTimes.sort();
                stopTimes.sort();
                this.timer["starts"] = startTimes;
                this.timer["stops"] = stopTimes;

                // E. // Setup timer for complete routeset 
                this.trackTimerRefresh(); // Setup timer for 
            },

            // Update timer-entries to FORCE databinding-events to timer-ctrls
            trackTimerRefresh: function(timerEntry) {
                var start, stop, 
                    n = this.timer.stops.length - 1;

                if (!timerEntry) {
                    start = this.timer.starts[0];
                    stop = this.timer.stops[n];
                    timerEntry = "all routes"; 
                } else {
                    start = timerEntry.start;
                    stop = timerEntry.stop;
                }

                // ** SET explicitely to notify changes for data-binding to ctrl-elements
                this.set("timer.start", start);
                this.set("timer.stop", stop);
                this.set("timer.time", start);
                // console.log("Timer refreshed for ", timerEntry, this.timer);
            },

            // B. TrackCtrls

            /**
             *  Actions after main animation ctrl changes 
             *
             * @param      {any basic type}  trackctrl  Main animation Ctrl
             */
            trackCtrlAction: function(trackctrl) {
                var ctrlflag = "STOP";
                // console.log("LOG: trackctrl", trackctrl);
                if (trackctrl) {
                    // console.log("trackCtrlActn:", typeof trackctrl, trackctrl);
                    if (typeof trackctrl == "number") {  // A. 
                        // console.log("ctrltime[h] set (slider o.Ã¤.)", trackctrl)
                        var mapTime = trackctrl,
                            located = this.trackStepAction(null, mapTime);
                    
                        if (located) ctrlflag = "CONT";

                    } else if (trackctrl == "reset") { // B. 
                        
                        this.trackctrl = false; // triggers this function (trackCtrlAction) again 
                        this.trackalignmap = false; // 
                        this._trackId = undefined; 

                        this._counter = 0;

                        this.trackRoutesZoomTo();
                        
                        ctrlflag = "STOP";
                    
                    } else {
                        
                        ctrlflag = "START";
                    }

                } else {

                    if (this._counter) {
                        var trackObjs = [];
                        if (this.map) {
                            trackObjs = this.map.querySourceFeatures({
                                layers: ['tracks']
                            });
                        }  // console.log("STOPPED track at cnt=" + this._counter + " with objs", trackObjs);
                    }

                    ctrlflag = "STOP";
                }

                this.trackStepAnimation(ctrlflag);
                // ******************************
            },

            // Reassign animation data (why) 
            animationReset: function(_counter) {

                if (0) {
                    // if (_counter == 1) {
                    // RESET to START
                    if (this.map.getSource('routes')) { // == 0
                        var timer = this.timer;                        
                        // console.log("Reset tracking objects");
                        var contentbox = this.animationRoutesSetup(this.routedata, timer);
                        // Set the coordinates of tracker(s) and trace(s) back to origin
                        this.animationTrackerSetup(this.routedata, timer);

                        this.map.getSource('routes').setData(this.routes);
                        this.map.getSource('tracks').setData(this.tracks);
                        // this.map.getSource('traces').setData(this.traces);
                    }
                }
            },    	


            /**
             *   Swing-switch of map-orientation between north and track-aligned
             *   maporientation: true = aligned along bearing of trackObject
             */
            mapAlignChange: function(mapalign, geojson) {
                if (!this.map || !geojson) return;

                var minZoom = 4;
                var mm = {};
                mm.center = geojson.geometry.coordinates;
                mm.bearing = geojson.properties.bearing;
                if (!mm.bearing) return; // not given or = 0 

                this.trackctrl = false; // STOP animation

                if (mapalign) {
                    mm.align = true; 
                }   // console.log("mapAlignChange", mm); 
                this.mapLocate(mm, minZoom);
            },

            // C. TrackStep-Animation 

            /**
             *  
             */
            trackStepAnimation: function(flag) {
                if (!mba) return;
                // var timer = mba.timer;
                if (!mba.timer) {
                    mba.popupOnMap("OOPS. AnimationTimer n.a.");
                    mba.trackctrl = false;
                    return;
                }
                // 1. Remove OLD animationRefs
                var rfr = mba._requestframeref;
                // console.log("CTRL " + flag, rfr, "timer=", mba.timer);
                if (rfr && rfr.length) {
                    rfr.forEach(function(r) {
                        cancelAnimationFrame(r);
                    })
                }

                if (flag == "STOP") {
                    return;
                }

                // 2. Start new animationFrame
                mba._requestframeref = [];
                // let timer = mba.timer;
                if (mba.timer.fps && (mba.timer.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                    setTimeout(function() {
                        mba._requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                    }, 1000 / mba.timer.fps);
                } else { // system-based Recall-frequency 
                    mba._requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                }
            },

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {
                
                function updateMapTrack() {
                    var s1 = mba.map.getSource('tracks');
                    var s2 = mba.map.getSource('traces');

                    if (s1) s1.setData(mba.tracks);
                    if (s2) s2.setData(mba.traces);
                }

                function generateCtrlMsg(counter) {    
                    var mapTime = (mba.timer["start"]) + (counter * mba.timer.frametime / 3600),
                        t_msg = mba.logTime(mapTime, "h"),
                        s = mba.getNextStart(mapTime),
                        msg;

                    if (s) {
                        let ds = s - mapTime,
                            ds_msg = mba.deltaT(ds, "");
                        msg = "Continue at: " + mba.logTime(s, "h") + "<hr>TTT: " + ds_msg;
                    } else {
                        msg = "IDLE: " + t_msg;
                    }
                    mba.popupOnMap(msg);
                }

                if (!mba.tracks || !mba.tracks.features) {
                    mba.popupOnMap("OOPS. TrackData n.a.");
                    mba.trackctrl = false;
                    return;
                }

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.

                // ******************************
                var located = mba.trackStepAction(mba._counter);
                // ******************************

                // B. Transfer updated track to map or generate ctrlMsg

                if (!located) {
                    // updateMapTrack(); 
                } else {    
                    generateCtrlMsg(mba._counter);
                }

                // C. Prepare request of next trackStepAction (animationFrame) 
                mba._counter = mba._counter + 1;

                // D. Animation RECALL 
                if (mba.trackctrl) {
                    mba.trackStepAnimation("CONT");
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function updates location and properties  
                // of trackObjects and trackTraces at animationstep 'counter'
                //  - passed as parameter directly  
                //  - recalculated from mapTime 

                var timer = mba.timer,
                    map = mba.map;
                // ctrl-parameters 
                var located = 0, // counts trackObjs relocated at trackStep
                    mapMsg = ""; // flag is set at "specific" situations (start,stop, ...)

                // Search location of (animation-)counter 
                // on one of the routes legs                     	
                function getLegLocation (counter, route) { 
                    var legLocation; 

                    var geotype = route.geometry.type,
                        legCoordSet = route.geometry.coordinates;
                    if (geotype == "MultiLineString") { // multiple legs ?? 
                    } else { // one leg only 
                        legCoordSet = [legCoordSet];
                    }

                    // Iterate along the positions of the route-legs 
                    // until the track-counter is "located" within one of the legs. 
                    // Get coords and legInfo of the leg selected.

                    var routeProps = route.properties,
                        legdata = routeProps.legs,
                        legStartAt = routeProps.startCounter,
                        legStopAt, cc;

                    legCoordSet.every(function(legPositions, i) {
                        cc = null;
                        legStopAt = legStartAt + legPositions.length;
                        if (counter < legStopAt) {
                            cc = legPositions[counter - legStartAt];
                            if (cc) {
                                legLocation = {
                                    "leg": legdata[i],
                                    "coords": cc
                                };
                                return false;
                            }
                        }
                        // move to next leg
                        legStartAt = legStartAt + legPositions.length;
                        return true; // wichtig !!
                    });
                    return legLocation; 
                }

                // Map-Updates related to HILITED tracker
                function updateTrackMap(trackObj, legLocation) {

                    var coords = legLocation["coords"],
                        legInfo = legLocation["leg"];

                    var trackBearing = trackObj.properties.bearing;

                    if (mba.trackalignmap) {
                        // In track-align-map-orientation 
                        // The map is continuously 
                        //  - rotated to bearing 
                        //  - centered at trackObj 
                        // NO mapInfo is shown   
                        
                        console.log("Map-Bearing aligned to track:", trackBearing);

                        // Trigger CLOSE of trackInfo (fi. on map)
                        mba.trackdata = {
                            "open": false
                        };

                        let map = mba.map;
                        map.easeTo({
                            center: coords,
                            bearing: trackBearing
                        });

                        map.setLayoutProperty('tracks-select', 'icon-rotate', 0);

                    } else {
                        // REFRESH trackdata to trigger INFO-element(-popup) 
                        // and the trackObj-symbol is aligned to bearing

                        mba.trackdata = {
                            "id": mba._trackId,
                            "lnglat": coords,
                            "trackobj": trackObj
                        }

                        map.setLayoutProperty('tracks-select', 'icon-rotate', trackBearing);
                    }

                    // optional specAction if selectedObj "arrived"  
                    if (trackObj.properties.arrived) {
                        // mba.trackalignmap = false;
                    }

                } 

                // - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - 

                // A.0 Sync alternative animation-time-sources 

                if (!counter) { 
                    counter = 0;
                    if (mapTime) {
                        counter = (mapTime - timer["start"]) * 3600 / timer.frametime;
                        counter = Math.round(counter);
                    }
                    // ??? WHY 
                    if (counter == 0)  counter = 1;
                    mapMsg += "mapTIME"
                }

                if (counter && !mapTime) {
                    mapTime = (timer["start"]) + (counter * timer.frametime / 3600);
                }

                mba._counter = counter;

                // A.1 Export Timesignal for sync with other elements 
                
                mba.set('timer.time', mapTime);
                // ****************************

                // A.2 Integrated RESET-function 
                //     after setting the animation-starttime
                if (counter == 1) {
                    // zoom to max Extent of (all) route(s)
                    // console.log("zoom2max at counter=1", timer);
                    mba.trackRoutesZoomTo(null, null, timer.filter); 
                    // mba.trackctrl = false // RESET trackObject 
                }

                // B. REFRESH the srcdata of those trackObjects/trackTraces 
                //    whose start and stop surround actual mapTime  
                var nn = mba.tracks.features.length;

                for (j = 0; j < nn; j++) {
                    // Easyly find route and trace for trackObj 
                    // as routes, traces and track(Obj)s are equally indexed 
                    var route = mba.routes.features[j],
                        trackObj = mba.tracks.features[j];
                        trackTrace = mba.traces.features[j];
                    
                    var routeProps = route.properties, 
                        routeid = routeProps.id,
                        routeStartCounter = routeProps.startCounter;

                    if (mapTime > routeProps.stop) {           // A. BREAK "" after end of this route 

                        if (routeStartCounter != null) {   // must be valid for 0 too

                            routeProps.startCounter = null;

                            mba.trackStepTracer("STOP");

                            mapMsg += ",STOP:" + routeid;
                        }

                    } else if (mapTime >= routeProps.start) {  // B. Try to refresh the      

                        if (routeStartCounter == undefined) { // 
                            // FIRST access to this route during animation
                            routeStartCounter = Math.round((routeProps.start - (timer["start"])) / (timer.frametime / 3600));
                            routeProps.startCounter = routeStartCounter;
                            mapMsg += ",START:" + routeid;
                        }

                        // Find the legLocation of animation-counter 
                        var legLocation = getLegLocation(counter, route) ; 
                        
                        // Update dynamic features according to its location on the route
                        if (legLocation) {

                            located += 1;

                            var coords = legLocation["coords"],
                                legInfo = legLocation["leg"];

                            // A. Set new POSITION of trackObject 

                            trackObj.geometry.coordinates = coords; 

                            // B. Option: EXTEND/MOVE the trackTrace 

                            if (trackTrace && timer.traces && timer.traces[routeid]) {
                                var traceCoords = mba.trackStepTracer(mapTime, coords, routeid, timer);
                                if (traceCoords.length) { // console.log("traceCoords", traceCoords);
                                    trackTrace.geometry.coordinates = traceCoords;
                                }  
                            }

                            // C. Option: HILITE/SYNC content (and location) of the info-popup 
                            //    if the trackObj of this route was selected as "selected-Object" 
                            
                            if (mba._trackId == routeid) {

                                // Eval DynamicSTATUS (properties) of trackObj between 2 animation-points 
                                if (trackObj.properties.lastPos) {
                                    mba.getTrackStatus(trackObj, legInfo, mapTime);
                                    // console.log("Refreshed " + routeid, trackObj); // , legInfo);
                                }

                                updateTrackMap(trackObj, legLocation) ; 

                            } else {
    
                                // console.log(mapTime, coords); 

                                // ??? align all "active" trackers along its bearing (without hiliting)
                                // requires filtering of the tracklayer-feature related to trackObj   
                                // map.setLayoutProperty('tracks', 'icon-rotate', trackObj.properties.bearing);
                            }

                            // D. Mark this location as lastLocation for next animationStep 
                            trackObj.properties.lastPos = legLocation['coords'];
                        }
                    }
                };
                
                // C. APPLY the updated sources of the animation-layers                
                if (located) {                    
                    var s1 = mba.map.getSource('tracks');
                    if (s1) {
                        s1.setData(mba.tracks);
                    }

                    // NOW(T) working  
                    var s2 = mba.map.getSource('traces');
                    if (s2 && mba.traces.features.length > 1) {
                        s2.setData(mba.traces);
                    }   
                }

                // D. If flag "mapMsg" was created  
                if (mapMsg) { // console.log(mapMsg);
                    mba._animationMapRefresh(mapTime, mapMsg, timer.filter);
                } 

                return located;
            },

            // Calc status-parameters at mapTime and save as trackObj-properties
            getTrackStatus: function(trackObj, legInfo, mapTime) {

                var speedFlag = true;

                var routeunitsystem = trackObj.properties.unitsystem;
                // console.log("getTrackStatus with " + routeunitsystem + " unitsystem from ", legInfo, trackObj);

                trackObj.properties.time = this.logTime(mapTime, "h");

                var nowPos = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos;

                // calc the bearing between "actual" and 'last' Position of trackObj 
                var bearing = turf.bearing(new TrackSource(lastPos), trackObj);
                
                if (bearing < 0) bearing = bearing + 360;
                if (bearing > 360) bearing = bearing - 360;

                // Use temporary Leg to calculate DTA
                var legTarget = legInfo.to;
                var legToArrival = new LegSource([nowPos, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers"); // console.log("dta", dta); 

                var v = legInfo.speed,
                    dist = legInfo.dist,
                    speedUnit, distUnit ;

                // if (v && Math.round(dta / 10)) { 
                if (v && dta) { // TrackObj is "Moving" 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.tta = tta;
                    trackObj.properties.bearing = Math.round(bearing); // Â°
                    trackObj.properties.arrived = null;
                    trackObj.properties.ttt = null;

                    if (routeunitsystem == "nautic") {
                        speedUnit = "nds";
                        distUnit = "nm";

                        trackObj.properties.speed = Math.round(v / 1.856); // nds
                        trackObj.properties.dist = Math.round(dist / 1.856); // nm
                        trackObj.properties.dta = Math.round(dta / 1.856); // nm

                    } else if (routeunitsystem == "angloamerican") {
                        speedUnit = "mph";
                        distUnit = "mil";

                        trackObj.properties.speed = Math.round(v / 1.609); // mph
                        trackObj.properties.dist = Math.round(dist / 1.609); // miles
                        trackObj.properties.dta = Math.round(dta / 1.609); // miles

                    } else {
                        speedUnit = "kmh";
                        distUnit  = "km";

                        trackObj.properties.speed = Math.round(v); // km/h
                        trackObj.properties.dist = Math.round(dist); // km
                        trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    }

                    if (speedFlag) {
                        trackObj.properties.title = trackObj.properties.speed + speedUnit;
                        // console.log("speed=", trackObj.properties.title);
                    }

                } else { // Resting(pausing) objects 

                    if (!v) trackObj.properties.bearing = 0; // stÃ¶rend on track-animation
                    trackObj.properties.speed = 0;
                    trackObj.properties.dist = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;

                    if (legTarget.ab && (legTarget.ab != legTarget.an)) {

                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        trackObj.properties.arrived = "Stopover: " + stoptime;

                        let cntdwn = this.deltaT(legTarget.dep - mapTime, ":");
                        trackObj.properties.ttt = cntdwn;

                    } else {

                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },

            // Get the trace of a route at a mapTime
            trackStepTracer: function(mapTime, coords, routeid, timer) {
                if (mapTime == "STOP") return [];

                // var tracelength = 10; // timer.traces[routeid].length; 
                if (typeof timer.tracelength == "number") tracelength = timer.tracelength;

                var tracetemplate = timer.traces[routeid],
                    startTime = timer.routes[routeid].start,
                    traceCounter = Math.round((mapTime - startTime) / (timer.frametime / 3600)),
                    first = traceCounter < tracelength ? 0 : traceCounter - tracelength,
                    last = traceCounter;

                tracetemplate.push(coords);     
                // console.log(first, last, tracetemplate, timer);
                // return traceCoords;
                return tracetemplate.slice(first, last);
            },

            // D. SETUP elements ctrling and/or illustrating the tracking 

            // Initialisierung der animation-feature(collections)
            trackFeaturesReset: function() {
                var lnames = ["routes", "traces", "tracks", "nodes"];
                // console.log("trackFeaturesReset for objects:", lnames);
                lnames.forEach(function(lname) {
                    // console.log("RES:", lname);
                    if (mba.map.getLayer(lname)) mba.map.removeLayer(lname);
                    if (mba.map.getLayer(lname + "-select")) mba.map.removeLayer(lname + "-select");
                    if (mba.map.getLayer(lname + "-glow")) mba.map.removeLayer(lname + "-glow");
                    if (mba.map.getLayer(lname + "-glow-strong")) mba.map.removeLayer(lname + "-glow-strong");
                    if (mba.map.getLayer(lname + "-bg")) mba.map.removeLayer(lname + "-bg");

                    if (mba.map.getSource(lname)) mba.map.removeSource(lname);

                    this[lname] = {
                        "type": "FeatureCollection"
                    };
                }.bind(this));

            },

            /**
             * Setup "routes" optimized for animation with "requestAnimationFrame (60 fps)"
             * Optional + "traces" (= route-geometries "behind" the tracker ) 
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationRoutesSetup: function(routedataset, timer, metadataset) {
                // console.log("setupAnimationRoutes, configdata:", routedataset);

                this.routes.features = [];
                this.traces.features = [];
                var routemetas = {};  // separate collection of all routes metadata

                /** Basic routeCreate-action   
                 *  compile coords of all route-legs into one coordinatecollection 
                 */
                function animationRouteCreate(routedata, timer) {
                    // console.log("Initialize route from", data, timer);
                    var routeNodes = routedata.nodes; // wps as given
                    if (!routeNodes.length > 1)  return; // 

                    var frametime = timer.frametime;

                    var nextNode, legDistance, legStepCount;

                    var routeid = routedata.id,
                        legsData = [], // mean props of every leg    
                        legsCoords = [], // coords of every leg
                        legTimeSec, legStopSec, legSpeed, routespeed;

                    var props = {
                        "id": routeid,
                        "start": timer.routes[routeid]["start"],
                        "stop": timer.routes[routeid]["stop"]
                    };

                    if (routedata.speed) {
                        props.speed = routedata.speed;
                    }

                    // console.log("Initialize route from", data, timer, props);

                    var srces = {};

                    // A. Create route-object consisting of 1-n legs

                    // Create route-legs between 2 waypoints at any one time 

                    routeNodes.forEach(function(wp, p) {

                        legStopSec = 0;
                        nextNode = routeNodes[p + 1];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("waypoints:" + p, wp, nextNode);
                            // Calculate the distance in kilometers between waypoints
                            var leg = new LegSource([wp.coords, nextNode.coords]),
                                legDistance = turf.lineDistance(leg, 'kilometers');

                            // legDistance = Math.round(legDistance);

                            // Calculate a mean leg-speed between wp's with ab/an times
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                    arv = mba.utcTime(nextNode.an, nextNode.coords, "h");
                                legSpeed = legDistance / (arv - dep);
                                nextNode.arv = arv;
                            } else if (nextNode.speed) {
                                legSpeed = nextNode.speed;
                            }
                            // legSpeed = Math.round(legSpeed);
                            //console.log("leg-speed-calc", legDistance, legSpeed, nextNode, wp);

                            // Calculate arv and dep at "stopover"
                            if (nextNode.an && nextNode.ab) {
                                let arv = mba.utcTime(nextNode.an, nextNode.coords, "h"),
                                    dep = mba.utcTime(nextNode.ab, nextNode.coords, "h");
                                legStopSec = (dep - arv) * 3600;
                                nextNode.arv = arv;
                                nextNode.dep = dep;
                            } else if (nextNode.stopover) {
                                legStopSec = nextNode.stopover;
                            }
                            // 3. Calc leg-animation 

                            // Time and number of animation-steps to travel between waypoints in legTimeSec
                            legTimeSec = legDistance / legSpeed * 3600;
                            legStepCount = Math.round(legTimeSec / frametime);

                            // console.log(p + ". leg-data for dx=" + legDistance, "n=" + legStepCount);

                            // Assign basic leg-properties
                            var legInfo = {};
                            legInfo.from = wp;
                            legInfo.to = nextNode;

                            legInfo.dist = legDistance;
                            legInfo.speed = legSpeed;

                            legInfo.time = legTimeSec;
                            legInfo.steps = legStepCount;

                            // Assign time-properties
                            var h = Math.floor(legTimeSec / 3600),
                                m = Math.round((legTimeSec - (h * 3600)) / 60);
                            legInfo.timetext = h + "h" + m + "min";

                            // Insert animation-positions along the leg
                            var startPosition = 0;
                            var legPositions = [];

                            for (let i = 0; i < legStepCount; i++) {
                                let dist = i * (legDistance / legStepCount);
                                let position = turf.along(leg, dist, 'kilometers');
                                legPositions.push(position.geometry.coordinates);
                            }

                            // 4. Append "STOPOVER-animation" 
                            //    into 
                            if (legStopSec) { // INSERT some "zero-steps" at stopover waypoint 
                                // console.log("INSERT STOPover at ", nextNode, legStopSec);
                                h = Math.floor(legStopSec / 3600);
                                m = Math.round((legStopSec - (h * 3600)) / 60);
                                legInfo.stopTime = h + "h" + m + "min";
                                var n = Math.round(legStopSec / frametime);
                                legInfo.stopSteps = n;
                                // append the "stop-coordinates" to the leg 
                                for (let i = 0; i < n; i++) {
                                    legPositions.push(legPositions[legPositions.length - 1]);
                                }
                            }

                            // 4. Compile leg-data in route-collections of legs  
                            // console.log("leg-data ", legInfo, legPositions);
                            legsData.push(legInfo);
                            legsCoords.push(legPositions);
                        }
                    });

                    srces["routeSrc"] = new RouteSource(routeid, props, legsCoords, legsData, routeNodes);

                    // B. Save a template for dynamic traces 
                    //  - the complete trace of a route as
                    //  - the first node 
                    //  - an empty trace

                    if (timer.tracelength == undefined) timer.tracelength = 10 ;
                    
                    if (timer.tracelength) {

                        var coordinates = [];

                        if (1) {    // collect coordinates of complete route
                            legsCoords.forEach(function(legcoords) {
                                coordinates = coordinates.concat(legcoords);
                            });
                        } else if (legsCoords.length) { // first 2 nodes only
                            var l = legsCoords[0];
                            console.log("legsCoords", l)        
                            coordinates.push(l[0]); 
                            coordinates.push(l[1]) ;
                        } else {    // empty

                        }    

                        // Create "initial" trace-object with startpoint only
                        var traceInit = coordinates;    

                        if (coordinates.length > 1) traceInit = coordinates.slice(0, 2);

                        timer.traces[routeid] = traceInit;

                        srces["traceSrc"] = new TraceSource(traceInit, routeid);
                    }

                    // console.log("New routeSrces: " + routeid, rSrc, tSrc);
                    return srces;
                }

                function setupRouteStyling(routemetas) {

                    // Unique color 
                    var linecolorProp = "#007cbf";

                    // Option: Prepare differentiated linecolor-styling for every route
                    // as mb-lookup on "id" with "stops"-table  
                    var metakeys = Object.keys(routemetas);
                    if (metakeys.length) {
                        // optional: ddr-styling based on routeid
                        var ddrLinecolors = {
                            property: 'id',
                            type: 'categorical',
                            stops: []
                        };

                        metakeys.forEach(function(id) {
                            var col = routemetas[id].color;
                            if (!col) col = linecolorProp;
                            if (!col) col = this.getRandomColor();
                            ddrLinecolors.stops.push([id, col]);
                        }.bind(this));

                        linecolorProp = ddrLinecolors;
                    }

                    var routePaintProps = {
                        "line-color": linecolorProp
                    };  // console.log("routePaintProps", routePaintProps); 
                    
                    return { "paints": routePaintProps} ; 
                }
                
                // A. Interpolate the Routes between waypoints(trackpoints) 
                //    based on info about speed and/or arrival-/departure-times at waypoints
                var nn = routedataset.length,
                    rr, r, t, m;

                routedataset.forEach(function(routedata, j) {
                    
                    // A.1 track-based routes should be preprocessed to minimie gps-noise 

                    if (routedata.trackmode) {
                        routedata = this.trackDataFilter(routedata, timer);
                    }

                    if (routedata.nodes && (routedata.nodes.length > 1)) { // minimum 2 points required 
                        
                        // A.2 Create srcObjects 
                        rr = animationRouteCreate(routedata, timer);
                        // **********************

                        // A.3  Include srcObjects into api-Context
                        if (rr) { // console.log("setupAnimationRoute:" + j, rr);
                            
                            r = rr.routeSrc;
                            t = rr.traceSrc;
                            
                            if (!routedata.meta) routedata.meta = {};
                            if (!routedata.meta.color) routedata.meta.color = this.getRandomColor();

                            routemetas[r.id] = routedata.meta;

                            r.properties = Object.assign({}, r.properties, routedata.meta);

                            this.routes.features.push(r);
                            // **************************

                            // IF prepared, add trace-features (with same properties as routes) 
                            if (t) {

                                t.properties = r.properties;
                                this.traces.features.push(t);
                                //*********************
                            }
                        }
                    }

                }.bind(this));
                // console.log("Srces:", this.routes.features, this.traces.features);
                // return;

                // B. Setup (differentiated) STYLING of routes (and traces) 

                var routeStyling = setupRouteStyling(routemetas); 

                // C. FINAL mb-Objects

                var routesContent = this._animationContentSetup("routes", "line", this.routes, routemetas, routeStyling);
                
                var tracesContent = this._animationContentSetup("traces", "line", this.traces, routemetas, routeStyling);

                // RETURN: 
                // console.log("ThemeObjs:", mapObjRoutes, mapObjTraces);
                return {
                    "routes": routesContent,
                    "traces": tracesContent
                };
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationNodesSetup: function(routedata) {
                // console.log("setupAnimationNodes. srcdata:", routedata);
                this.nodes.features = [];
                var nodemetas = {};

                function setupBgLayer(nodemetas) {
                    // Prepare ddr-styling (circle-size of symbol-bg)
                    // fi. to visualize size of airport-nodes 

                    var nodesize = 2,
                        size, smin, smax;

                    Object.keys(nodemetas).forEach(function(id) {
                        size = nodemetas[id].size;
                        if (size) {
                            if (!smin || (size < smin)) smin = size;
                            if (!smax || (size > smax)) smax = size;
                        }
                    })

                    if (smin && smax && (smin < smax)) {
                        nodesize = {
                            property: 'size',
                            stops: [
                                [smin, 4],
                                [smax, 12]
                            ]
                        }
                    }

                    var bglayer = {
                        "id": "nodes-bg",
                        "type": "circle",
                        "source": "nodes",
                        "paint": {
                            "circle-radius": nodesize,
                            "circle-opacity": 0.5,
                            "circle-color": "red"
                        }
                    };

                    return bglayer; 
                }

                // A. Collect nodes into features
                var allnodes = this.nodes,
                    id;

                routedata.forEach(function(route, j) {
                    // locate trackObj at 'origin'
                    if (route.nodes && (route.nodes.length>1)) {
                        // console.log("route-" + j, route.nodes);
                        route.nodes.forEach(function(wp, p) {
                            var key,
                                coords,
                                newNode,
                                props = {},
                                meta = wp.meta;

                            if (wp.id) key = wp.id;
                            else if (meta && meta.id) key = meta.id;
                            else key = p;

                            allnodes.features.forEach(function(nod) {
                                // do NOT add nodes multiple times (fi airports of different flights)
                                if ((key != p) && (nod.id == key)) {
                                    // console.log("doubling routenode", key, route.id);
                                    newNode = nod;
                                }
                            });

                            if (!newNode) {
                                if (wp.coords) coords = wp.coords;
                                else if (meta.coords) coords = meta.coords;
                                else key = p;

                                Object.keys(wp).forEach(function(k) {
                                    if (k != "coords") props[k] = wp[k];
                                });

                                // console.log("wp-" + p, key, wp, props);
                                newNode = new NodeSource(coords, key, route.id, props);
                                if (wp.meta) {
                                    newNode.properties = Object.assign({}, newNode.properties, wp.meta);
                                    nodemetas[key] = wp.meta;
                                }

                                allnodes.features.push(newNode);
                            }
                        });
                    }
                });
                // console.log("all waypoints collected", allwaypoints.features);

                // B. Create object 
                var mapObjNodes = this._animationContentSetup("nodes", "symbol", allnodes, nodemetas);

                // C. additional layer as node-background to the same src
                // mapObjNodes['bglayer'] = setupBgLayer(nodemetas) ;

                //console.log("nodeLayer", nodeLayer);
                return mapObjNodes;
            },

            /**
             * create the contentBoxObj for trackLayer
             *
             * @param      {object}  routedata     The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationTrackerSetup: function(routedataset, timer, metadataset) {
                // console.log("routedata at setupAnimationTracker", routedata);
                // the trackLayerObj contains the data, the styling of the baseLayer AND the styling for the selectLayer
                if (!timer) timer = this.timer;
                if (!metadataset) metadataset = this.metadataset; console.log("animationTrackerSetup metadata", metadataset); // metadata of primary datasrc 
                
                function guessRouteMeta(routedata) {
                    // HEURISTIC to alternatively(?) query from different properties 
                    var routeMeta = routedata.item; // 
                    if (!routeMeta) routeMeta = routedata.meta;
                    if (!routeMeta) routeMeta = routedata.master;
                    if (!routeMeta) routeMeta = {};

                    if (!routeMeta["id"]) routeMeta["id"] = routeid;
                    return routeMeta;
                }

                function guessTrackStyle(routemetas) {
                    // includes options for 
                    //  - different icon(color) per tracker 
                    //  - data-driven rotation of the icon

                    var trackStyle = {}, 
                        type, layouts, paints;
                    const metas = Object.keys(routemetas).map(key => routemetas[key]);  // JS2015
                   
                    const hasIcon = metas[0].icon; 
                    
                    if (hasIcon) { //  EITHER: Symbol 
                        // - with rotating-property 
                        // - NOT be sized or colored byNow (17.02.17)  

                        trackStyle.type = "symbol";

                        // ddr styling enables  
                        // A. in Quick-Mode: variable Icon and text 
                        // ---

                        // B. in LUT-Mode: symbol-rotation according to bearing 
                        // var symbolrotation = 0;
                        var symbolrotation = {
                            property: 'bearing',
                            stops: [
                                [0, 0],
                                [360, 360]
                            ]
                        };

                        trackStyle.layouts = {
                            "icon-image": "{icon}",
                            "icon-rotate": symbolrotation,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        };

                    } else { // OR : ColorableCircle-Layer 

                        trackStyle.type = "circle";

                        // ddr styling enables different colors for every tracker
                        var symbolcolor = "red";
                        
                        if (routemetas && Object.keys(routemetas).length) {
                            var ddrSymbolcolor = {
                                property: 'id',
                                type: 'categorical',
                                stops: []
                            };

                            Object.keys(routemetas).forEach(function(id) {
                                var col = routemetas[id].color;
                                // if (!col) col = symbolcolor;
                                if (!col) col = this.getRandomColor();
                                ddrSymbolcolor.stops.push([id, col]);
                            }.bind(this))

                            if (ddrSymbolcolor.stops.length) {
                                symbolcolor = ddrSymbolcolor;
                            }
                        } 

                        trackStyle.paints = {
                            'circle-radius': 6,
                            'circle-color': symbolcolor
                        }; // console.log("trackStyle", trackStyle); 
                    }

                    // console.log("guessTrackStyle", trackStyle, "from", routemetas); 
                    return trackStyle; 
                }

                function setupSelectLayer(metadataset) {
                    // A meaningful TrackPoint-presentation built from 3 symbol(Layer)s 
                    var selectsymbol = "airport-15";
                    if (metadataset.symbol) selectsymbol = metadataset.symbol; 

                    var selectLayer =  [
                        {
                            "id": "tracks-glow-strong",
                            "type": "circle",
                            "source": "tracks",
                            "paint": {
                                "circle-radius": 18,
                                "circle-color": "#ff0",
                                "circle-opacity": 0.6
                            }
                        }, 
                        
                        {
                            "id": "tracks-glow",
                            "type": "circle",
                            "source": "tracks",
                            "paint": {
                                "circle-radius": 40,
                                "circle-color": "#ff0",
                                "circle-opacity": 0.2
                            }
                        }, 
                        
                        {
                            "id": "tracks-select",
                            "type": "symbol",
                            "source": "tracks",
                            "layout": {
                                "icon-image": selectsymbol,
                                "icon-rotate": 0,
                                "text-field": "{title}",
                                "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                "text-size": 12,
                                "text-offset": [0, 0.6],
                                "text-anchor": "top"
                            }
                        }
                    ];
                    return selectLayer; 
                }  
                
                // A. setup data 
                this.tracks.features = [];
                var routemetas = {};

                var allTracks = this.tracks,
                    routedata, routeid, startort, trackmeta,
                    nn = routedataset.length;

                for (var j = 0; j < nn; j++) {

                    routedata = routedataset[j];  
                    routeid = routedata.id; // console.log(routeid, routedata);

                    if (routedata.nodes && (routedata.nodes.length > 1)) {
                        
                        trackmeta = guessRouteMeta(routedata);
                        routemetas[routeid] = trackmeta;  
                        // console.log(route,trackmeta);

                        var props = {
                            "routeid": routeid,
                            "id": trackmeta.id,
                            "title": trackmeta.id,
                            "unitsystem": routedata.unitsystem,
                            "bearing": 0,
                            "start": timer.routes[routeid]["start"],
                            "stop": timer.routes[routeid]["stop"]
                        };

                        // Optional: master-data-properties
                        props["master"] = trackmeta;

                        // Required : icon; 
                        if (trackmeta.icon) props.icon = trackmeta.icon;

                        // Optional: 
                        if (trackmeta.iconsize) props.iconsize = trackmeta.iconsize;

                        // Create Tracker located at route-start 
                        startort = routedata.nodes[0].coords;

                        var aTrack = new TrackSource(startort, routeid, props);
                        
                        allTracks.features.push(aTrack);

                    } else {
                        // console.log("ALERT.", "No nodes in routedata" + routeid, routedata.nodes ) 
                    }

                };  

                // B. Setup ONE Layer for multiple trackers (DynamicPoints)
                
                // guess from last track-props used to build a Track
                var mbStyle = guessTrackStyle(routemetas); // , routedataset);

                var trackLayerObj = this._animationContentSetup("tracks", mbStyle.type, allTracks, routemetas, mbStyle); // paints, layouts);
                // console.log("trackLayerObj", trackLayerObj);

                // C. ADD SPECIFIC "multiSymbol" presentation 
                // of one!! "observed" trackObj (app-specific)

                trackLayerObj['selectlayer'] = setupSelectLayer(metadataset);

                // console.log("trackLayerObj", trackLayerObj);
                
                return trackLayerObj;
            },

            // Preprocessing of tracks dependent on 
            //  - DOP of tracking device   
            //    ABANDON points closer as DOP  
            //  - animation timescale (alias frametime) 
            //    ABANDON wp, if smaller then timeframe 
            trackDataFilter: function(data, timer, metadataset) {

                // guess measure for spatial accuracy of track-device
                if (!metadataset)  metadataset = this.metadataset;   // console.log("trackDataFilter with metadataset",metadataset) ;
                var dop = 10, 
                    device = metadataset.device;
                if (device && device.dop) dop = device.dop;  

                // Get frametime to use for  
                if (!timer) timer = this.timer; 
                var frametime = timer.frametime;

                var trackpoints = [],
                    routeNodes = data.nodes, // waypoints/trackpoints 
                    legspeed, legTimeSec, wp, nextNode;
                // console.log("original trackpoints", routeNodes);

                var n1 = routeNodes.length, n2;

                var p = 0;
                while (p < routeNodes.length) {
                    wp = routeNodes[p];
                    i = 1;
                    while (i > 0) {

                        nextNode = routeNodes[p + i];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("routeNodes:" + p, wp, nextNode);
                            // A. Check 
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, wp.coords, "s"),
                                    arv = mba.utcTime(nextNode.an, nextNode.coords, "s");
                                legTimeSec = (arv - dep);
                            } else {
                                legTimeSec = wp.stopover;
                            }

                            // CHECK time-diff between wps
                            // ABANDON wp, if smaller then timeframe 
                            if (legTimeSec > frametime / 2) {
                                // B. Check DIST between routeNodes
                                //    ABANDON wp, if smaller then dop
                                var leg = new LegSource([wp.coords, nextNode.coords]),
                                    legDistance = turf.lineDistance(leg, 'kilometers'),
                                    legDistMeters = Math.round(legDistance * 1000);

                                if (legDistMeters > dop) {

                                    // Time and number of animation-steps to travel between routeNodes in legTimeSec
                                    // legTimeSec = legDistance / legSpeed * 3600;
                                    legStepCount = Math.round(legTimeSec / frametime);

                                    // console.log("leg-data ", "dx=" + legDistance, "dt=" + legTimeSec, "steps=" + legStepCount); // , frametime);
                                    // return;
                                    p = p + i;
                                    trackpoints.push(wp)
                                    i = 0;

                                } else {
                                    i = i + 1;
                                }

                            } else {
                                i = i + 1;
                            }

                        } else {
                            p = routeNodes.length;
                            i = 0;
                        }
                    }
                }

                if (nextNode) trackpoints.push(nextNode);
                // console.log("checked trackpoints", trackpoints);

                data.nodes = trackpoints;
                n2 = trackpoints.length;
                if (n2 != n1) {
                     console.log("trackData filtered", n1, n2); // , metadataset.device); 
                }
                return data;
            },

            // E. Additional Functions
            // SHOW SELECT-Track-symbol 
            // - for features with id=[idvalue]
            // - for all if idvalue = ""
            trackFilterApply: function(idvalue) {
                if (typeof idvalue == "undefined") return; 

                var names = ["tracks-select", "tracks-glow", "tracks-glow-strong"];
                names.forEach(function(lname) {
                    if (mba.map.getLayer(lname)) { // console.log("trackFilterApply", lname, idvalue);  
                        mba.map.setFilter(lname, ["==", "id", idvalue]);
                    }
                });
            },

            // SYNC mapcontent (visibility of TrackObjects and "related" map-layers) 
            //   - primarely at "mapTime" (FIRST) 
            //   - or for (combined with) "routeFilter" (SECOND) 
            _animationMapRefresh: function(mapTime, syncflag, routeFilter) {
                // console.log("DEBUG", mapTime, routeFilter, syncflag);
                var stopDelay = 2000; // time to let last situation "visible" before reset 

                // TIME filter: applied, on every maptime ??
                function applyTrackFilter(mapTime, flag, routeFilter) {
                    if (!flag) flag = "noflag";
                    // if (!routeFilter) routeFilter = mba.timer.filter;
                    
                    var routeids = [],
                        routeid,
                        trackFilter,
                        msg;

                    // A. Apply TIME-FILTER on "ALL" trackObjects 
                    //    with start- and stop-properties  
                    //    (is applied on sourcedata)
                    if (mapTime) {
                        trackFilter = [
                            'all', ['>=', 'start', mapTime],
                            ['<=', 'stop', mapTime]
                        ];
                        if (routeFilter) {
                            trackFilter.push(routeFilter); 
                        }    

                    } else if (routeFilter) {

                        trackFilter = routeFilter

                    } else {
                        trackFilter = null;
                    }

                    // Refresh tracks on map
                    var trackName = "tracks", 
                        trackObjs = [],
                        trackLayer = mba.map.getLayer(trackName),
                        boxdata = mba._animationbox[trackName]; 
                    
                    if (trackLayer) {
                        // A.2 Query the trackObj - src-Features 
                        if (boxdata) {  // console.log("boxdata",boxdata);
                            trackObjs = mba._contentGetSrcFeatures(boxdata, {
                                filter: trackFilter
                            });
                        } else {  //  (? present at actual mapextent ?) 
                            trackObjs = this.map.querySourceFeatures(trackName, {
                                filter: trackFilter
                            });
                        } 
                    }

                    if (mapTime && !trackObjs.length) {

                        var msgTime = mba.logTime(mapTime, "h"),
                            nextTime = mba.getNextStart(mapTime);

                        if (!nextTime) { // CHECK for STOP
                            // B.1 No trackfeature defined for filtertime
                            //  STOP animation, if no further track-Start is pendig 

                            mba.trackctrl = false;
                            mba.trackalignmap = false;
                            // trackFilter = null; 
                           
                            msg = "STOPPED. No more data after: " + msgTime; // console.log(msg);
                            // mba.popupOnMap(msg);

                            // SHOW all trackObjects 
                            if (boxdata) {  // console.log("boxdata",boxdata);
                                trackObjs = mba._contentGetSrcFeatures(boxdata, {
                                    filter: null
                                });
                            } else {  //  (? present at actual mapextent ?) 
                                trackObjs = mba.map.querySourceFeatures(trackName, {
                                    filter: null
                                });
                            } 

                        } else {
                            // B.2 
                            msg = msgTime + ". WAITING for next track at: " + mba.logTime(nextTime, "h");
                            // console.log(msg);
                        }

                    } 

                    // B.2 Some trackObjs animated at filter-time  
                    if (flag.indexOf('TIME') >= 0) {
                        // console.log("trackObjs filtered at ", msgTime, trackObjs, startStopFilter);
                    }

                    // C. Get route-ids of active trackers
                    //    to prepare a "SECONDARY FILTER"" 
                    //    to Sync the filters for "related" layers (traces, routes, waypoints)  

                    // collect ROUTES of all actually "active" trackObjs    
                    if (trackObjs.length) {

                        // console.log("Active track(s): Layer, Filter, objs", trackLayer, trackFilter, trackObjs);

                        // A. Filter the visibility of tracks-theme-elements
                        mba.map.setFilter(trackName, trackFilter);

                        // B. Prepare the 
                        trackObjs.forEach(function(to) {
                            routeid = to.properties.routeid;
                            if (routeid) routeids.push(routeid);
                        });

                        // remove possible "DUPLICATES" ? 
                        routeids = routeids.filter(function(item, pos, self) {
                            return self.indexOf(item) == pos;
                        })
        
                        var info = syncflag.substring(0, 15) + "...";

                        msg = "<b>" + info + "</b>" + "<br>" + routeids.length + " track(s) active";
                    }

                    if (mapTime) {
                        msg += "<br> at " + mba.logTime(mapTime, "h", "_");
                    }
   
                    mba.popupOnMap(msg);

                    return routeids;
                };

                // 1. Optional BREAK! 
                //    Sync trackObjects (and it's routes) only as long as they "are tracked2 
                if (!mba.map.getLayer("tracks") && mapTime) {
                    var syncTime = this.logTime(mapTime, "h"),
                        msg = "<b>No trackers on map to track</b>" + " at " + syncTime;
                    mba.popupOnMap(msg);
                    return;
                }

                // 2. Additional HIDE-Filters after STOP-action
                if (syncflag && syncflag.indexOf("STOP") >= 0) {
                    // Apply "stopfilter" after some "stopDelay" only
                    // to let user observe arrived tracker during this delay before removing the tracker and related features 
                    setTimeout(function() {
                        // Apply "empty mapTime-Filter" on trackLayers after stopDelay  
                        mba.trackFilterApply("");
                    }, stopDelay);
                    // return;
                } 

                // 3. Filter for mapTime&&routeFilter (not for flag STOP) 
                var trackids = applyTrackFilter(mapTime, syncflag, routeFilter);
                //console.log("REFRESH: ids of trackFeatures", trackids);

                // 4. 
                var syncFilter = mba._idFilterCreate(trackids);
                // console.log("syncFilter", syncFilter);

                var srcFeatures = mba.syncFilterApply(syncFilter); // ,trackids);
                //console.log("REFRESH: srcFeatures with", routeFilter, srcFeatures);
                return srcFeatures;
            },

            // Create an idFilter for idname (routeid) with 'routeids'
            _idFilterCreate: function(routeids, idname) {
                if (!idname) idname = "routeid";

                var idFilter = ["in", idname];

                if (typeof routeids == "string") { // select one or none ("") 

                    if (routeids == "none") {   // EMPTY filter 
                        idFilter.push("");

                    } else if (routeids == "all") {  // FULL filter
                        idFilter = null;

                    } else { // SINGLE filter

                        idFilter.push(routeids);
                    }

                } else if (!routeids || !routeids.length) { // FULL filter
                    //syncFilter = null; //n = "all";
                    idFilter.push("");

                } else {   // MULTIPLE filter 
                    routeids.forEach(function(id) {
                        idFilter.push(id);
                    });
                    // syncFilter = syncFilter.concat(routeids);
                }

                return idFilter;
            },

            // SYNC animationLayers "related" with tracker of active route
            syncFilterApply: function(syncFilter) { // , boxflag) {
                // Filter  mapFeatures "related"  to animating trackers (identified by routeid-property) 
                // or none 
                // or all 

                // 1. Generate "syncfilter" 
                var srcNames = ["tracks", "traces", "routes", "nodes"],
                    srcFeatures = {},
                    msg = 0;

                if (!syncFilter) { // select one or none ("") 
                    msg = "all";
                } else {
                    msg = "???"
                }

                // 2. Get (?src-)features of "visible" animationThemes 
                //    related to syncFilter 

                srcNames.forEach(function(sname) {
                    var src = mba.map.getSource(sname);
                    if (src) {
                        var features = mba.map.querySourceFeatures(sname, {
                            filter: syncFilter
                        });
                        // console.log(sname, features, src);
                        if (features.length) {
                            srcFeatures[sname] = features;
                        }    
                    }
                });

                // 3. Update the "related" mapLayers

                var srcKeys = Object.keys(srcFeatures);
                
                if (srcKeys.length) {
                    
                    console.log("syncFilterApply with ["+syncFilter+"]", srcFeatures); 

                    srcNames.forEach(function(sname) {
                        if (mba.map.getLayer(sname)) {
                            mba.map.setFilter(sname, syncFilter);
                            if (sname == "nodes") mba.map.setFilter(sname + '-bg', syncFilter);
                        }
                    })
                } 
                return srcFeatures;
            },

            // Zoom to bbox of all raw route-nodes (waypoints, trackpoints) 
            // 
            trackRoutesZoomTo: function(routeFeatures, routeid, filter, msg) {
                if (!msg) msg = "Route-Feature-Zoom.";
               
                var bboxFilter = null,
                    timer,
                    timemsg;

                if (!routeFeatures) {

                    // option: extract routeid from 'filter'-parameter
                    if (filter && !routeid) {
                        bboxFilter = filter;
                        routeid = filter.slice(2, 3); // ???? 
                    }

                    // A. Zoom to a routes "Rawfeatures"
                    // SPECIAL
    
                    if (routeid) {
                        routeFeatures = this._trackRouteGetSrcFeatures(routeid);
                        bboxFilter = ["in", "routeid", routeid];
                        timer = mba.timer.routes[routeid];
                        console.log(msg +" for routeid=" + routeid, "VON " + this.logTime(timer.start, "h"), "BIS " + this.logTime(timer.stop, "h")); // , timer);
                    }

                    // B. Zoom to features in actual viewframe
                    if (!routeFeatures || !routeFeatures.length) {
                        console.log(msg + " applyFilter:", bboxFilter);
                        routeFeatures = this.map.querySourceFeatures("routes", {
                            filter: bboxFilter
                        });
                    }
                }

                if (!routeFeatures || !routeFeatures.length) {
                    console.log(msg + "BREAK. No routefeatures available to Zoom!");
                    return;
                }  // console.log(msg, routeFeatures); // .getCoordinates());
               
                mba.setFeatureBounds(routeFeatures, mba.map);
           
         },

            /**
             *  ??? 
             *
             */
            _trackRouteGetSrcFeatures: function(routeid) {
                // console.log("animationsrc routes", this._animationbox.routes); 
                var routesrc = this._animationbox.routes.srcdata,
                    rrall = [];
                if (typeof routesrc == "string") {
                    var routesrcdata = mba.map.getSource(routesrc); console.log("routesrc:", routesrc, routesrcdata);
                    if (routesrcdata) rrall = routesrcdata.features;  
                } else {
                    rrall = routesrc.features;
                }
                if (!routeid || !rrall.length) {
                    console.log("NO Features queried for id=" + routeid);
                    return rrall;
                }

                var rr = [];
                rrall.forEach(function(r) {
                    if (r.id == routeid) {
                        rr.push(r);
                    }
                });
                // console.log("_trackRouteGetSrcFeatures. queried raw routeData for id=" + routeid, rr);
                return rr;
            },

            // Generic function to test 
            _contentGetSrcFeatures: function(boxcontent, query) {
                // console.log("GetSrcFeatures for ", boxcontent);  

                var contentsrc = boxcontent.srcdata,
                    ffall = contentsrc.features;

                if (!query || !query.filter) {
                    // as well if no filter or filter = null;
                    return ffall;     
                }

                var filter = query.filter,
                    filter0 = filter[0],
                    logic, 
                    qq = [];

                if ( filter0 == "all") { // AND 
                    qq = filter.slice(1); 
                    logic = "and"
                } else if (filter0 == "in")  { // OR 
                    logic = "or"
                } else {    
                    qq = filter; 
                }
                // console.log(qq, ffall);

                var ff = [];

                ffall.forEach(function(f) {
                    var expr, op, prop, value, test, 
                        found = true,
                        props = f.properties;
                    qq.forEach(function(q){
                        op=q[0]; value=props[q[1]]; test=q[2]; 
                        expr = test + op + value; 
                        found = eval(expr) ? (found && true) : false;  // console.log(expr, found); 
                    }) 
                    if (found) ff.push(f);
                });
                // console.log("_contentGetSrcFeatures. queried raw routeData for id=" + routeid, rr);
                return ff;
            },


            // Check if more starts before end of animated routeSet (timer.stop)
            getNextStart: function(mapTime) {
                var starts = mba.timer.starts,
                    nextStart;
                if (!starts) return;
                starts.some(function(start) {
                    if (mapTime < start) {
                        nextStart = start;
                        return true;
                    }
                });
                if (nextStart && (nextStart < mba.timer.stop)) { // console.log("t=", mapTime, "nextStart=" + nextStart, starts);
                    return nextStart;
                }
            },

            // updates "popupOnMap" if a trackinfo-property changes
            trackInfoPopup: function(trackinfo) {
                // console.log("LOG", trackinfo.value, trackinfo);
                if (!trackinfo.value) return;

                // trackinfo = trackinfo.value;
                this.popupOnMap(trackinfo.value);
            },


            /**
             * Activate a trackObject driven by mouse-event ;
             * (move-over, click, ...) 
             */
            trackObjSelect: function(e, clickevent) {
                
                var features = [];

                if (map.getLayer('tracks') || map.getLayer('tracks-select')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['tracks', 'tracks-select']
                    });
                }

                // Try nodes if no tracks selected
                if (!features.length) {
                    // Check waypoints/trackpoints    
                    if (map.getLayer('nodes')) {
                        features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes']
                        });
                    }
                    if (!features.length) return;

                    // popup-strategy 1: 
                    // Remove popup if pointer not on any feature
                    this.popupOnMap();
                    let wp = features[0];
                    if (this.wpid != wp.properties.id) {
                        this.wpid = wp.properties.id;
                        var msg = "WP/TP " + wp.properties.ab;
                        this.popupOnMap(msg); // console.log(msg, wp);
                    }
                    return;
                }

                // console.log("mouse-event-trackObjSelect", features, features[0].properties.id, mba._trackId );

                // NO info-action if INFO already visible
                // 
                if (mba._trackId == features[0].properties.id) {

                    if (clickevent) {
                        console.log("CLEAR trackObj", mba._trackId, features[0]);
                        mba.popupOnMap()
                        mba.trackFilterApply("");
                        mba._trackObj = null;
                        mba._trackId = null;
                    }
                    return;

                } else  {  // ??? 
                    // Change the cursor style as a UI indicator.
                    // map.getCanvas().style.cursor = 'pointer';
                }
                // 
                this.trackObjHilite(features[0]); 
            },    

            // SET global ctrl-variables 
            trackObjHilite: function(feature) {
                // Update GLOBAL objects
                mba._trackObj = feature;
                mba._trackId = mba._trackObj.properties.id;

                // temporary debug function 
                function toHtml(obj, title) {
                    var val, html = "" ; 
                    if (title) html = "<h3>"+title+"</h3>";
                    Object.keys(obj).forEach(function(key){
                        if (typeof obj[key] != "object") {
                            html = html + key + ":" + obj[key] + "</br>";
                        }  
                    })
                    return html;
                }

                // popup-strategy 2: 
                // Update and reconnect the this.popup to the map at new object
                // Trackdata with "Override dirty checking" 
                // if (mba._trackObj) {
                if (mba._trackId) {
                    console.log("Hiliting track: " + mba._trackId, mba._trackObj);

                    mba.trackFilterApply(mba._trackId);
                    mba.trackdata = {
                        "lnglat": mba._trackObj.geometry.coordinates,
                        "trackobj": mba._trackObj,
                        "open": true
                    }
                    var html = toHtml(mba._trackObj.properties, mba._trackId);
                    mba.popupOnMap(html);

                } else {

                    mba.popupOnMap();
                }


            },

            /*
             *   get wp-(tp-) info on CLICK-query
             */
            routeNodeSelect: function(e) {
                // Check waypoints(trackpoints)    
                var features = [];
                if (map.getLayer('nodes')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['nodes']
                    });
                }
                if (!features.length) return;
                // popup-strategy 1: 
                // Remove popup if pointer not on any feature
                let wp = features[0];
                if (this.wpid != wp.properties.id) {
                    this.wpid = wp.properties.id;
                    var msg = "WP/TP " + wp.properties.ab;
                    this.popupOnMap(msg); // console.log(msg, wp);
                } else {
                    this.popupOnMap();
                }
                return;
            },

            // DEBUG-utilities

            _checkObject: function(obj) {
                // console.log("CHECK", obj);
            },
            
            _checkTimer: function(timer) {
                // console.log("CHECK animationTIMER", timer.value);
            },
            _checkTrackdata: function(data) {
                //console.log("CHECK TRACKdata", data);
            },
            _checkTrackinfo: function(trackinfo) {
                // console.log("CHECK TRACKinfo", trackinfo);
            }
        });
    </script>

</dom-module>