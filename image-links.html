<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href = "../files-input/files-input.html">
<link rel="import" href = "../image-meta/exif-locations.html">

<link rel="import" href = "fab-area.html">

<!--
`image-links`
container for upload/presentation of geolocated images 

@demo demo/imagelinks.html 
-->

<dom-module id="image-links">

    <template>

        <style>

            :host {
                display: block;
                position: relative;
            }
            paper-item : {
                padding: 3px;
                border: 1;
            }

            .content : {
                @apply(--layout-horizontal);
                @apply(--layout-justified);
            }
        </style>

        <fab-area 
            ctrllabel = "[[ctrllabel]]"
            ctrldisable = "[[ctrldisable]]"
            checked = false>

            <div class="ctrl">
                <!-- Liste der nicht referenzierten -->
                <paper-listbox>
                    <template is="dom-repeat" items="{{_sessionunset}}">
                        <paper-item value="[[item]]" on-tap="_checkoutDocList">[[item]]</paper-item>
                    </template>    
                </paper-listbox>
                
            </div>        

            <div class="content">    
                <!--  -->
                <files-input
                    type="image"
                    multiple=true
                    loadedfiles="{{imageset}}">
                </files-input>    

                <!--<button> STORE </button>-->
                
                <!-- invisible  -->
                <exif-locations
                    imageset = "[[imageset]]"
                    locationmode = "geojson"
                    locations = "{{featureset}}"
                    nonlocated = "{{nonlocated}}">
                </exif-locations>
            
            </div>

        </fab-area>

    </template>

    <script>
        var wpscope; 

        Polymer({
            is: 'image-links',

            properties: {

                // checkIn: doc(img)Data collection
                imageset : {
                    type: Array ,
                    observer: '_checkinDocs'
                },

                // checkIn: linkPoints
                featureset : {
                    type: Object,
                    observer: '_refreshLayer'
                },

                // checkIn: names of NOT located docs(imgs) 
                nonlocated : {
                    type: Array,
                    observer: '_checkInUnset'
                },

                // checkOut : selected doc(img)
                supplieddoc : {
                    type: Object,
                    notify : true
                },

                // 
                location : {
                    type: String,
                    observer : 'testlocation'
                },



                _sessionset : {
                    type: Array,
                    value: []
                },

                // set of locations 
                _sessionfeatures : {
                    type: Object
                },

                // set of docs(imgs) NOT located in actual session
                _sessionunset : {
                    type: Array,
                    value: []
                    // observer: '_observeUnset'
                },

                // visibility of pointlayer
                visible : {
                    type : Boolean,
                    value : true
                },

                layerid : {
                    type : String,
                    value : "imglinks"
                },

                ctrllabel : {
                    type : String,
                    value : 'ToBeLocated'
                },

                ctrldisable : {
                    type : Boolean,
                    value : true
                }

            },

            behaviors: [
            ],           

            observers: [
                'addFeature(supplieddoc.location)',
                '_observeUnset(_sessionunset.length)'
            ],

            ready: function() {
                wpscope = this;
            },

            // 
            addFeature: function(locationFeature) { 
                if (locationFeature) {  
                    var docname = locationFeature.properties.name;  // console.log("Add Link to mapIndex for", docname);
                    var featureset = {
                        "type": "FeatureCollection",
                        "features": [locationFeature]
                    }
                    this._refreshLayer(featureset);

                    var index = this._sessionunset.indexOf(docname);
                    if (index > -1) {
                        this.splice('_sessionunset', index, 1);
                        // console.log("sessionUnSet updated", this._sessionunset);
                    }
                }
            },

            // Update the session's collection of processed docs(imgs)
            // from last added docs 
            _checkinDocs : function(docset) { // console.log("CheckIn docs(imgs)", docset);
                var firstDoc;

                docset.some( function(img){
                    if (!firstDoc) firstDoc = img;

                    if (!this._sessionset[img.name]) {
                        this._sessionset[img.name] = img; // .value;
                    }     
                }.bind(this));    

                if (firstDoc) { // console.log("activating doc(img) ", firstDoc.name, Object.keys(firstDoc)); 
                    this._checkoutDoc(firstDoc.name); 
                }    
            },

            // Checkout-1:  doc according to selected list-item
            _checkoutDocList : function(e) { 
                var item = e.target;   // console.log("item-value", item.value); // , item.value);
                this._checkoutDoc(item.value); 
            },

            // Checkout-2:  doc according to 'tapped' feature
            _checkoutDocMap : function (feature) {  
                var id = feature.properties.name; // console.log("clicked at locator of  image " + id, feature.properties); 
                // Send the image 
                this._checkoutDoc(id); 
            },

            /**
             *  Supply image to other APP-Components 
             */            
            _checkoutDoc : function(imgid) { 
                var imgnames = Object.keys(this._sessionset);  // console.log("SUPPLY from", imgnames, imgid) ;
                imgnames.some(function(imgname){
                    if (imgid == imgname) {  
                        var img = this._sessionset[imgname]; // console.log("Found img [" + imgname + "]"); // , img); // , img.value);
                        this.supplieddoc = img;
                        return;
                    } 
                }.bind(this));   
            },


            hoverAction : function (feature) {
                console.log("hovered ", feature); 
            },

            // 
            _checkInUnset : function (nonlocated) { // console.log("FRESH nonlocated docs", nonlocated);
                if (nonlocated.length) {
                   this._sessionunset = this._sessionunset.concat(nonlocated); 
                }   
            },

            // 
            _observeUnset: function(count) { // console.log("UnSet",count);
                if (count) {    
                   this.ctrldisable = false; 
                } else {
                   this.ctrldisable = true; 
                }
            },

            // generic click-listener
            _mapclickListener : function(e) {
                var f = wpscope._mapeventListener(e); 
                if (!f) return; // console.log("clicked",f);

                wpscope._checkoutDocMap(f);
            }, 

            // generic hover-listener
            _maphoverListener : function(e) {
                var f = wpscope._mapeventListener(e); 
                if (!f) return; 
                wpscope.hoverAction(features[0]);
            }, 

            // generic select-event-translator
            _mapeventListener : function(e) {
                var st = wpscope._layerStatus(); 
                if (!st.layer) return ;  

                var features = map.queryRenderedFeatures(e.point, {
                    layers: [st.id]
                });
                if (!features || !features.length) return;   
                return features[0];
            },    

            // Test the layer status
            _layerStatus : function(layid) {
                if (!layid) layid = this.layerid;
                var status = {
                    id : layid,
                    layer : map.getLayer(layid),
                    src :  map.getSource(layid)
                };  // console.log("_layerStatus", status);  
                return status;  
            },

            // Simple fitbounds for point-features
            _fitBounds : function(features, padding) {
                if (padding== null) padding = 20;

                if (features.features) features = features.features; // if a feature-set was passed

                var coord0 = features[0].geometry.coordinates;
                var bounds = features.reduce(function(bounds, feature) {
                    var coord = feature.geometry.coordinates;
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coord0, coord0));

                map.fitBounds(bounds, {
                    padding: 30
                }); 
            },     

            // 
            _refreshLayer: function(rawdata) {
                
                if (!rawdata || !rawdata.type) {
                    console.log("BREAK. 1  no location data attached!");
                    return;  
                } 

                // 1. 
                var _sessionfeatures = rawdata; 
                if (!_sessionfeatures.features) {
                    _sessionfeatures = {
                        "type": "FeatureCollection",
                        "features": [_sessionfeatures]
                    }
                }    
                if (!_sessionfeatures.features.length) {
                    console.log("BREAK. 2  no location data attached to ", rawdata);
                    return;  
                } 

                // 2. Update dataSource
                var st = this._layerStatus();  // console.log("_refresh Layer " + st.id, st, rawdata, _sessionfeatures); 

                if (!st.src) {
                   
                    this._sessionfeatures = _sessionfeatures;
                    map.addSource(st.id, {
                        "type": "geojson",
                        "data": _sessionfeatures
                    });

                } else { 

                    this._sessionfeatures.features = this._sessionfeatures.features.concat(_sessionfeatures.features); 
                    // console.log("new, all features", _sessionfeatures, this._sessionfeatures) ; 
                    
                    map.getSource(st.id).setData(this._sessionfeatures);
                    
                } // console.log("UPDATED imglinks-src with ", rawdata);
                
                // 3. Check/Update "LinkLayer"
                if (!st.layer) {
                    var vis = "none";
                    if (this.visible) vis = "visible";

                    map.addLayer({
                        "id": st.id,
                        "type": "circle",
                        "source": st.id,
                        "layout" : {
                            "visibility": vis
                        },
                        "paint": {
                            "circle-radius": 8,
                            "circle-color": "#FFFFFF",
                            "circle-stroke-width": 2,
                            "circle-stroke-color": "#B42222"
                        },
                        "filter": ["==", "$type", "Point"],
                    }); // console.log("added img-link-layer", map.getLayer(st.id) ); 

                }    

                // 4. Update viewPort to inculde last loaded locations  
                //    HILITING the last linkPoint
                var fitdata = this._sessionfeatures,
                    ff = fitdata.features;
                if (ff.length < 2) { // fit to a certain buffer around point !!
                    var center = ff[0];
                    var radius = 5;
                    var steps = 10;
                    var units = 'kilometers';
                    var pp = turf.explode(turf.circle(center, radius, steps, units));
                    ff = ff.concat(pp.features);   
                } else {
                    // console.log("fitting to data:", ff); 
                }

                this._fitBounds(ff);

                // 5. 
                if (this._checkoutDocMap) {
                     map.off('click', this._mapclickListener);
                     map.on('click', this._mapclickListener);
                } 

                if (this.hoverAction) {
                     map.off('hover', this.hoverListener);
                     map.on('hover', this.hoverListener);
                }

                return st;
            }

        });
    </script>
</dom-module>