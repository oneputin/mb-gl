<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-flex-layout/iron-flex-layout.html">

<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../iron-collapse/iron-collapse.html">
<link rel="import" href="../paper-item/paper-item.html">
<link rel="import" href="../paper-listbox/paper-listbox.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href = "../files-input/files-input.html">
<link rel="import" href = "../image-meta/exif-locations.html">

<link rel="import" href = "gui-area.html">


<!--
`image-links`
container for 
- generation/management of map-links to docs/images (to be) gelocated/presented on a map 
    - uploaded "internally" by filedialog or dropzone 
    - supplied from outside
- a ToolSet for      

@demo demo/imagelinks.html 
-->

<dom-module id="image-links">

    <template>

        <style>

            :host {
                display: block;
                position: relative;
            }
            paper-item : {
                padding: 3px;
                border: 1;
            }

            .placeholder {
                padding: 3px;
                margin: 2px;
                border: solid 1px red;
            }

            .content : {
                @apply(--layout-horizontal);
                @apply(--layout-justified);
            }
        </style>

        <!-- gui-area = part of the map area (or whole map) may be the dropbox -->
        <gui-area 
            id = "imgctrl"
            ctrllabel = "[[ctrllabel]]"
            ctrldisable = "[[ctrldisable]]"
            open = "{{toolstatus}}">

            <!-- SLOT-1 -->
            <div class="ctrl">
                <!-- Liste der primÃ¤r nicht referenzierten images -->
                <paper-listbox>
                    <template is="dom-repeat" items="{{_sessionunset}}">
                        <paper-item value="[[item]]" on-tap="_checkoutDocFromList">[[item]]</paper-item>
                    </template>    
                </paper-listbox>
            </div>        

            <!-- SLOT-2 -->
            <div class="content">    
                
                <div class="placeholder">
                    Placeholder DB QUERY & STORE
                </div>
                
                <!-- try to extend to 100% of parent container -->
                <div class="placeholder">
                    Placeholder DRAGnDROP
                    <files-box
                        type="image"
                        multiple=true
                        loadedfiles="{{imageset}}">
                    </files-box>    
                </div>
                
                <files-input
                    type="image"
                    multiple=true
                    loadedfiles="{{imageset}}">
                </files-input>    

            </div>
        </gui-area>

        <!--<files-box  
            filetype="image" 
            loadedfiles="{{imageset}}" 
            boxsize="300"> 
        </files-box> -->

        <!-- always invisible background-function-element  -->
        <exif-locations
            imageset = "[[imageset]]"
            locationmode = "geojson"
            locations  = "{{featureset}}"
            nonlocated = "{{nonlocated}}">
        </exif-locations>

    </template>

    <script>
        var wpscope; 

        Polymer({
            is: 'image-links',

            properties: {

                // checkIn: doc(img)Data collection
                imageset : {
                    type: Array ,
                    observer: '_imagesetRefresh'
                },

                // checkIn: linkPoints
                featureset : {
                    type: Object,
                    observer: '_refreshMap' 
                },

                // checkIn: names of NOT located docs(imgs) 
                nonlocated : {
                    type: Array,
                    observer: '_checkInUnset'
                },

                // checkIn/checkOut : selected doc(img)
                docselected : {
                    type: Object,
                    observer: 'logselected',
                    notify : true
                },

                // 
                location : {
                    type: String,
                    observer : 'testlocation'
                },

                /**
                 * Container of docs "in use" during this session
                 */
                _sessionsetDocs : {
                    type: Object,
                    value: {},
                    observer : '_sessionlog'
                },

                // set of locations 
                featuresetRefresh : {
                    type: Object
                },

                /**
                 * Container of docs(imgs) NOT geolocated in actual session
                 */
                _sessionMarkers : {
                    type: Array,
                    value: []
                    // observer: '_observeUnset'
                },
                /**
                 * Container of docs(imgs) NOT geolocated in actual session
                 */
                _sessionunset : {
                    type: Array,
                    value: []
                    // observer: '_observeUnset'
                },

                // visibility of pointlayer
                visible : {
                    type : Boolean,
                    value : true
                },

                layerid : {
                    type : String,
                    value : "imglinks"
                },

                ctrllabel : {
                    type : String,
                    value : 'ToBeLocated'
                },

                ctrldisable : {
                    type : Boolean,
                    value : true
                },

                toolstatus : {
                    type: Boolean,
                    value: true,
                    notify : true,
                    observer: 'logToolStatus'
                }

            },

            behaviors: [
            ],           

            observers: [
                'setImgLink(docselected.geojson)',
                '_observeUnset(_sessionunset.length)'
            ],

            logselected: function(imgObj) {
                // console.log("logselected", imgObj.name);
            },
            _sessionlog : function(set) {
                console.log("_sessionlog", set);
            },

            ready: function() {
                wpscope = this;
                //map.showTileBoundaries();
            },

            logToolStatus : function(toolstatus) {
                // other "peripheral" gui-elements should be "hidden"(closed) during "tooling" 
                console.log("toolstatus", toolstatus);
            },

            // Append link to 
            setImgLink: function(linkFeature) { 

                if (!linkFeature) return;   
                // A. add link to map
                var featureset = {
                    "type": "FeatureCollection",
                    "features": [linkFeature]
                }

                this._refreshLinks(featureset); 

                // B. remove entry from 
                var docname = linkFeature.properties.name;  console.log("Add Link to mapIndex for", docname, linkFeature);
                var index = this._sessionunset.indexOf(docname);
                if (index > -1) {
                    this.splice('_sessionunset', index, 1);  // console.log("sessionUnSet updated", this._sessionunset);
                }
            },

            // Update the "_sessionSet-object" ( =  docs(fi. img's) actually "in use") 
            // from collection of "last added docs" 
            _imagesetRefresh : function(docCollection) { 
                if (!docCollection || !docCollection.length)  return; 

                this.toolstatus = true;
                this.toolstatus = false; // dbl-zuordnung ensures that false is evaluated !! 

                var firstDoc;
                var sessionset = this._sessionsetDocs; 

                docCollection.forEach( function(img){ // console.log("CheckIn doc", img);
                    if (!firstDoc) firstDoc = img;

                    if (!sessionset[img.name]) {
                        sessionset[img.name] = img; // .value;
                    }     
                });   

                this._sessionsetDocs = sessionset;  console.log("Refreshed this._sessionsetDocs", this._sessionsetDocs);

                if (firstDoc && (docCollection.length < 2)) { // console.log("activating doc(img) ", firstDoc.name, Object.keys(firstDoc)); 
                    this._checkoutDoc(firstDoc.name); 
                }    
            },

            // Checkout-1:  from list of non-geocoded docs(images)
            _checkoutDocFromList : function(e) { 
                var item = e.target;   // console.log("item-value", item.value); // , item.value);
                this._checkoutDoc(item.value); 
            },

            // Checkout-2:  according to name-property of 'tapped' point-feature
            _checkoutDocFromMap : function (feature) {  
                var id = feature.properties.name; // console.log("clicked at locator of  image " + id, feature.properties); 
                this._checkoutDoc(id); 
            },

            /**
             *  Notify id of selected doc to be used by other APP-Components 
             */            
            _checkoutDoc : function(imgid) { // console.log("_checkoutDoc", imgid, this._sessionsetDocs); 
                if (!this._sessionsetDocs) return;  
                
                var imgnames = Object.keys(this._sessionsetDocs);  // console.log("SUPPLY from", imgnames, imgid) ;
                imgnames.some(function(imgname){
                    if (imgid == imgname) {  
                        var imgObj = this._sessionsetDocs[imgname];   console.log("Selected imgObj named [" + imgname + "]"); // , img); // , img.value);
                        this.docselected = imgObj;
                        return;
                    } 
                }.bind(this));   
            },


            hoverAction : function (feature) {
                console.log("hovered ", feature); 
            },

            // 
            _checkInUnset : function (nonlocated) { // console.log("FRESH nonlocated docs", nonlocated);
                if (nonlocated.length) {
                   this._sessionunset = this._sessionunset.concat(nonlocated); 
                }   
            },

            // 
            _observeUnset: function(count) { // console.log("UnSet",count);
                if (count) {    
                   this.ctrldisable = false; 
                } else {
                   this.ctrldisable = true; 
                }
            },

            // generic click-listener
            _mapClickListener : function(e) {
                var f = wpscope._mapeventListener(e); 
                if (!f) return; // console.log("clicked",f);

                wpscope._checkoutDocFromMap(f);
            }, 

            // generic hover-listener
            _mapHoverListener : function(e) {
                var f = wpscope._mapeventListener(e); 
                if (!f) return; 
                wpscope.hoverAction(features[0]);
            }, 

            // generic select-event-translator
            _mapeventListener : function(e) {
                var st = wpscope._layerStatus(); 
                if (!st.layer) return ;  

                var features = map.queryRenderedFeatures(e.point, {
                    layers: [st.id]
                });
                if (!features || !features.length) return;   
                return features[0];
            },    

            // Test the layer status
            _layerStatus : function(layid) {
                if (!layid) layid = this.layerid;
                var status = {
                    id : layid,
                    src :  map.getSource(layid),
                    layer : map.getLayer(layid)
                };  // console.log("_layerStatus", status);  
                return status;  
            },

            // Simple fitbounds for point-features
            _fitBounds : function(features, padding) {
                if (padding== null) padding = 20; // pixels ?

                if (features.features) features = features.features; // if a feature-set was passed

                var coord0 = features[0].geometry.coordinates;
                var bounds = features.reduce(function(bounds, feature) {
                    var coord = feature.geometry.coordinates;
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coord0, coord0));

                map.fitBounds(bounds, {
                    padding: 30
                }); 
            },     

            // 
            _refreshMap: function(imagesetLocated) {
                
                map.showTileBoundaries = true; // for DEBUG 

                var imageset = this.imageset;  
                // console.log("_refreshMap ImageSet Raw",  imageset); 
                // console.log("_refreshMap ImageSet Located", imagesetLocated); 

                var featureSet = imagesetLocated.geojson; 

                featureSet.features.forEach(function(f){
                    if (!f.properties.img) {
                        var name = f.properties.name,
                            img ; 
                        imageset.some(function(obj){
                            if (obj.name == name) {
                                img = obj.value;
                                return;
                            }     
                        });
                        f.properties.img = img;
                    }
                });

                console.log("_refreshMap FeatureSet", featureSet); 
                
                this._refreshLinks(featureSet);
            },

            // Refresh the "src"(content) of "explored" data-layers 
            // creates layers if not yet existing 
            _refreshLinks: function(rawdata) {
                
                if (!rawdata || !rawdata.type) {
                    console.log("BREAK. 1  no location data attached!");
                    return;  
                } 

                // 1. ReCheck structure as featureset
                var featuresetRefresh = rawdata; 
                
                if (!featuresetRefresh.features) {
                    featuresetRefresh = {
                        "type": "FeatureCollection",
                        "features": [featuresetRefresh]
                    }
                }    
                if (!featuresetRefresh.features.length) {
                    console.log("BREAK. 2  no location data attached to ", rawdata);
                    return;  
                } 

                var zoomFunction = this._fitBounds; 

                // Update viewPort to include last loaded locations  
                function zoomToFeatures(zoomFeatures) {
                    var ff = zoomFeatures;
                    var radius = this.radius ? this.radius : 5; 

                    if (ff.length < 2) { // fit to a certain buffer around point !!
                        // HILITING the last linkPoint in suitable Umkreis with "radius" km 
                        var center = ff[0];
                        var units = 'kilometers';
                        var radius = radius;
                        var steps = 10;
                        var pp = turf.explode(turf.circle(center, radius, steps, units));
                        ff = ff.concat(pp.features);   
                    }
                    zoomFunction(ff);
                }  

                // 2. Check/Create/Update "LinkLayer"-Data

                var st = this._layerStatus();  // console.log("_refresh Layer " + st.id, st, rawdata, featuresetRefresh); 
                var addedFeatures = [];

                if (!st.layer) {   console.log("FIRST link-layer-setup from", rawdata);

                    addedFeatures = this._createLayers(st.id, featuresetRefresh);
                    setTimeout( function() {
                        // map.setZoom(map.getZoom() + 0.1); 
                        zoomToFeatures(addedFeatures);
                    }, 500);  
              
                }  else {          // Update dataSource

                    var oldFeatures = this._sessionsetMap.features,
                        tryFeatures = featuresetRefresh.features; // console.log("old", oldFeatures) ; console.log("try", tryFeatures) ;

                    // Filtering only features with a new name  
                    var addedFeatures = tryFeatures.filter(function(item){
                        var isOld = false;
                        oldFeatures.some(function(old){
                            if (old.properties.name === item.properties.name) {
                                isOld = true;
                                return;
                            } 
                        })
                        return !isOld;
                    }); // console.log("really new features", addedFeatures); 
                    if (!addedFeatures.length) return;   

                    this._sessionsetMap.features = this._sessionsetMap.features.concat(addedFeatures); 

                    // console.log("new, all features", featuresetRefresh, this._sessionsetMap) ; 
                    map.getSource(st.id).setData(this._sessionsetMap);

                    zoomToFeatures(addedFeatures); 

                }

                // 3.  
                if (this._checkoutDocFromMap) {
                     map.off('click', this._mapClickListener);
                     map.on('click', this._mapClickListener);
                } 

                if (this.hoverAction) {
                     map.off('hover', this.hoverListener);
                     map.on('hover', this.hoverListener);
                }

                return {features: addedFeatures} ;
            },

            // Create an suitably "clustering" layer
            _createLayers : function(srcname, featureset) {    

                this._sessionsetMap = featureset;
                
                // 
                var mode = "cluster";
                var vis = "none";
                if (this.visible) vis = "visible";

                // A. SOURCE 
                map.addSource(srcname, {
                    "type": "geojson",
                    "data": featureset,
                    "cluster": true,
                    "clusterMaxZoom": 14, // Max zoom to cluster points on
                    "clusterRadius": 50 // Radius of each cluster when clustering points (defaults to 50)
                    
                });

                // B. Create LAYER(s) of SOURCE
                if (mode != "cluster") {  // B.1  Simple PointLayer

                    map.addLayer({
                        "id": srcname,
                        "type": "circle",
                        "source": srcname,
                        "layout" : {
                            "visibility": vis
                        },
                        "paint": {
                            "circle-radius": 8,
                            "circle-color": "#FFFFFF",
                            "circle-stroke-width": 2,
                            "circle-stroke-color": "#B42222"
                        },
                        "filter": ["==", "$type", "Point"],
                    }); // console.log("added img-link-layer", map.getLayer(srcname) ); 

                } else {                  // B.2 LayerGROUP with clusters (to best visualize the content of SOURCE) 

                    var elem = this;

                    // Cluster-Symbol (BG) 
                    map.addLayer({
                        id: "clusters",
                        type: "circle",
                        source: srcname,
                        filter: ["has", "point_count"],
                        paint: {
                            "circle-color": {
                                property: "point_count",
                                type: "interval",
                                stops: [
                                    [0, "#51bbd6"],
                                    [5, "#f1f075"],
                                    [20, "#f28cb1"],
                                ]
                            },
                            "circle-radius": {
                                property: "point_count",
                                type: "interval",
                                stops: [
                                    [0, 20],
                                    [5, 30],
                                    [20, 40]
                                ]
                            }
                        }
                    });

                    // Cluster-Label (FG)
                    map.addLayer({
                        id: "cluster-count",
                        type: "symbol",
                        source: srcname,
                        filter: ["has", "point_count"],
                        layout: {
                            "text-field": "{point_count_abbreviated}",
                            "text-font": ["DIN Offc Pro Medium", "Arial Unicode MS Bold"],
                            "text-size": 12
                        }
                    });

                    // NON-clustered points
                    map.addLayer({
                        id: srcname,
                        type: "circle",
                        source: srcname,
                        filter: ["!has", "point_count"],
                        paint: {
                            "circle-color": "#11b4da",
                            "circle-radius": 4,
                            "circle-stroke-width": 1,
                            "circle-stroke-color": "#fff"
                        }
                    });

                    // 
                    map.on('zoomend', function(){
                        elem._refreshMarkers(srcname);
                    });

                    map.on('moveend', function(){
                        elem._refreshMarkers(srcname);
                    });
                }

                // C. Return features added at creationtime
                return featureset.features; 

            },    

            // Show markers only for features of a layer 
            // that are actually rendered (visible mapextent)  
            _refreshMarkers : function(layername, ms_debounce) {
                if (!layername) layername = 'unclustered-point';
                if (!ms_debounce) ms_debounce = 500; 
                
                this.debounce("markers", function() {
                    
                    var zoom = map.getZoom();

                    var features = map.queryRenderedFeatures({
                        layers: [layername]
                    });  // console.log("_refreshMarkers. At zoom=" + zoom + " for", features.length + " feature(s)");

                    features = this.getuniqueFeatures(features, "name");

                    // ? Heuristics of marker.management ?  
                    // Comparing "new" features and "previous" markers  

                    // H1:  
                    var n1 = features.length,
                        n2 = this._sessionMarkers.length; // console.log(n1,n2, features, this._sessionMarkers); 
                    if (n1 == n2) {
                        // H2: 
                        
                        return; 
                    }

                    // Refresh required !!
                    this._sessionMarkers.forEach(function(marker){
                        marker.remove(); 
                    })
                    this._sessionMarkers = [];

                    if (features.length)  {
                        
                        this._createMarkers(features);
                    }

                }, ms_debounce); 
            },

            // MB-specific tool to remove duplicates !!
            getuniqueFeatures: function(features, idname) {
                if (!idname) idname = "name";
                var uniqs = [], ids = [], id = "";

                features.forEach(function(f) {
                    id = f.properties[idname];
                    if (!id || (ids.indexOf(id) < 0)) {
                       ids.push(id);
                       uniqs.push(f);
                    }   
                });
                return uniqs; 
            },


            // Create Markers used for display of points at "suitable" scales
            // showing a thumbNail of geocoded images
            _createMarkers: function(features) {
                
                if (!features || !features.length) {  // console.log("ALERT. NO features to refresh markers from"); 
                    return;
                }  // console.log("Features to create Markers from:", features);

                // Function activated after marker-click
                var linkFunction = this._checkoutDoc;

                // Sample function of dom4popup creation 
                function dom4pop(properties) {
                    var domContent = window.document.createElement('div');
                        domContent.style.backgroundColor = "yellow";
                        domContent.style.padding = "5px";
                        
                    var title = window.document.createElement('h3');
                        title.innerText = properties.name;    
                    var popimg = window.document.createElement('img');
                        popimg.style.width = "400px";
                        popimg.src = properties.img;
                    domContent.append(title);    
                    domContent.append(popimg);    
                    return domContent; 
                };

                function makeMarker(imgUrl, iconSize) {
                    var el = document.createElement('div');
                    el.className = 'marker';
                    el.style.cursor = "pointer";
                    el.style.border = '1px solid #777';
                    el.style.borderRadius = '4px';
                    el.style.width  = iconSize[0] + 'px';
                    el.style.height = iconSize[1] + 'px';
                    el.style.backgroundImage = "url('"+imgUrl+"')";
                    el.style.backgroundSize = "cover";
                    return el;
                };

                function makePopup(properties) {
                    var popup = new mapboxgl.Popup({offset: 25});
                
                    var text; // = properties.name; 
                    var html; // ="<h3> Image name</h3>" + properties.name;
                    var domContent = dom4pop(properties); 

                    if (text)   popup.setText(text);
                    if (html)   popup.setHTML(html);
                    if (domContent) popup.setDOMContent(domContent);

                    return popup;    
                };    


                var log = []; // tracks processed features
                
                features.forEach(function(markerpnt) {
                    // create a DOM element for the marker
                    var name     = markerpnt.properties.name,
                        bgimg    = markerpnt.properties.img,
                        iconSize = markerpnt.properties.iconsize;

                    if (!iconSize) iconSize = [50,50];

                    // if (bgimg && (log.indexOf(name) < 0)) {
                    if (bgimg) {    

                        log.push(name);
                        
                        var marker = makeMarker(bgimg, iconSize, markerpnt.properties);

                        // add marker to map
                        var mbMarker = new mapboxgl.Marker(marker, {offset: [-iconSize[0] / 2, -iconSize[1] / 2]})
                            .setLngLat(markerpnt.geometry.coordinates)
                            .addTo(map);

                        this._sessionMarkers.push(mbMarker); 

                        // setup link functions    
                        if (linkFunction)  {
                            marker.addEventListener('click', function() {
                                linkFunction(markerpnt.properties.name);
                            }); 
                        } else if (dom4pop)  {
                            var popup  = makePopup(markerpnt.properties);  
                            mbMarker.setPopup(popup);
                        }    
                    }
                }.bind(this)); console.log(features.length + " Marker(s) created ", log); 
            }

        });
    </script>
</dom-module>