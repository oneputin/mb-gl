<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="../neon-animation/neon-animations.html">
<link rel="import" href="../kml-json/kml-json.html">
<link rel="import" href="../paper-fab/paper-fab.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href="mb-api.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="mb-info-drag.html">
<link rel="import" href="mb-layer-animation.html">

<!--
`mb-slide`
wraps a mb-gl-overlay based on feature-geosource (geojson) and links to mb-gl-map 
- additional fab for zoom to slide
- interactive queries (f.i. map-click) produce slideinfo-object 
- optional layer-bound POPUP (paper-dialog) to view slideinfo ontop of map  

@demo demo/slidemap.html 
-->

<dom-module id="mb-slide">
    <template>

        <style>
            :host {
                display: block;
            }

            paper-dialog {
                border: 2px solid;
                border-color: var(--paper-green-500);
                background-color: var(--paper-light-green-50);
                color: var(--paper-green-500);
            }
            
            #slidezoom {
                position:absolute;
                right:5px;
                top:5px;
                opacity: 0.8; 
            }

            #loadspinner {
                position:absolute;
                right: 0px;
                width:  66px;
                height: 66px;
                --paper-spinner-color: var(--paper-pink-500);
                opacity: 1; 
            }

        </style>

        <!-- Async query for new {{slidedata}} -->
        <template is="dom-if" if="[[serviceflag]]">
            <kml-json 
                url     = "[[serviceurl]]"
                service = "[[_servicequery]]"
                query   = "[[_clientquery]]"
                msg = "{{msg}}"
                geojson = "{{slidedata}}">
            </kml-json>
        </template>

        <!-- 2 elements optically grouped by css -->
        <paper-spinner-lite 
            id="loadspinner" 
            alt="loading next slide" active>
        </paper-spinner-lite>

        <paper-fab 
            id="slidezoom" 
            class="fab" 
            icon="all-out" 
            title="heart" 
            on-tap="zoomslide">
        </paper-fab>

        <mb-info-drag 
            carddata="[[slidecard]]">
        </mb-info-drag>

        <content>
        </content>    

    </template>

    <script>

        var slidesetup = {

            serviceurl: "http://iimaps.de/npp/if_slides.php",

            serviceparams: {
                mapclient: "ol2",
                card: "default",
                slide: "basin"
            },

            cbox: {
                type: String,
            },

            /**
             * "static" layer-ctrl of overlay 
             */
            layer: {
                "id": "slide",
                "type": "fill",
                "source": "slide",
                "layout": {},
                'paint': {
                    'fill-color': '#088',
                    'fill-opacity': 0.3,
                    'fill-outline-color': '#000'
                }
            }

        };

        Polymer({
            is: 'mb-slide',

            properties: {
                /**
                 *  map-object of related mb-gl-map
                 */
                /*map: {
                    type: Object,
                },*/

                /**
                 * basic server-url of overlay-dataservice
                 */
                serviceurl: {
                    type: String
                },

                /**
                 * "static" parameters qualifying the overlay-dataservice
                 */
                serviceparams: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /*
                 *  Flag to enable/disable automatic sliderequests
                 */
                serviceflag: {
                    type: Boolean,
                    value: false,
                    notify: true,
                },

                /**
                 * location for service-query.
                 * default: actual map-center : Alternatively 
                 *  - after stop of map-move   or 
                 *  - continuously during map-move 
                 */
                target: {
                    type: String //, observer: 'locationrequest'
                },

                msg: {
                    type: String,
                    observer: 'showmsg'
                },

                _servicequery: {
                    type: Object
                },

                // clientQuery
                _clientquery: {
                    type: Object,
                    value: {
                        "structure": "doc"
                    }
                },

                /**
                 * raw response from slide-server. 
                 * geometries + properties of all slide-faetures
                 */
                slidedata: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /**
                 * animation of slides coming in 
                 */
                slideanimation: {
                    type: Object
                },

                /*
                 *  customizable transformation of one features properties(attributes) for output
                 */
                preformatter: {
                    type: Function,
                    value: function() {
                        return function(x) {
                            var s = "";
                            // console.log(x.properties.name, x.properties)
                            return x.properties.name;
                            // return s;
                        };
                    }
                },

                /*
                 *  JSONstring of array of feature-properties after formatting by 'preformatter'
                 */
                slideinfo: {
                    type: String,
                    notify: true,
                    observer: 'createCarddata'
                },

                /*
                 *  bbox of last-updated-slide
                 */
                slidebox: {
                    type: Object
                },
                /*
                 *  ids of all features building the actual slide 
                 *  (as links for following feature-actions, fi. requests to feature-databases)
                 */
                slidekeys: {
                    type: String,
                    notify: true
                },

                // mapbox-layer-ctrl used to create slideLayer
                slidectrl: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /*
                 *  name of basemap-layer to insert the slide below 
                 */
                insertslidebelow: {
                    type: String,
                    value: "water"
                }

            },

            behaviors: [
                Mbb.MapBehavior,
                Mbb.LayerAnimation
            ],

            observers: [
                'locationrequest(target, serviceflag)',
                //'servicerequest(serviceflag, serviceparams.card, serviceparams.slide)',
                'serviceresponse(slidedata.*)',
                'requestlog(serviceurl, _servicequery.*)'
            ],

            showmsg : function(msg){
                console.log("server-msg", msg)
            },

            requestlog: function(a, b) {
                // console.log("requestlog", a, b, b.value);
            },

            attached: function() {

                // var serviceparams 
                this.serviceparams = Object.assign({}, slidesetup.serviceparams, this.serviceparams);
                // this.serviceparams = serviceparams;

                this.slidectrl = Object.assign({}, slidesetup.layer, this.slidectrl);
                // this.slidectrl = layerctrl;

                if (0) {
                    console.log("slide service: " + this.serviceurl, this.serviceparams);
                    console.log("slide layer:", this.slidectrl);
                }

                // Trigger FIRST request 
                this.serviceurl = slidesetup.serviceurl;
            },

            locationrequest: function(target, serviceflag) {
                this.serviceparams.cbox = target; 
                this.servicerequest(serviceflag);
            },

            /**
             *   Action triggers new slide-request after any of the service-parameters had changed
             *   mainly : cbox (mapcenter)
             */
            servicerequest: function(serviceflag) {
                if (!serviceflag || !this.serviceparams.cbox) return;

                var servicelayer = this.slidectrl.id,
                    animation = this.slideanimation;

                this.$.loadspinner.active = true;

                this.debounce('request', function() {
                    // Trigger the ServiceIF (<kml-json>) toggling _servicequery 

                    var servicequery = this.serviceparams;

                    servicequery["time"] = Date.now();
                   
                    // console.log("Trigger SERVICEREQUEST as:", servicequery, "to " + this.serviceurl);
                    this._servicequery = {};
                    this._servicequery = servicequery;

                    // Hide actually active slide (tacked or animated ??)
                    if (map && map.getLayer(servicelayer)) {
                        map.setLayoutProperty(servicelayer, 'visibility', 'none');
                        // this.runLayerAnimation(animation, "hide");
                    }
                }, 300)
            },

            /*
             *   action triggered after (slide)-server returns new data   
             */
            serviceresponse: function(rawslidedata) {
                // console.log("RAW serviceresponse", rawslidedata) 
                this.$.loadspinner.active = false;
                if (!map || (typeof rawslidedata != "object") || !Object.keys(rawslidedata).length) return;
                // console.log(typeof rawslidedata, rawslidedata); // , map);

                var slidedata;
                if (rawslidedata.value) {
                    slidedata = rawslidedata.value; // 
                } else {
                    slidedata = rawslidedata;
                }
                // console.log(typeof slidedata, slidedata); // , map);
                if (!slidedata.features || !slidedata.features.length) return;
                // if (!slidedata || !slidedata.length) return;

                this.slidedata = slidedata;
                this.slideindex = null;
                // console.log("new slide data:", slidedata);

                this.slidebox = this.getBoundingBox(slidedata.features);

                this.slidekeys = this.getFeatureKeys(slidedata);
                // console.log("ServiceResponse [slidekeys,slidedata,slidebox]:", this.slidekeys, slidedata, this.slidebox);

                var slidesource = this.slidectrl.source,
                    slidename = this.slidectrl.id;

                // Specifically mb-gl: ? Test for SOURCE  (not for layer) ?
                if (!map.getSource(slidesource)) {
                    // create NEW slidelayer
                    this.createSlideLayer();

                } else {
                    // Modify slide-data ( = insert NEW slide)     
                    if (this.slideanimation) {  
                        // insert data as ANIMATED 
                        this.slideanimation.layerdata = slidedata; // console.log("slideanimation", this.slideanimation);
                        this.runLayerAnimation(this.slideanimation, "show");

                    } else {
                        // insert data as STAMPED 
                        map.getSource(slidesource).setData(slidedata);
                        map.setLayoutProperty(slidename, 'visibility', 'visible');
                    }

                }
            },

            /*
             *  create a layer for slide-ctrl and slide-data are prepared 
             */
            createSlideLayer: function() {

                var that = this,
                    slidedata = this.slidedata,
                    slidectrl = this.slidectrl,
                    insertlayer = this.insertslidebelow,
                    slidesource = slidectrl.source;
                // console.log("createSlideLayer for source",slidesource, slidedata);     
                // A. add slide-source to map    
                map.addSource(slidesource, {
                    type: 'geojson',
                    data: slidedata
                });

                // B. create slide-layer with insert-point in baseLayerStack
                map.addLayer(slidectrl, insertlayer);
                // ======================================

                // C. setup slide-in-animation 
                if (this.setupLayerAnimation) {
                    this.slideanimation = this.setupLayerAnimation(slidectrl, "viewpath");
                }

                // D. setup events to observe on slide-layer
                map.on('click', function(e) {
                    // console.log("clicked", e, e.point);
                    that.slideinfoget(e.point);
                });

                // Indicate that the slides are clickable
                // by changing the cursor style to 'pointer'.
                map.on('mousemove', function(e) {
                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [slidectrl.id]
                    });
                    map.getCanvas().style.cursor = (features.length) ? 'pointer' : '';
                });

                /* Optional for autotracing of center-info
                map.on('render', function(e) {  // 
                    that.debounce('rendering', function() {  // was called too often 
                        var ll = that.map.getCenter();
                        var c = e.target._canvas;
                        console.log(ll, c);
                        // qpoint = new mapboxgl.Point(c.width / 2, c.height / 2);
                        // that.slideinfoget(e.point);
                    }, 300);
                }); */
            },

            // interactive feature-query at click-location 
            // (?? or at mapcenter after render-event ??)	
            slideinfoget: function(qpoint) {
                if (!qpoint) return;
                var formatter = this.preformatter,
                    slidename = this.slidectrl.id;
                // console.log("slideinfoget for pnt, formatter", qpoint, formatter);

                var features = map.queryRenderedFeatures(qpoint, {
                    layers: [slidename]
                }); // console.log('slideinfoget-qpoint', qpoint, features);

                if (!features.length) {
                    this.slideinfo = "slide-query outside slide-area!";
                } else {
                    var frameindex, slideinfo = [];
                    features.forEach(function(item, index) {
                        if (item.id) frameindex = item.id;
                        else frameindex = index;
                        slideinfo[frameindex] = formatter(item);
                    })

                    this.slideinfo = slideinfo;
                }
                // console.log("slideinfoget", this.slideinfo);
            },

            /**
             * 
             */
            createCarddata: function(item) {
                if (!item) return;
                // console.log("createCarddata of:", item);
                var txt = typeof item == "string" ? item : JSON.stringify(item, null, '\n');
                this.slidecard = {
                    "html": '<pre><code id="popupbody">' + txt + '</code></pre>',
                    "open": 1
                };
            },

            /**
             * 
             */
            zoomslide: function() {
                if (!this.slidebox) return;

                if (this.$.loadspinner.active) {
                    // B. reset old slide if NO server-response
                    console.log("NO-SERVER-RESPONSE");
                    this.$.loadspinner.active = false;
                    map.setLayoutProperty(this.slidectrl.id, 'visibility', 'visible');
               
                } else {
                    var slidedata = this.slidedata,
                        n = slidedata.features.length;


                    // A. deactivate service-trigger
                    this.serviceflag = false;

                    // B. 
                    var index = this.slideindex;
                    if (index == undefined) index = n - 1;  

                    // C. 
                    var slide = slidedata.features[index],  
                        bb = this.getBoundingBox([slide]);
                    map.fitBounds(bb);
                    
                    // D. 
                    index = index - 1 < 0 ? n - 1 : index - 1 ; 
                    this.slideindex = index; 

                }

            }

        });
    </script>
</dom-module>