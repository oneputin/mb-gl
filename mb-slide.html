<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../paper-dialog/paper-dialog.html">
<link rel="import" href="../paper-dialog-scrollable/paper-dialog-scrollable.html">
<link rel="import" href="../neon-animation/neon-animations.html">
<link rel="import" href="../kml-json/kml-json.html">
<link rel="import" href="../paper-fab/paper-fab.html">
<link rel="import" href="../paper-spinner/paper-spinner-lite.html">
<link rel="import" href="../iron-icons/iron-icons.html">

<link rel="import" href="mb-api.html">

<!--
`mb-slide`
wraps a mb-gl-overlay based on feature-geosource (geojson) and links to mb-gl-map 
- additional fab for zoom to slide
- interactive queries (f.i. map-click) produce slideinfo-object 
- optional layer-bound POPUP (paper-dialog) to view slideinfo ontop of map  

@demo demo/index1.html 
-->

<dom-module id="mb-slide">
    <template>
        <style>
            :host {
                display: block;
            }
            paper-dialog {
                border: 2px solid;
                border-color: var(--paper-green-500);
                background-color: var(--paper-light-green-50);
                color: var(--paper-green-500);
            }
            #slidezoom {
                position:absolute;
                right:5px;
                top:5px;
                opacity: 0.8; 
            }
            #loadspinner {
                position:absolute;
                right: 0px;
                width:  66px;
                height: 66px;
                --paper-spinner-color: var(--paper-pink-500);
                opacity: 1; 
            }
            #popupbody {
                line-height: 0.8;
            }

        </style>

        <template is="dom-if" if="[[serviceflag]]">
            <!-- Async query for new {{slidedata}} -->
            <kml-json 
                url     = "[[serviceurl]]"
                service = "[[_servicequery]]"
                geojson = "{{slidedata}}">
            </kml-json>
        </template>

    <paper-spinner-lite id="loadspinner" alt="loading next slide" active></paper-spinner-lite>
    <paper-fab id="slidezoom" class="fab" icon="all-out" title="heart" on-tap="zoomslide"></paper-fab>

    <paper-dialog id="popup" class="colored" entry-animation="scale-up-animation" exit-animation="fade-out-animation" with-backdrop>
        <!--  -->
        <h2 id="popupheadline">[[popuptitle]]</h2>
        <paper-dialog-scrollable>
            <pre><code id="popupbody">[[slideinfo]]</code></pre>
        </paper-dialog-scrollable>
    </paper-dialog>

    <!--<div id='map'></div>-->

    </template>

    <script>
        var slidesetup = {

            serviceurl: "http://iimaps.de/npp/if_slides.php",

            serviceparams: {
                mapclient: "ol2",
                card: "default",
                slide: "basin"
            },

            cbox: {
                type: String,
            },

            /**
             * "static" layer-ctrl of overlay 
             */
            layer: {
                "id": "slide",
                "type": "fill",
                "source": "slide",
                "layout": {},
                'paint': {
                    'fill-color': '#088',
                    'fill-opacity': 0.3,
                    'fill-outline-color': '#000'
                }
            }

        };

        Polymer({
            is: 'mb-slide',

            properties: {
                /**
                 *  map-object of related mb-gl-map
                 */
                map: {
                    type: Object,
                    observer: 'setupthetrigger',
                    notify: true
                },

                /*
                 *  flag to enable/disable automatic sliderequests
                 */
                serviceflag: {
                    type: Boolean,
                    value: false,
                    notify: true,
                    observer: 'servicetrigger'
                },

                /**
                 * basic server-url of overlay-dataservice
                 */
                serviceurl: {
                    type: String
                },

                /**
                 * "static" parameters qualifying the overlay-dataservice
                 */
                serviceparams: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /**
                 * location for service-query.
                 * default: actual map-center
                 */
                cbox: {
                    type: String,
                    observer: ('locationrequest')
                },

                _servicequery: {
                    type: Object
                },

                /**
                 * raw response from slide-server. 
                 * geometries + properties of all slide-faetures
                 */
                slidedata: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /*
                 *  customizable transformation of one features properties(attributes) for output
                 */
                preformatter: {
                    type: Function,
                    value: function() {
                        return function(x) {
                            var s = "";
                            // console.log(x.properties.name, x.properties)
                            return x.properties.name;
                            // return s;
                        };
                    }
                },

                /*
                 *  JSONstring of array of feature-properties after formatting by 'preformatter'
                 */
                slideinfo: {
                    type: String,
                    notify: true,
                    observer: 'popupopen'
                },

                /*
                 *  bbox of last-updated-slide
                 */
                slidebox: {
                    type: Object
                },
                /*
                 *  ids of all features building the actual slide 
                 *  (as links for following feature-actions, fi. requests to feature-databases)
                 */
                slidekeys: {
                    type: String,
                    notify: true
                },

                // mapbox-layer-ctrl used to create slideLayer
                slidectrl: {
                    type: Object,
                    value: function() {
                        return {};
                    }
                },

                /*
                 *  name of basemap-layer to insert the slide below 
                 */
                insertslidebelow: {
                    type: String,
                    value: "water"
                },

                /*
                 *  title of "internal" info-popup
                 */
                popuptitle: {
                    type: String,
                    value: "Slideinfo"
                }
            },

            observers: [
                'servicerequest(serviceflag, serviceparams.card, serviceparams.slide)',
                'serviceresponse(slidedata.*)',
                'requestlog(serviceurl, _servicequery.*)'
            ],

            requestlog: function(a, b) {
                // console.log("requestlog", a, b, b.value);
            },

            attached: function() {

                this.serviceurl = slidesetup.serviceurl;

                // var serviceparams 
                this.serviceparams = Object.assign({}, slidesetup.serviceparams, this.serviceparams);
                // this.serviceparams = serviceparams;

                this.slidectrl = Object.assign({}, slidesetup.layer, this.slidectrl);
                // this.slidectrl = layerctrl;

                if (0) {
                    console.log("slide service: " + this.serviceurl, this.serviceparams);
                    console.log("slide layer:", this.slidectrl);
                }
            },

            locationrequest: function(n, o) {
                // don't request for very small 'movements' of cbox
                if (n && o && this.map && this.map.getBounds()) {
                    var mindy = 0.01, //  
                        mb = this.map.getBounds(),
                        dlat = Math.abs(mb.getNorth() - mb.getSouth()),
                        dy = Math.abs(n.split(",")[1] - o.split(",")[1]);
                    // console.log("locationrequest", dlat, dy);
                    if ((dy / dlat) < mindy) return;
                }
                // console.log("locationrequest", n, o);
                this.servicerequest(this.serviceflag);
            },

            /**
             *   Action triggers new slide-request after any of the service-parameters had changed
             *   mainly : cbox (mapcenter)
             */
            servicerequest: function(serviceflag) {
                if (!serviceflag || !this.cbox) return;

                this.$.loadspinner.active = true;

                this.debounce('request', function() {
                    // Trigger the ServiceIF (<kml-json>) toggling _servicequery 

                    var servicequery = this.serviceparams;
                    servicequery["time"] = Date.now();
                    // console.log("Trigger SERVICEREQUEST as:", servicequery);

                    this._servicequery = {};
                    this._servicequery = servicequery;

                    // Hide actually active slide
                    if (this.map && this.map.getLayer("slide")) {
                        this.map.setLayoutProperty("slide", 'visibility', 'none');
                        // this.animateSlide("hide");
                    }
                }, 300)
            },

            /*
             *   action triggered if (slide)-server returns new data   
             */
            serviceresponse: function(rawslidedata) {
                // console.log(typeof rawslidedata, rawslidedata, this.map);

                this.$.loadspinner.active = false;

                if (!this.map || (typeof rawslidedata != "object") || !Object.keys(rawslidedata).length) return;

                var slidedata;
                if (rawslidedata.value) slidedata = rawslidedata.value; // 
                else slidedata = rawslidedata;

                if (!slidedata.features || !slidedata.features.length) return;

                this.slidedata = slidedata;
                // console.log("new slide data:", slidedata);

                this.slidebox = this.getBoundingBox(slidedata);

                this.slidekeys = this.getSlideKeys(slidedata);
                // console.log("ServiceResponse=slidelayer:", this.slidekeys, slidedata, this.slidebox);

                // Specifically mb-gl: ? Test for source (not for layer) ?
                var slidesource = this.slidectrl.source;

                if (!this.map.getSource(slidesource)) {
                    // create NEW slidelayer
                    this.createSlideLayer();

                } else {
                    // Modify datasource in ACTUAL slidelayer     
                    if (this.animateSlide) {
                        // FLOWIN (ANIMATED) 
                        this.animateSlide("show");
                    } else {
                        // STAMPIN (DEFAULT) 
                        this.map.getSource(slidesource).setData(slidedata);
                        this.map.setLayoutProperty("slide", 'visibility', 'visible');
                    }

                }
            },

            /*
             *  ANIMATOR
             */
            animateSlide: function(flag) {
                if (!flag) flag = "hide";

                var animation = {};

                animation.count = 60;
                animation.context = this;
                animation.index = 0;

                if (0) {
                    animation.fade = this.slideFade;
                }
                if (1) {
                    animation.path = this.slidePath;
                    animation.pathdatax = [
                        "0.1, 0.1",
                        "0.1, 0.1",
                        "0.1, 0.1",
                        "0.1, 0.1",
                        "0.1, 0.1",

                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",
                        "-0.1, -0.1",

                        "0.1, 0.1",
                        "0.1, 0.1",
                        "0.1, 0.1",
                        "0.1, 0.1",
                        "0.1, 0.1"
                    ]
                }
                if (0) {
                    animation.move = this.slideMove;
                    var bb = this.map.getBounds();
                    animation.dx0 = (bb.getEast() - bb.getWest()) / 2;
                    animation.dy0 = (bb.getNorth() - bb.getSouth()) / 2;
                    animation.dx = 0 - (animation.dx0 / animation.count);
                    animation.dy = 0 - (animation.dy0 / animation.count);
                }

                var updateFrame = (function updateFrame() {

                    if (animation.path) {
                        // any move along path
                        animation.path(animation.index, animation.context);

                    } else if (animation.move && (animation.dx || animation.dy)) {
                        // linear translation
                        animation.move(animation.dx, animation.dy, animation.context);
                    }

                    if (animation.fade) {
                        animation.fade(animation.count, animation.index, animation.context)
                    }

                    animation.index += 1;
                    if (animation.index == animation.count) return;

                    // console.log("next animation-step:", animation.index);
                    requestAnimationFrame(updateFrame);

                }).bind(this);

                if (flag == "show") {

                    // 1. initialize animation-object in the OFF (location and opacity)
                    if (animation.fade) {
                        animation.fade(0, 0, animation.context); // animation-start-opacity=0
                    }
                    if (animation.move && (animation.dx0 || animation.dy0)) {
                        animation.move(animation.dx0, animation.dy0, animation.context); // animation-start-location
                    }

                    // 2. make layer visible 
                    this.map.setLayoutProperty("slide", 'visibility', 'visible');

                    // 3. start show-animation  
                    updateFrame();

                } else {

                    // 1. start hide-animation
                    updateFrame();
                    // 2. make layer invisible 
                    this.map.setLayoutProperty("slide", 'visibility', 'none');
                }

            },

            // slideMove, slidePath, slideFade called ONLY from inside ANIMATOR
            /*
             *  moves/translates slide by dx,dy
             */
            slideMove: function(dx, dy, that) {
                // slideMove: function(slidesource, startdata, dx, dy) {
                var anim = this;
                if (!that) that = this.context;
                // console.log("BEFORE locate:", "dx=" + dx, "dy=" + dy, Date.now());
                if (!dx) dx = anim.dx;
                if (!dy) dy = anim.dy;
                if (!dx && !dy) {
                    that.map.getSource(that.slidectrl.source).setData(that.slidedata); // slidedata);
                    return;
                }

                var slidedata = that.slidedata;

                slidedata.features.forEach(function(f) {

                    // Handle alternative geojson-geometry-struktures (with/without substructures)
                    var gg = f.geometry.geometries;
                    if (!gg) gg = [f.geometry];

                    gg.forEach(function(g) {
                        g.coordinates.forEach(function(cc) {
                            cc.forEach(function(c) {
                                c[0] = c[0] + dx;
                                c[1] = c[1] + dy;
                            })
                        })
                    })
                })

                // console.log("AFTER locate:", slidedata, Date.now());

                that.map.getSource(that.slidectrl.source).setData(slidedata);
                // return slidedata;
            },
            /*
             *  moves slide along a path
             */
            slidePath: function(count, that) {
                var animation = this,
                    spath = animation.pathdata;

                if (!that) that = animation.context;
                if (!count) count = 0;

                var ampl = 0.02,
                    p1, p2, dx, dy,
                    bb = that.map.getBounds(),
                    bbdx = bb.getEast() - bb.getWest(),
                    bbdy = bb.getNorth() - bb.getSouth();

                // calc animation-step 
                if (!spath) {
                    p1 = Math.cos(2 * Math.PI * count / animation.count);
                    p2 = Math.cos(2 * Math.PI * (count + 1) / animation.count);
                    dx = ampl * (p2 - p1);
                    dy = dx * bbdy;
                    dx = dx * bbdx;
                    // console.log(count, dx, dy);
                } else {
                    pc = spath[count];
                    if (!pc) return;
                    dx = ampl * pc.split(",")[0] * bbdx;
                    dy = ampl * pc.split(",")[1] * bbdy;
                }
                // console.log("BEFORE locate:", "dx=" + dx, "dy=" + dy, Date.now());

                that.slideMove(dx, dy, that);
            },
            /*
             *  fades slide-opacity by fraction of target-opacity
             */
            slideFade: function(maxcount, count, that) {
                // slideMove: function(slidesource, startdata, dx, dy) {
                // translate slide by dx,dy
                if (!that) that = this.context; // !!!
                if (!maxcount) maxcount = 100;
                if (!count) count = 0;

                var opacity = 0,
                    targetopacity = that.slidectrl.paint["fill-opacity"],
                    maxopacity = targetopacity ? targetopacity : 1;

                if (count > 0 && maxcount > 0) {
                    var countopacity = maxopacity * count / maxcount;
                    opacity = countopacity < 1 ? countopacity : 1;
                }
                //console.log(that.slidectrl.id, maxopacity, opacity);

                that.map.setPaintProperty(that.slidectrl.id, 'fill-opacity', opacity);
            },

            /*
             *  
             */
            createSlideLayer: function() {

                var that = this,
                    slidedata = this.slidedata,
                    slidectrl = this.slidectrl,
                    insertlayer = this.insertslidebelow,
                    slidesource = slidectrl.source;

                this.map.addSource(slidesource, {
                    type: 'geojson',
                    data: slidedata
                });

                // SlideLayer with insert-point in baseLayerStack
                this.map.addLayer(slidectrl, insertlayer);
                // ======================================

                this.map.on('click', function(e) {
                    // console.log("clicked", e, e.point);
                    that.slideinfoget(e.point);
                });

                /* Optional for autotracing of center-info
                this.map.on('render', function(e) {  // 
                    that.debounce('rendering', function() {  // was called too often 
                        var ll = that.map.getCenter();
                        var c = e.target._canvas;
                        console.log(ll, c);
                        // qpoint = new mapboxgl.Point(c.width / 2, c.height / 2);
                        // that.slideinfoget(e.point);
                    }, 300);
                }); */
            },

            /**
             *  setting up the 
             */
            setupthetrigger: function(newmap) { // console.log("setupthetrigger", newmap);
                if (newmap) {
                    // var that = this;

                    this.map.on('moveend', function() {
                        // trigger overlay-request after every "map-move" 
                        if (this.serviceflag) this.servicetrigger();
                    }.bind(this));

                    // console.log("trigger initial service-request on", this.map);
                    this.serviceflag = true;
                    this.servicetrigger();
                } else {
                    // this.map = undefined;
                }
            },

            /**
             *
             * Indirectly triggers a request for new servicedata 
             * updating cbox in serviceparameters (observed by servicerequest)
             */
            servicetrigger: function(t) {
                if ((t != undefined) && !t) return;
                var that = this;
                this.debounce('triggering', function() {
                    var cbox = that.map.getCenter();
                    cbox = cbox.lng + ',' + cbox.lat;
                    that.serviceparams.cbox = cbox; // the TRIGGER
                    // console.log("Triggering service", that.serviceparams, that.serviceflag);
                }, 300);
            },

            // interactive feature-query at click-location 
            // (?? or at mapcenter after render-event ??)	
            slideinfoget: function(qpoint) {
                if (!qpoint) return;
                var formatter = this.preformatter,
                    slidename = this.slidectrl.id;
                // console.log("slideinfoget for pnt, formatter", qpoint, formatter);

                var features = map.queryRenderedFeatures(qpoint, {
                    layers: [slidename]
                }); // console.log('slideinfoget-qpoint', qpoint, features);

                if (!features.length) {
                    this.slideinfo = "slide-query outside slide-area!";
                } else {
                    var frameindex, slideinfo = [];
                    features.forEach(function(item, index) {
                        if (item.id) frameindex = item.id;
                        else frameindex = index;
                        slideinfo[frameindex] = formatter(item);
                    })

                    // Tranform Array into string
                    // this.slideinfo = JSON.stringify(slideinfo, null, '\n');
                    // this.slideinfo = JSON.stringify(slideinfo);
                    this.slideinfo = slideinfo;
                }
                // console.log("slideinfoget", this.slideinfo);
                // optionally show in map-context
                if (true) this.$.popup.open();
            },

            /**
             * 
             */
            popupopen: function(item) {
                if (!item) return;
                var txt = typeof item == "string" ? item : JSON.stringify(item, null, '\n');
                this.$.popupbody.innerText = txt;
                this.$.popup.open();
            },

            /**
             * 
             */
            zoomslide: function() {
                if (!this.slidebox) return;

                if (this.$.loadspinner.active) {
                    // B. reset old slide if NO server-response
                    console.log("NO-SERVER-RESPONSE");
                    this.$.loadspinner.active = false;
                    this.map.setLayoutProperty("slide", 'visibility', 'visible');
                } else {
                    // A. deactivate service-trigger
                    this.serviceflag = false;
                    // C. 
                    var bb = this.slidebox; // console.log("fitToSlide", bb);
                    this.map.fitBounds(bb);
                }

            },

            // utilities
            // u1: bounding box
            getBoundingBox: function(data) {
                if (data.features) data = data.features; //console.log(data); // return
                if (!data.length) return; //console.log(data); 

                var segments, coords, pnt, latitude, longitude, bb = {};
                for (var i = 0; i < data.length; i++) {
                    if (data[i].geometry.geometries) {
                        segments = data[i].geometry.geometries; //console.log("segments", segments);
                    } else {
                        segments = [data[i].geometry];
                    }
                    for (var k = 0; k < segments.length; k++) {
                        coords = segments[k].coordinates[0];
                        if (!bb.xMin) {
                            pnt = coords[0];
                            bb = {
                                "xMin": pnt[0],
                                "xMax": pnt[0],
                                "yMin": pnt[1],
                                "yMax": pnt[1]
                            };
                        }
                        for (var j = 0; j < coords.length; j++) {
                            longitude = coords[j][0];
                            latitude = coords[j][1];
                            bb.xMin = bb.xMin < longitude ? bb.xMin : longitude;
                            bb.xMax = bb.xMax > longitude ? bb.xMax : longitude;
                            bb.yMin = bb.yMin < latitude ? bb.yMin : latitude;
                            bb.yMax = bb.yMax > latitude ? bb.yMax : latitude;
                        }
                    }
                }
                var bb = [
                    [bb.xMin, bb.yMin],
                    [bb.xMax, bb.yMax]
                ]; //console.log(bb);
                return bb;
            },
            // u2: (geo)id-list of slide-features
            getSlideKeys: function(data) {
                if (data.features) data = data.features; //console.log(data); // return
                if (!data.length) return; // console.log("getSlideKeys", data); 
                var props, id, keys = [];
                for (var i = 0; i < data.length; i++) {
                    id = data[i].id;
                    props = data[i].properties;
                    if (!id) {
                        id = props.id;
                        if (!id) id = props.name;
                        if (!id) id = i;
                    }
                    keys.push(id);
                }
                keys = keys.toString(); // 
                return keys;
            }

        });
    </script>
</dom-module>