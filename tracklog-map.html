<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="tracks-behavior.html">

<!--
`tracklog-map`
Draggable mb-point with optional snapping to mb-theme features (or vice-versa), 
alternative demos : routingtracks.html, fullscreen.html

@demo demo/routingtracks.html
-->

<dom-module id="tracklog-map">

    <template>
    </template>

    <script>
        Polymer({
            is: 'tracklog-map',

            properties: {

                mbid: {
                    type: Object,  
                    observer: '_install'
                }, 

                lnglat: {
                    type: Object //, observer: 'logPointGet'
                },

                // property-items to be used for decription, charting etc
                logitems : {
                    type: Array,
                    value:  ["coordElevs","coordTimes"]  // standard of trackLines
                },
                // 
                titleitem: {
                    type: String,
                    value : "coordTimes" // "coordElevs"                    
                },


                draggable: {
                    type: Boolean
                },

                mobilemode: {
                    type: Boolean,
                    value: false
                },

                disable: {
                    type: Boolean,
                    value: false //, observer: 'toggleVis'
                },

                // externally available coords
                /*coords: {
                    type: Array,
                    value : [0,0],
                    observer: 'logPointRefresh',
                    notify: true                    
                },*/

                // 
                index: {
                    type: Number,
                    value : -1,
                    observer: 'logPointRefresh',
                    notify: true
                },

                // mbstyleSymbol of logpoint
                logsymbol: {
                    type: String,
                    value : "toilet-15"                    
                },

                // 
                _snapTarget: {
                    type: Object
                },

                // Array of indexed data
                logdata: {
                    type: Object
                },

                // 
                maptoast: {
                    type: String,
                    notify: true
                },

                _logPntLayers : {
                    type: Array,
                    value : []
                },

                _dragPntLayers : {
                    type: Array,
                    value : []
                }
            },

            behaviors: [
                Mbb.TracksBehavior,
            ],

            observers: [
                '_snapTargetBuild(logdata.geometry)',
                'logPointGet(logdata.lnglat)',
                // '_toggleMode(draggable, mobilemode)'
            ],

            ready : function() {
                this.logPointSymbolDefine();
            },

            _install : function(mbid, mbidbefore) { // console.log("TRACKLOG _install", mbid, mbidbefore);
                if (mbidbefore) return; 
                this.logPointSetup(this.draggable, this.mobilemode);
            },

            // map-entity 
            logPointSetup : function(draggable, mobilemode) {  
                // console.log("Setup logPoint into ["+this.mbid+"]","mobilemode=" + mobilemode, "draggable=" + draggable);

                var scope = this;
                var logid = 'logpoint',
                    dragid = 'dragpoint';

                var isMobile = (typeof window.orientation !== "undefined") || (navigator.userAgent.indexOf('IEMobile') !== -1),
                    isCursorOverPoint,
                    isDragging;
                
                mobilemode = mobilemode || isMobile;

                // Change point and cursor style as a UI indicator
                // and set a flag to enable other mouse events.
                function logPointToggle(flag, msg) { 

                    if (flag) {
                        map.setPaintProperty(dragid, 'circle-color', '#f00'); // '#3bb2d0');
                        map.setLayoutProperty(logid, 'icon-image', 'rocket-15'); // '#3bb2d0');

                        isCursorOverPoint = true;

                        map.dragPan.disable();

                    } else {
                        map.setPaintProperty(dragid, 'circle-color', '#ff0');
                        map.setLayoutProperty(logid, 'icon-image', 'toilet-15'); // '#3bb2d0');

                        isCursorOverPoint = false;

                        map.dragPan.enable();
                    } 
                    // console.log("logPointToggle", "flag="+flag, "msg="+msg, "isCursorOverPoint:" + isCursorOverPoint);
                }

                function dragPointDragEvents() {
                    if (!mobilemode && !isCursorOverPoint) return;
                    if (!map.getLayer(dragid)) return; 
                    // console.log("dragPointDragEvents. mobile flags:", mobilemode, isMobile)

                    // A. Setup Events on logPoint
                    
                    if (mobilemode) {    
                
                        if (isMobile) { // Real TouchActions
                            //map.on('touchmove', dragid, onDragMove);
                            map.on('touchmove', onDragMove);

                            // map.once('touchend', dragid, onDragStop);
                            map.once('touchend', onDragStop);

                        } else {        // Simulates TouchActions

                            //map.on('mousemove', dragid, onDragMove);
                            if (isCursorOverPoint)  map.on('mousemove', onDragMove);
                            
                            map.once('mouseup', onDragStop);
                        }

                    } else { // Purely Desktop: MouseActions
    
                        //map.on('mousemove', dragid, onDragMove);
                        //map.on('mouseup', dragid, onDragStop);
                        map.on('mousemove', onDragMove);
                        //map.on('mouseup', onDragStop);
                        map.once('mouseup', onDragStop);
                    }

                    // B. Set Drag-Status
                    isDragging = true; // console.log("start dragging");

                }

                // basic event-actions 
                function mouseToggle(e) {
                    var flag = (e.type=="mouseover") ? 1 : 0;  // console.log("mouseToggle", e.type, flag);
                    logPointToggle(flag, "mouseMove"); 
                }    

                function mouseMove(e) {
                    if (!map.getLayer(dragid)) return;
                    var features = map.queryRenderedFeatures(e.point, { layers: [dragid] });
                    logPointToggle(features.length, "mouseMove"); 
                }
                
                function mouseDown(e) {
                    // e.originalEvent.stopPropagation();
                    dragPointDragEvents();
                }

                // Combines action of desktop-events 'mousemove' and 'mousedown' 
                function touchStart(e){
                    if (!map.getLayer(dragid)) return;
                    // e.originalEvent.stopPropagation();
                    var features = map.queryRenderedFeatures(e.point, { layers: [dragid] });  // console.log("touchStart", e, features);
                    if (features.length) {
                        logPointToggle(features.length, "touchStart");
                        dragPointDragEvents(); 
                    } 
                } 

                // event-actions when point was "activated"
                function onDragMove(e) {        // console.log("onDragMove isDragging=", isDragging);
                    if (!isDragging) return;    // e.originalEvent.stopPropagation();

                    var lngLat = e.lngLat,
                        coords = [lngLat.lng, lngLat.lat],
                        index;   // console.log("onDragMove", coords);     

                    if (scope._snapTarget) { // Update the "nearest" point on active target(fi. track) 
                        var snapPnt = scope._snapPointQuery(lngLat, scope._snapTarget);
                        index = snapPnt.properties.index; 
                        // coords = ????
                    }    
                    
                    if (index != null) {
                        // A. Trigger index in all related elements
                        // scope.index = snapSet.index;
                        // B. Refresh dragPnt on map only 
                        scope.logPointRefresh(index);
                    } else {
                        scope.logPointRefresh(null, coords);
                    }

                    // scope.coords = coords;
                }

                function onDragStop(e) {  
                    if (!isDragging) return;
                    // e.originalEvent.stopPropagation();

                    isDragging = false;  // console.log("onDragStop. stopDragging");

                    scope.maptoast = "Log: " + scope.logPointGet(e.lngLat); // console.log(scope.maptoast, e); 

                    // Unbind 'permanent' drag-events
                    //map.off('mousemove', dragid, onDragMove);
                    //map.off('touchmove', dragid, onDragMove);
                    map.off('mousemove', onDragMove);
                    map.off('touchmove', onDragMove);

                    logPointToggle(0, "onDragStop"); 
                }

                function logPointReset(draggable){
                    if (!draggable) draggable = scope.draggable; 
                    // console.log("logPointReset. draggable=",draggable);
                    
                    // map.off('data', testStyleChange);
                    // console.log("dragpntEvents REMOVED");

                    if (!map.getSource(logid)) {
                        var logFeature = scope.logPointFeature([0,0]); 
                        map.addSource(logid, { 
                            type: 'geojson', 
                            data: logFeature 
                        }); // console.log("logpnt SOURCE ADDED", logFeature);  
                    }

                    if (!map.getLayer(logid)) {

                        scope._dragPntLayers.forEach(function(layer){
                            map.addLayer(layer);
                        }); //console.log("dragpntLayers ADDED", scope._dragPntLayers);

                        scope._logPntLayers.forEach(function(layer){
                            map.addLayer(layer);
                        }); //console.log("logpntLayers ADDED", scope._logPntLayers[0]);
                    }

                    // HIDE/SHOW "dragLayers""
                    var vis = "visible";
                    if (!draggable) vis = "none";  // console.log("SET dragVisibility", vis);                    
                   
                    scope._dragPntLayers.forEach(function(layer){ 
                        map.setLayoutProperty(layer.id, 'visibility', vis);
                    });    


                    // reset draglayer-events 
                    var dragLayer = map.getLayer(dragid);

                    if (dragLayer) {
                        // console.log("logPointReset. set EVENTS for", "dragLayer:", dragLayer, "draggable=" + draggable);
                        
                        // A. OFF
                        //map.off('mousemove', mouseMove); 
                        map.off('mouseover', dragid,  mouseToggle); 
                        map.off('mouseout', dragid,  mouseToggle); 

                        map.off('mousedown', dragid, mouseDown); 

                        map.off('mousedown', dragid, touchStart);
                        map.off('touchstart', dragid, touchStart); 
                        
                        // Init !!
                        map.dragPan.disable();
                        map.dragPan.enable();

                        // B. ON
                        if (draggable) {

                            // Set `true` to dispatch start-events (mousedown, touchstart) before other functions call it. 
                            // This is necessary for disabling the default map dragging behaviour.

                            if (mobilemode) {   // ctrlOption to test mobileMode on PC 
                                // 
                                if (isMobile) { //console.log("logPointReset", "setup REAL  'mobile touchstart-action'");  
                                    map.on('touchstart', dragid, touchStart);  // true
                                } else {        //console.log("logPointReset", "setup FAKED 'mobile touchstart-action'");            
                                    map.on('mousedown', dragid, touchStart);   // true
                                }
                            
                            } else { 
                                // map.on('mousemove', mouseMove);
                                // map.on('mousemove', dragid, mouseMove);
                                map.on('mousedown', dragid, mouseDown);  // true
                                map.on('mouseover', dragid,  mouseToggle); 
                                map.on('mouseout', dragid,  mouseToggle); 
                            }  
                        } // console.log("Refreshed logPoint-MAP-listeners ", map._listeners); 

                    }    

                }

                // reset logPoint in new Style
                function testStyleChange(e) {
                    if (e.dataType == "style") {   

                        if (e.style.stylesheet.id != scope.mbid) { // console.log("style unchanged ", e.style.stylesheet.id); 

                            // mbid for internal ctrl only 
                            scope.mbid = e.style.stylesheet.id;  // console.log("refreshing logPoint into ["+mbid+"]. mobilemode=" + mobilemode); 
                            
                            // 
                            logPointReset(); 

                            // return; 
                        } 
                    }    
                }  

                map.off('data', testStyleChange); // console.log("SETUP logPoint"); // to avoid duplicates 
                logPointReset(); 
                map.on('data', testStyleChange);
            },

            // 
            logPointSymbolDefine : function() {
                // symbolLayers-1 (permanent)
                this._logPntLayers = [
                    {
                        "id": "logpoint-glow",
                        "type": "circle",
                        "source": "logpoint",
                        "paint": {
                            "circle-radius": 18,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.6
                        }
                    }, 
                    {
                        "id": "logpoint",
                        "type": "symbol",
                        "source": "logpoint",
                        "layout": {
                            "icon-image": this.logsymbol,
                            "icon-rotate": 0,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        }
                    }
                ];
                // symbolLayers-2 (dragmode only)
                this._dragPntLayers =  [
                    {
                        "id": "dragpoint",
                        "type": "circle",
                        "source": "logpoint",
                        "paint": {
                            "circle-radius": 40,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.2
                        }
                    }
                ];
            },

            // AppShell around logPointRefresh
            logPointGet : function(lngLat) { 
                if (!lngLat) return; // console.log("logPointGet START", lngLat, this.logdata);
                var mapToast = ""; 

                if (this._snapTarget) {   // A. 

                    var snapPnt = this._snapPointQuery(lngLat, this._snapTarget),
                        index = snapPnt.properties.index; 

                    if (index != null) {
                        // MAIN Trigger: SYNC of target-use in external apps
                        // ************
                        this.index = index;
                        mapToast = this._snapPointInfo(snapPnt, this.logdata); 
                        return mapToast; 
                        // dragPointDragEvents(); 
                    }    

                } 

                var coords = [lngLat.lng, lngLat.lat];
                
                this.logPointRefresh(null, coords);  // console.log("Refreshing logPoint", ix);
                // Additional UI-info 
                mapToast = "FREE. Dragged to " + coords; 

                return mapToast;
            },        

            // Refresh coords of dragPnt (= refresh Source of dragPnt-theme)
            logPointRefresh: function(index, coords, title, logsymbol) {
                if (!map) return; 
                var logPointSrc = map.getSource("logpoint");
                if (!logPointSrc) return; // console.log("logPointRefresh", index, coords);

                var scope = this; 
                function _logdataTitle(index, titleprop, logdata) {
                    var titledata, title, titleraw;
                    if (titleprop ) { // console.log(index, titleprop); // , logdata); 
                        
                        titledata = logdata[titleprop];
                        
                        if (titledata) {
                            titleraw = titledata[index];
                            if (titleprop=="coordTimes") {
                                var t = scope.trackTime(titleraw);
                                t = scope.utcTime(t, "h");
                                title = scope.logTime(t, "h", "t");
                            } else if (titleprop=="coordTimes") {
                                title = titleraw + "m"
                            } else {
                                title = titleraw
                            }
                        }
                    }  
                    return title;   
                }

                // move map that actual bound-size 
                // contains the point with [coords]
                function moveMapToCoords(coords){
                    var pcheck = turf.point(coords),
                        bbox = map.getBounds(),
                        bounds = turf.polygon([[
                            bbox.getSouthWest().toArray(), 
                            bbox.getNorthWest().toArray(), 
                            bbox.getNorthEast().toArray(), 
                            bbox.getSouthEast().toArray(), 
                            bbox.getSouthWest().toArray()
                        ]]); // console.log(coords, pcheck, bbox, bounds);
                    if (!turf.inside(pcheck, bounds)) {
                        map.flyTo({center: coords});
                    }
                }

                // A meaningful logPointSymbolDefine built from 3 symbol(Layer)s 
                if (index < 0) index = null; 

                // A. Recalculate coords of trackPnt, if index was supplied
                if ((index!=null) && this.logdata) {
                    coords = this.logdata["coords"][index].slice(0,2);  // console.log(coords[0],typeof coords[0]);
                } 
                if (!coords) return; // console.log("DEBUG-1", index, this.logdata, coords, title );
                
                // B. Refresh the logged title
                if (!title && this.titleitem && this.logdata) {
                    title = _logdataTitle(index, this.titleitem, this.logdata); 
                }

                // C. Optionally Move mapextent to ensure 
                //    the new trackPoint-location is inside  
                moveMapToCoords(coords);

                // Update LogPoint-srcData 
                logPointSrc.setData(this.logPointFeature(coords, title));

                // if (!turf.inside(logPoint, map.getBounds())) {
                //     map.flyTo({center: coords});
                // }

            },

            // 
            logPointFeature: function(coords, title) {
                if (title == null) title = "drag"; 
                var logPoint = {
                    "type": "FeatureCollection",
                    "features": [{
                        "type": "Feature",
                        "geometry": {
                            "type": "Point",
                            "coordinates": coords
                        },
                        "properties": {
                            "title" : title
                        }
                    }]
                };
                return logPoint; 
            },

            // 
            _toggleMode : function(draggable, mobilemode) { 
                if (!this.mbid || (draggable == null)) return;   
                console.log("logModes: ", "draggable="+draggable, "mobilemode="+mobilemode);
                this.logPointSetup(draggable, mobilemode); 
                
            },

            // 
            _snapTargetBuild: function(targetgeometry) { 
                if (!targetgeometry) return; // console.log("targetgeometry", targetgeometry);

                this._snapTarget = turf.feature(targetgeometry);

                return;

                // A. Collect 
                var targetSource = map.getSource('snaptarget');
                if (targetSource) {
                    targetSource.setData(targetgeometry);
                } else {
                    map.addSource('snaptarget', { 
                        type: 'geojson', 
                        data: {
                            type: "Feature",
                            properties : {},
                            geometry: targetgeometry
                        }
                    }); 
                    targetSource = map.getSource('snaptarget');
                    var targetLayer = map.addLayer({
                        "id": "snaptarget",
                        "type": "line",
                        "source": "snaptarget"
                    });

                    this._snapTarget = targetLayer;
                }
            },

            // 
            _snapPointQuery : function(queryPnt, snapTarget) { // , elemscope) {
                if (!snapTarget) return; // target = this._snapTarget; 
                
                queryPnt = { 
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Point",
                        "coordinates": [queryPnt.lng, queryPnt.lat]
                    }
                };  

                // B.2 Find/Eval nearest point on target
                var snapPnt = turf.pointOnLine(snapTarget, queryPnt, 'kilometers');
                if (!snapPnt) return queryPnt; // console.log("snapPnt", snapPnt );

                return snapPnt; 
            },

            // UX-support
            _snapPointInfo: function(snapPnt, logdata) { // console.log(snapPnt); 
                    var index = snapPnt.properties.index,
                        location = snapPnt.properties.location;

                    // Additional UI-info 
                    var s = "nn",t = "nn" ;
                    
                    if (logdata["coordTimes"]) {
                        t = logdata["coordTimes"][index]; 
                        t = this.logTime(this.utcTime(this.trackTime(t)),null,"/");
                    }

                    if (location) {
                        s = this.toFixed(snapPnt.properties.location, 2)+"km";
                    }    
                    
                    var mapToast = 'At = [' + t + '] ,  dist = [' + s + ']  from start';
                    return mapToast; 
            },

        })
    </script>
</dom-module>                  