<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="../paper-icon-button/paper-icon-button.html">
<link rel="import" href="../paper-button/paper-button.html">
<link rel="import" href="../iron-icon/iron-icon.html">
<link rel="import" href="../paper-card/paper-card.html">

<link rel="import" href="../kml-json/kml-json.html">

<link rel="import" href="mb-tools-behavior.html">

<link rel="import" href="routing-behavior.html">


<!--
`routing-handheld`
Interface for import/export of tracking data from handheld gps-devices

IN: transfer raw handheld-data (of different formats)
--- into 'routedata-template' (dataformat required by mb-routes-api)

OUT: RICH-content Info-card related to one selected feature,  
---  absolutely positioned as (mapbox-)map-overlay   

Mode-A: Can be vertically dragged & horizontally resized.  
Mode-B: Free drag   

To 'close' 
    - with click anywhere on the card
    - with click on specific "cancel"-button

@demo demo/routinghandheld.html 
-->

<dom-module id="routing-handheld">

    <template>

        <style is="custom-style">
            :host {
                position: absolute;
                display: none; /*inline-block;*/
                opacity: 1; 
                top: 50%;
                margin-bottom: -50%;
                transform: translate(0, -50%);

                /*  */
                --paper-card-header-text: {
                    padding: 8px;
                    font-size: 12px;
                    font-weight: 400;
                }
            }

            paper-card.info { 
                @apply(--layout-horizontal); 
                align-items: flex-start;
                --paper-card-header-color: #f00;
            }

            #div0 {
                font-size: 12px;
                font-weight: 400;
                border-bottom: 1px solid #e8e8e8;
                padding: 2px 2px;
            }
            .info-content {
                @apply(--layout-flex);
                float: left;
            }

            .card-image {
                width: 100px;
                height: 170px;
                background-color: red;
                background-size: cover;
            }

            .info-html { 
                color: var(--paper-grey-600); 
                opacity: 1;
            }
            
            .info-link { 
                color: var(--google-blue-500); 
            }

            paper-icon-button {
                background-color: var(--paper-light-blue-500);
            }

        </style>

        <iron-ajax
            auto
            url="[[jsonurl]]"
            handle-as="json"
            on-response="getrawdata">
        </iron-ajax>

        <kml-json 
            url="[[kmlurl]]" 
            query="[[kmlquery]]" 
            geojson="{{rawdata}}">
        </kml-json>

        <iron-ajax
            auto
            url="[[basedataurl]]"
            handle-as="json"
            on-response="getrawdbdata">
        </iron-ajax>

        <paper-card heading="{{carddata.title}}" image="{{cardimgurl}}" class="info">

            <div class="info-content">

                <div class="card-content">

                    <div id="div0"></div>

                    <div id="div1" class="info-html">

                    </div>

                </div>

                <div class="card-actions">
                    <paper-button class="info-link">more...</paper-button>
                </div>

            </div>

            <!--<paper-button class="info-link" on-click="_onBackClick">X</paper-button>-->
            <!--<paper-icon-button icon="close" on-click="_onBackClick"></paper-icon-button>-->

        </paper-card>

        <content>
        </content>    

    </template>

    <script>
        Polymer({
            is: 'routing-handheld',

            properties: {

                url: {
                    type: String,
                    observer: 'urldispatcher'
                },
                kmlurl: {
                    type: String
                },
                jsonurl: {
                    type: String,
                    observer: 'urldispatcher'
                },

                rawdbdata: {
                    type: Object,
                    value: []
                },

                rawdata: {
                    type: Object,
                    value: [],
                    observer: 'checkrawdata'
                },

                routedata: {
                    type: Object,
                    notify: true
                },

                mapdata: {
                    type: Object,
                    notify: true
                }

            },

            behaviors: [
                Polymer.ToolsBehavior,
            ],

            observers: [
                'importTracks(rawdata, rawdbdata)'
            ],

            attached: function() {
                // console.log("target attached");
            },

            urldispatcher: function(srcurl) {
                if (!srcurl) return;
                var ext = srcurl.split(".").slice(-1);
                if (!ext.length) return;
                ext = ext[0];
                // console.log("srcurl",typeof srcurl, srcurl,ext); // return;

                if (ext == "json") {
                    this.jsonurl = srcurl;
                } else if ((ext == "kml") || (ext == "gpx")) {
                    this.kmlurl = srcurl;
                    this.kmlquery = {
                            "tags": "Track",
                            "structure": "doc"
                        }
                        // console.log("kmlLOG:", this.kmlurl, this.kmlquery);
                }
            },

            getrawdata: function(ajaxresponse) {
                //console.log("getrawdata, response", ajaxresponse);
                if (!ajaxresponse || !ajaxresponse.detail) return;
                this.rawdata = ajaxresponse.detail.response;
                //if (this.rawdata) console.log("OK: trackdata", this.rawdata);
            },

            getrawdbdata: function(ajaxresponse) {
                var rawdata = ajaxresponse.detail.response;
                if (!rawdata) return {};
                console.log("rawdbdata", rawdata);
                this.rawdbdata = rawdata; // triggers 'setupTracking'
            },

            // 
            checkrawdata: function(data) {

                // Split multiLineTracks into tracksegments 
                // addressable by time every 
                var scope = this;

                function jsonTrackPreprocess(rawdata) {

                    var segfeatures = [];

                    rawdata.features.forEach(function(f, i) {

                        coordinates = f.geometry.coordinates;

                        tracktimes = f.properties.coordTimes;

                        type = f.geometry.type;

                        if (type == "MultiLineString") {

                            coordinates.forEach(function(coords, j) {

                                var cc = JSON.parse(JSON.stringify(coords)); // .slice(0);
                                var tt = JSON.parse(JSON.stringify(tracktimes[j])); // .slice(0);

                                var seg = {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "LineString",
                                        "coordinates": cc
                                    },
                                    "properties": {
                                        "coordTimes": tt,
                                        "name": tt[0],
                                        "time": tt[0],
                                        "color": scope.getRandomColor()
                                    }
                                };

                                segfeatures.push(seg);
                            })

                        } else {
                            f.properties.color = scope.getRandomColor();
                            segfeatures.push(f);
                        }
                    })

                    var segdata = {
                        "time": rawdata.time,
                        "type": rawdata.type,
                        "features": segfeatures
                    };

                    return segdata;

                }

                // Possibly geojson
                if (data && data.features) {

                    var mapdata, ddrLinecolors = [];

                    // console.log("checkrawdata, geojson-1", data)
                    data = jsonTrackPreprocess(data);
                    // console.log("checkrawdata, geojson-2", data)

                    // Quickview of raw data 
                    var mapid = "rawtracks" + data.time;
                    mapdata = {};
                    mapdata[mapid] = {
                        "layer": {
                            "type": "line",
                            "id": mapid,
                            "source": mapid
                        },
                        "srcdata": data,
                        "raw": 1
                    };

                }

                // SUPPLY mapdata
                if (mapdata) this.mapdata = mapdata;

                // SUPPLY list of tracks
                // this.rawdata = data.features;
            },

            // 
            importGPX: function(rawdata, masterdata, minTrackLength) {

                var routedata = [],
                    trackpoints, tracktimes,
                    route, tt, coordinates,
                    type, id, title;

                function gpxTime(traw) {

                    var t = traw.replace("Z", "");
                    t = t.split(":").join(".");
                    t = t.split("-").join(".");
                    t = t.split("T").join(".");
                    //aa = t.split(".");
                    //t = aa.join(".");
                    return t;
                }

                function extractPnts(coords, tt) {
                    // tracktimes = r.properties.coordTimes;
                    var tp, trackpoints = [];
                    if (!coords || !coords.length) return trackpoints;

                    coords.forEach(function(cc, j) {
                        tp = {};
                        tp.coords = [cc[0], cc[1]]; // !!! mapbox
                        tp.z = cc[2];
                        tp.ab = gpxTime(tt[j]);
                        tp.an = tp.ab;
                        trackpoints.push(tp);
                    });

                    return trackpoints;
                }

                rawdata.forEach(function(r, i) {

                    coordinates = r.geometry.coordinates;

                    tracktimes = r.properties.coordTimes;

                    type = r.geometry.type;

                    if (type == "MultiLineString") {

                        coordinates.forEach(function(coords, j) {

                            if (coords.length > minTrackLength) {

                                tt = tracktimes[j];
                                id = tt[0];

                                trackpoints = extractPnts(coords, tt);
                                // console.log(id, coords, trackpoints);

                                route = {
                                    "id": id,
                                    "title": id,
                                    "unitsystem": "metric",
                                    "trackmode": true,
                                    "nodes": trackpoints
                                };

                                routedata.push(route);
                            }
                        })

                    } else {

                        id = r.properties.time;
                        title = r.properties.name;
                        if (!title) title = id;
                        title = title.replace("ACTIVE LOG:", "");

                        if (coordinates.length > minTrackLength) {

                            trackpoints = extractPnts(coordinates, tracktimes);

                            route = {
                                "id": id,
                                "title": title,
                                "unitsystem": "metric",
                                "trackmode": true,
                                "nodes": trackpoints
                            };

                            routedata.push(route);
                        }
                    }

                })

                return routedata;
            },

            // 
            importVomue: function(rawdata, rawmode, masterdata) {
                // Dis-assemble rawdata-recordings that contain "separable tracks"  
                // with mode-specific algorithms - assigning a unique track-ID

                function handheldCoords(cc, targetformat, prec) {
                    if (!targetformat) targetformat = "dd";
                    if (!prec) prec = 6;
                    // Split into 4 parts : 
                    // latDeg, latMin, lngDeg, lngMin
                    var coords = cc.split(" ");

                    lat = coords[0];
                    lat = lat[0] == "N" ? "+" + lat.slice(1) : "-" + lat.slice(1);

                    lng = coords[2];
                    lng = lng[0] == "E" ? "+" + lng.slice(1) : "-" + lng.slice(1);

                    if (targetformat == "dd") {
                        lat = parseInt(lat) + (parseFloat(coords[1]) / 60);
                        lng = parseInt(lng) + (parseFloat(coords[3]) / 60);

                    } else if (targetformat == "dm") {
                        lat = (parseInt(lat) * 60) + parseFloat(coords[1]);
                        lng = (parseInt(lng) * 60) + parseFloat(coords[3]);
                    }
                    coords = [lng, lat]; // console.log("dd-array", dd);
                    return coords;
                };

                // 
                function handheldTime(traw, asdate) {
                    // !! for (later) use of date-parser 
                    // the MONTH must be numbered 0 .. 11 !!
                    var t, a, aa, tstandard, tdate;
                    if (typeof traw == "string") {

                        t = traw.split(":").join(".");
                        t = t.split(" ").join(".");
                        a = t.split(".");

                        aa = [a[2], a[1], a[0], a[3], a[4], a[5]]; // datum umordnen

                        tstandard = aa.join(".");

                        tdate = new Date(parseInt(aa[0]), parseInt(aa[1]) - 1, parseInt(aa[2]), parseInt(aa[3]), parseInt(aa[4]), parseInt(aa[5]));

                    } else {
                        tdate = traw;
                        tstandard = traw
                    } // console.log("handheldTime", traw, t, a, tunix)

                    if (asdate) return tdate;
                    return tstandard;
                };

                // tool STABW 
                function stabw(array) {
                    var len = 0;
                    var sum = array.reduce(function(pv, cv) {
                        ++len;
                        return pv + cv;
                    }, 0);
                    var mean = sum / len;
                    var result = 0;
                    for (var i = 0; i < len; i++)
                        result += Math.pow(array[i] - mean, 2);
                    len = (len == 1) ? len : len - 1;
                    return Math.sqrt(result / len);
                };

                var routes = {},
                    routedata = [],
                    tp, trackpoints;
                var t, dt, dx, dt_std, dx_std, v, dv_std,
                    vprev = 0;

                // Step1: Analyse STDDEV of DT, DX-data (if available)   

                var dts = [],
                    dxs = [],
                    dvs = [];

                rawdata.forEach(function(tp, j) {

                    if (rawmode == "vomue1") {
                        dt = tp["Leg Time"].split(":");
                        dx = tp["Leg Length"].split(" ");
                        v = tp["Leg Speed"].split(" ");
                    }
                    if (rawmode == "vomue2") {
                        dt = tp["dt"].split(":");
                        dx = tp["dx"].split(" ");
                        v = tp["v"].split(" ");
                    }

                    // unit 
                    dt = 3600 * parseInt(dt[0]) + 60 * parseInt(dt[1]) + parseInt(dt[2]); // always [s]
                    dx = (dx[1] == "km") ? parseInt(dx[0]) * 1000 : parseInt(dx); // always in [m] 
                    dv = parseFloat(v[0]) - vprev; // dv = is always km/h
                    vprev = parseFloat(v[0]);
                    // console.log("dv=" + dv, v);
                    dts.push(dt);
                    dxs.push(dx);
                    dvs.push(dv);
                });

                if (dts.length) {
                    dt_std = Math.round(stabw(dts));
                    dx_std = Math.round(stabw(dxs));
                    dv_std = Math.round(stabw(dvs));
                    console.log("dt-std [sec]:", dt_std);
                    console.log("dx-std [m]:", dx_std);
                    console.log("dv-std [km/h]:", dv_std);
                }

                // Step2 : 
                var trackid = 1;

                rawdata.forEach(function(tp, j) {

                    if (rawmode == "vomue1") {
                        dt = tp["Leg Time"].split(":");
                        dx = tp["Leg Length"].split(" ");
                        v = tp["Leg Speed"].split(" ");
                    }
                    if (rawmode == "vomue2") {
                        dt = tp["dt"].split(":");
                        dx = tp["dx"].split(" ");
                        v = tp["v"].split(" ");
                    }

                    dt = 3600 * parseInt(dt[0]) + 60 * parseInt(dt[1]) + parseInt(dt[2]);
                    dx = (dx[1] == "km") ? dx[0] * 1000 : dx;

                    if ((dt > dt_std) || (dx > dx_std)) trackid = trackid + 1;

                    tp.id = trackid;

                });

                // B. GROUP all TP-records by id 
                //    into track-objects 

                rawdata.forEach(function(tp, j) {
                    var tpx = {};

                    Object.keys(tp).forEach(function(k) {

                        if (rawmode == "vomue1") {
                            if (k == "Position") {

                                coords = handheldCoords(tp[k]);
                                tpx["coords"] = coords;

                            } else if (k == "Time") {

                                time = handheldTime(tp[k]);
                                tpx["ab"] = time;
                                tpx["an"] = time; // 

                            } else {
                                tpx[k] = tp[k];
                            }
                        }

                        if (rawmode == "vomue2") {
                            if (k == "coords") {
                                coords = handheldCoords(tp[k]);
                                tpx["coords"] = coords;
                            } else if (k == "Date") {
                                time = handheldTime(tp[k]);
                                tpx["ab"] = time;
                                tpx["an"] = time; // 
                            } else {
                                tpx[k] = tp[k];
                            }
                        }
                    })

                    if (!tpx.coords) {
                        console.log("TP-record without coords", tp);
                    } else {
                        // Distribute the trackpoints into "separable" tracks
                        // (if wpts are pre-grouped by track-id)  
                        if (tp.id) {
                            id = tp.id;
                            route = routes[id];
                            if (!route) {
                                route = [];
                                routes[id] = route;
                            }
                        } else {
                            route = routes["raw"];
                            if (!route) {
                                route = [];
                                routes["raw"] = route;
                            }
                        }
                        // console.log(tpx);
                        route.push(tpx);
                    }

                }.bind(this));

                // console.log("raw routes", routes);

                // C. Join temporary masters- and routes-objects 
                //    into array of api-conform routedata (wps sorted by time) 

                Object.keys(routes).forEach(function(id) {

                    trackpoints = routes[id];

                    trackpoints.sort(function(wp1, wp2) {
                        return mba.utcTime(wp1.ab) - mba.utcTime(wp2.ab);
                    });

                    if (Object.keys(trackpoints).length > 5) {
                        var title = trackpoints[0].ab;
                        var route = {
                            "id": id,
                            "title": title,
                            // "icon": icon,
                            "unitsystem": "metric",
                            "nodes": trackpoints
                        };

                        // Optionally: include Stammdaten
                        if (masterdata && masterdata[id] && this.connect) {
                            route["master"] = masterdata[id];
                        }
                        // *** Required ***  
                        route.trackmode = true;

                        routedata.push(route);
                    }
                }.bind(this));

                return routedata;
            },

            // SPECIFIC import of gps-device data 
            // delivered in csv- or tabbed formats 
            // into datastructure of routing-API
            importTracks: function(rawdata, rawdbdata) {
                if (!rawdata || !rawdata.length) return;

                var debounceTime = 200;
                var minTrackLength = 5;

                this.debounce('import', function() {

                    console.log("LOG: Handheld raw data", {
                        "location": rawdata,
                        "master": rawdbdata
                    }); // return;

                    /**
                     *  transform from handheld-data (exported as tabbed text or csv)
                     */
                    /* var route, master, id,
                        routes = {},
                        masterdata = {};
                    var coords, time, id, lat, route,
                        timeunit = "s",
                        route0 = [],
                        routes = []; */


                    // Optional: Append track-masterData     
                    if (rawdbdata) {
                        // A. Redistribute raw master-data and wp-records into temporary objects (masters, routes) 
                    }

                    //  A.1 MODE Detector    
                    var rawmode = (rawdata[0]["geometry"]) ? "json" : "nn";
                    rawmode = (rawdata[0]["Header"] == "Trackpoint") ? 'vomue1' : rawmode;
                    rawmode = rawdata[0]["Pnt"] ? 'vomue2' : rawmode;
                    if (rawmode == "nn") {
                        console.log("BREAK. Selected dataset cannot be analysed!!");
                        return;
                    }

                    console.log("Handheld-datamode detected: ", rawmode);

                    var routedata = [];
                    //     
                    if (rawmode == "json") {

                        routedata = this.importGPX(rawdata, rawdbdata, minTrackLength);

                    } else if (rawmode.indexOf("vomue") >= 0) {

                        routedata = this.importVomue(rawdata, rawmode, rawdbdata, minTrackLength);
                    }

                    if (routedata && routedata.length) {
                        // console.log("JSON-Handheld routedata:", routedata); // , rawdata);
                        this.routedata = routedata;
                    }

                }.bind(this), debounceTime);

            },

            // B. COMPILE Feature-data 
            /**
             * Create some formatted html-text(dom?) 
             * to identify basic properties of an animated object (animation status)
             *
             * @param      {<type>}  trackObj  The animated trackObj (as mb-feature)
             * @return     {string}  A formatted information about trackObj-status.
             */
            calcBasicInfo: function(trackObj) {
                if (!trackObj || !trackObj.properties) return;

                var trackInfo = "<b>" + trackObj.properties.id + "</b>" + "<br>";
                if (trackObj.properties.time) trackInfo += trackObj.properties.time + "<hr>";

                if (trackObj.properties.speed) trackInfo += "SOG: " + trackObj.properties.speed + " nds <br>";
                if (trackObj.properties.bearing) trackInfo += "Head: " + trackObj.properties.bearing + "°<hr>";

                return trackInfo;
            },

            /**
             * Build (app-specific) trackData extending the basic infoSet 
             * to enable enhanced presentation of trackObj
             *
             * @param      {<type>}  trackObj  The track object
             * @param      {<type>}  openFlag  The open flag
             * @return     {<type>}  The more track data.
             */
            calcExtendedInfo: function(trackObj, openFlag) {
                if (!trackObj || !trackObj.properties) return;

                var basicInfo = this.calcBasicInfo(trackObj);

                var extendedData = {
                    "title": trackObj.properties.title,
                    "html": basicInfo,
                    "properties": trackObj.properties
                };

                if (openFlag) {
                    extendedData.open = 1;
                }

                if (trackObj.properties.master) {
                    extendedData.headline = trackObj.properties.master.skipper;
                }
                // console.log("calcTrackData", trackObj, trackData)
                return extendedData;
            },


            // C.  FORMAT INFO-Card 

            refreshCardContent: function(data) {
                var nbsp = "&nbsp;"; //"~"; 
                if (!data) return;

                // if (data.properties && data.properties.master) {
                // var pp = JSON.parse(data.properties.master);
                if (this.masterdata && data.properties.id) {
                    // 
                    pp = this.masterdata[data.properties.id];
                    if (pp) {
                        // console.log("masterdata:", pp);
                        // DIV0
                        var imgurl = pp.img,
                            skipper = pp.skipper,
                            boat = pp.ship,
                            header = "";

                        if (imgurl) this.cardimgurl = "wp-data/" + imgurl;
                        // console.log("some data ", imgurl, this.cardimgurl, skipper, boat);

                        if (skipper && boat) {

                            // to show items with no line-breaks (fi. in flex-formatted cards)
                            // replace many spaces 
                            skipper = skipper.split(' ').join(nbsp);
                            boat = boat.split(' ').join(nbsp);
                            // statt: 
                            // skipper = skipper.replace(" ", nbsp);
                            // boat = boat.replace(" ", nbsp);

                            header = "<b>" + boat + "</b>" + "<br>" + skipper;

                            this.$.div0.innerHTML = header;
                        }
                    }
                }

                // DIV1
                if (data.html) this.$.div1.innerHTML = data.html;
            }

        });
    </script>

</dom-module>