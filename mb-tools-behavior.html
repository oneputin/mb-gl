<link rel="import" href="../polymer/polymer.html">

<script>
    Polymer.ToolsBehaviorImpl = {

        properties: {},

        // Refresh content && location 
        // of an app-specific mapbox-popup 
        // default: html at map-center  
        popupOnMap: function(popupcontent) {
            if (!this.map) return;
            // console.log("popupcontent",popupcontent);
            var html, lnglat, openflag,
                map = this.map; // popup = this.popup;

            // Prepare a "" Info-Popup
            // to be closed on x-mark
            if (!this.popup) {
                this.popup = new mapboxgl.Popup({
                    closeButton: true,
                    closeOnClick: false
                });
            }

            if (typeof popupcontent == "object") {
                html = popupcontent.html;
                lnglat = popupcontent.lnglat;
                openflag = popupcontent.open;
            } else if (popupcontent) {  // String
                html = popupcontent;
            }
            if (!popupcontent || !html || (openflag == false) || this.trackmapmode) {
                this.popup.remove();
                return;
            }

            // Refresh popup contet and location
            if (!lnglat) lnglat = map.getCenter();

            if (!this.popup.isOpen()) this.popup.addTo(map);

            this.popup
                .setLngLat(lnglat)
                .setHTML(html);
        },

        // derive comparable/calculable times
        // from dates of type "2016.12.11,16.00" or "2016.12.16,16:00"
        utcTime: function(t, lonlat, unit) {
            // !! for parser the MONTH must be numbered 0 .. 11 !!
            var tlocal;
            if (typeof t == "string") {
                var t = t.replace(",", "."),
                    t = t.replace(":", "."),
                    a = t.split(".");

                // Time intervals 
                if (a[0] == "0") {
                    a[0] = "1970";
                    if (a[1] == "0") {
                        a[1] = "1";
                        if (a[2] == "0") {
                            a[2] = "1";
                            if (a[3] == "0") {
                                a[3] = "1";
                                if (a[4] == "0") {
                                    a[4] = "1";
                                }
                            }
                        }
                    }
                    // console.log("utcTime", t, a);
                }

                if (a.length > 5) { // 
                    tlocal = new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]), parseInt(a[5]));
                } else {
                    tlocal = new Date(parseInt(a[0]), parseInt(a[1]) - 1, parseInt(a[2]), parseInt(a[3]), parseInt(a[4]));
                }
            } else {
                tlocal = t;
            }

            var tg = tlocal,
                tunit = tg;

            if (unit == "h") tunit = tg / (1000 * 3600);
            else if (unit == "s") tunit = tg / 1000;
            else tunit = tg; // [ms]

            return tunit;
        },

        trackTime : function (traw, asarray) {
            var t = traw.replace("Z", "");
            t = t.split(":").join(".");
            t = t.split("-").join(".");
            t = t.split("T").join(".");
            // console.log(t);
            if (asarray)  return t.split(".");
            return t;
        },

        deltaL : function(aLine, unit) {
          // aLine must be an element of src-data (!!!) , here   
          var unitshort ;
          if (!unit) unit="kilometers";
          if (unit=="kilometers") unitshort ="km";
          if (unit=="miles") unitshort ="mi";
          if (unit=="nautic") {
              unit="kilometers";
              unitshort ="nm";
          }    
          var dl = turf.lineDistance(aLine, unit);
          if (typeof dl == "number") {
              if (unitshort=="nm") dl = dl / 1.856; 
              dl = this.toFixed(dl, 3) + unitshort;
          }    
          return dl;
        },


        // Create readable time period h:min
        // from unixTime as [h]
        deltaT: function(t, fallback) {
            var h = Math.floor(t),
                m = Math.round((t - h) * 60);
            if (h > 0) h = h < 10 ? "0" + h + "h" : h + "h";
            else h = "";
            m = (m < 10) ? "0" + m : m;
            return h || m ? h + m + "min" : fallback;
        },

        /**
         * formats lonlat into [180W - 180E] if requested from "extended" mapview 
         */
        formatlonlat: function(lnglat, format, zoom) {
            if (!lnglat) return "";
            if (!zoom) zoom = 5;
            // console.log("apply formatlonlat on:", lnglat, zoom);

            var prec = zoom > 10 ? 1 : 0;
            var lon, lat;
            var trafo = format == "dms" ? this.ddtodms : this.ddtodm; // ddtodms;

            if (typeof lnglat == "string") {
                lon = lnglat.split(",")[0];
                lat = lnglat.split(",")[1]
            } else {
                lon = lnglat.lng;
                lat = lnglat.lat;
            }

            var lonunit = ((lon < 0) && (lon > -180)) || (lon > 180) ? "W" : "E",
                latunit = lat < 0 ? "S" : "N";

            var lonx = trafo(lon, "lon"),
                latx = trafo(lat, "lat");
            // console.log("lon,lat",lon,lat,"lonx,latx",lonx,latx)

            return lonx + lonunit + "  " + latx + latunit;
        },

        /**
         *  transform digitaldegree to dms
         */
        ddtodms: function(dd, prec) {
            if (!prec) prec = 0;
            dd = parseFloat(dd);
            if (dd < 0) dd = 0 - dd;
            let d = Math.floor(dd), // console.log("dd,d=", dd, d)
                mm = (dd - d) * 60, // [minutes]
                m = Math.floor(mm), // [minutes]
                ss = ((mm - m) * 60).toFixed(prec);
            if (ss == "60") {
                m = m + 1;
                ss = "00";
            }
            return d + "°" + m + "'" + ss + '"';

        },

        /**
         *  transform digitaldegree to d-m with 3 digits (last digit ca 1-2m)
         *  "maritime formatting"  
         */
        ddtodm: function(dd, lonflag, prec) {
            if (!prec) prec = 3;
            dd = parseFloat(dd);

            // lon only
            if (dd > 180) dd = 360 - dd;
            if (dd < -180) dd = 360 + dd;
            // lon and lat
            if (dd < 0) dd = 0 - dd;

            let d = Math.floor(dd), // console.log("dd,d=", dd, d)
                mm = (dd - d) * 60; // [minutes]
            m = mm.toFixed(3);

            if (d < 10) d = "0" + d;
            if (d < 100 && lonflag) d = "0" + d
            if (mm < 10) m = "0" + m;

            return d + "°" + m;
        },

        /**
         * Back-transform of "formatted" dm into raw dd
         * (fi vendee-data: "lat": "49°43.00'S", 
         *                  "lng": "162°32.42'E"
         */
        dmtodd: function(dm, lonflag, prec) {
            if (!prec) prec = 6;
            dm = dm.split("°"); // console.log("dm-array", dm);
            dd = parseInt(dm[0]) + parseFloat(dm[1]) / 60;
            if (dm[1].slice(-1) == "W") dd = 0 - dd;
            if (dm[1].slice(-1) == "S") dd = 0 - dd;
            return dd;
        }



        /**
         * 
         */
        logTime: function(ms1970, unit, sep) {
            // if (!sep) sep = ", ";
            if (unit == "h") ms1970 = ms1970 * 3600 * 1000;
            var logtime = new Date(ms1970);
            //  logtime = logtime.getDate() + "." + (logtime.getMonth() + 1) + ", " + logtime.getHours() + ":" + logtime.getMinutes();

            var D = logtime.getDate(),
                D = D < 10 ? "0" + D : D,

                M = logtime.getMonth() + 1,
                M = M < 10 ? "0" + M : M,

                h = logtime.getHours(),
                h = h < 10 ? "0" + h : h,

                m = logtime.getMinutes(),
                m = m < 10 ? "0" + m : m;

            var logdate = D + "." + M;
            logtime = h + ":" + m;
            if (sep) {
                logtime = logtime + sep + logdate;
            }
            return logtime;
        },

        // 
        setFeatureBounds: function(features, map) {

            if (features.features) features = features.features; //console.log(data); // return
            if (!features.length) return; //console.log(features); 
            // console.log("1-bounddata(features)", features);

            // concat coordsets (x,y) and (x,y,z) into (x,y)
            function concatcoords(coordinates, segment) {
                segment.forEach(function(cc) {
                    cc = [cc[0], cc[1]];
                    coordinates.push(cc);
                })
                return coordinates;
            }

            // Transform into list of coordinate-lists
            var coordinates = [],
                segments, coords, pnt, latitude, longitude, bb = {};

            for (var i = 0; i < features.length; i++) {
                t = features[i].geometry.type;
                segments = features[i].geometry.coordinates;
                if (t == "LineString") {
                    // coordinates = coordinates.concat(segments);
                    coordinates = concatcoords(coordinates, segments);
                } else if (t == "MultiLineString") {
                    for (var j = 0; j < segments.length; j++) {
                        // coordinates = coordinates.concat(segments[j]);
                        coordinates = concatcoords(coordinates, segments[j]);
                    }
                }
            };

            // Correctur datumsgrenze
            coordinates.forEach(function(coord) {
                if (coord[0] > 180) coord[0] = coord[0] - 360;
                if (coord[0] < -180) coord[0] = coord[0] + 360;
            });
            // console.log("2-coordinates", coordinates);

            // Pass the first coordinates to `lngLatBounds` 
            // & wrap each coordinate pair in `extend` to include them in the bounds result. 
            var bounds = coordinates.reduce(function(bounds, coord) {
                return bounds.extend(coord);
            }, new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]));
            //console.log("4-totalbounds", bounds);

            if (!map) return bounds;

            map.fitBounds(bounds, {
                padding: 20
            });
        },

        // get color in hex-format
        getRandomColor: function() {
            var letters = '0123456789ABCDEF';
            var color = '#';
            for (var i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        },

        // extended version optionally negative precision
        toFixed : function(number, precision) {
            var factor = Math.pow(10, precision);
            var tempNumber = number * factor;
            var roundedTempNumber = Math.round(tempNumber);
            return roundedTempNumber / factor;
        }
    };

    /** @polymerBehavior */
    Polymer.ToolsBehavior = [
        Polymer.ToolsBehaviorImpl
    ];
</script>