<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="geotags-from-gpx.html">
<link rel="import" href="tracks-behavior.html">

<!--
`layer-waypoints`
component loadswaypoint data 
- from location sets of different formats
    - raw handheld (gps as gpx)
    - tabular handheld export (gps as csv)
    - tabular database export (vendee-tables)

@demo demo/routingtracks.html 
-->

<dom-module id="layer-waypoints">

    <template>

    <style is="custom-style">
        :host {
            display: none; /*inline-block;*/
            position: absolute;
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <geotags-from-gpx 
        tagname = "Waypoint"
        srcmeta="[[srcmetax]]"
        tagdata="{{_rawdata}}">
    </geotags-from-gpx>    

    <content>
    </content>    

</template>

    <script>
        var wpscope;
        Polymer({
            is: 'layer-waypoints',

            properties: {

                layerid : {
                    type: String,
                    value: "waypoints"
                },

                tagname : {
                    type: String,
                    value: "Waypoint"                   
                },

                // id of mb-style
                mbid : {
                    type: String
                },


                visible : {
                    type: Boolean,
                    value: false,
                    observer: '_layerVisibility'
                },

                /** metadata describing rawdata to load
                 */
                querymeta: {
                    type: Object
                },

                // OUT: TRACKS as static log conternt
                wpdata: {
                    type: Object,
                    notify: true
                },

                // raw data imported from different  
                _rawdata: {
                    type: Object
                },

            },

            behaviors: [
            ],

            observers: [
                '_requestManager(querymeta.*, tagname)',
                '_responseManager(_rawdata, mbid)'
            ],

            attached: function() {
                wpscope = this;
            },

            // Process selected feature
            clickAction : function(feature) {
                if (!feature) return;
                var meta = this.querymeta,
                    lnglat = feature.geometry.coordinates,
                    pp = feature.properties;  
                
                var html = "<h3>Waypoint</h3>";
                if (meta) {
                    html = "<h3>WP in [" +meta.title+ "] </h3>"; 
                }
                html = html + pp.time
                     + "<hr/>" + pp.name
                     + "<br/>z = "+pp.coordElevs+" m";

                new mapboxgl.Popup()
                    .setLngLat(lnglat)
                    .setHTML(html)
                    .addTo(map);
            },


            // Toggle layer-visibility
            _layerVisibility : function(flag){ // console.log("SET _layerVisibility", flag);
                if (!map) return;  
                if (flag)  map.setLayoutProperty(this.layerid, 'visibility', 'visible');
                else map.setLayoutProperty(this.layerid, 'visibility', 'none');
            },

            // 
            _layerStatus : function(layid) {
                if (!layid) layid = this.layerid;
                var status = {
                    id : layid,
                    layer : map.getLayer(layid),
                    src :  map.getSource(layid)
                }    
                return status;  
            },

            /** Prepares import of rawdata
             *  - from alternative low-level import-components (evaluates metadata)  
             *  - with structures dependent on routemode
             */
            _requestManager: function(srcmeta, gpxtagname) {

                this.debounce("request", function() {  
                    if (srcmeta.path == 'querymeta') srcmeta = srcmeta.value;

                    var srcurl = srcmeta.url,      // 
                        srctype = srcmeta.type,    // 
                        srctitle = srcmeta.title;  // 

                    // Check some url - conditions ???
                    if (!srcurl) {
                        return;
                    } // console.log("_requestManager", srcmeta); 

                    if (this.querymeta && (srcurl != this.querymeta.url)) {
                        //this.routecontent = [];
                        //this.rawdata = [];
                        srctitle = this.querymeta.title;
                    } 

                    // Extend metadata with Query/Format - parameters
                    if ((srctype == "kml") || (srctype == "gpx")) {

                        srcmeta.xmlquery = {};
                        if (srcmeta.query) {  
                            srcmeta.xmlquery = srcmeta.query;
                        } 
                    
                        if (srctype == "gpx") {
                            // ALWAYS extract only tracks (neither waypoints or routes)
                            srcmeta.xmlquery["tags"] = gpxtagname;
                            srcmeta.xmlquery["structure"] = "doc";
                        } 
                        srctype = "xml"; 
                    }  // console.log("THEMEREQUEST based on", srcmeta) ; 

                    // trigger one of alternative import-elements
                    if (srctype == "xml")  {
                        this.srcmetax = srcmeta;
                        this.srcmetad = null;
                    } else {
                        this.srcmetad = srcmeta;
                        this.srcmetax = null;
                    }   

                }, 100);   

            },

            /** 
             * rawdata  
             * mbid     trigger reset in new mb-style
             * 
             * Postprocess raw geoJson-data into mb-Layer(s) 
             */    
            _responseManager : function(rawdata, mbid) {
                if (!rawdata) return;  // console.log("WP-REFRESH ", rawdata, mbid);  // return; 
                rawdata  = this._refreshLayer(rawdata);
                if (!rawdata) return;  

                this.wpdata = rawdata;
                // this._rawdata = null; // do NOT !!!
            },

            // generic click-listener
            _clickListener : function(e) {
                var st = wpscope._layerStatus(); 
                if (!st.layer) return ;  

                var features = map.queryRenderedFeatures(e.point, {
                    layers: [st.id]
                });
                if (!features || !features.length) return;   

                wpscope.clickAction(features[0]);
            }, 

            // Combine rawdata and metadata into contentObj 
            // (with mb-preview-properties) 
            _refreshLayer: function(rawdata) {
                var st = this._layerStatus();  // console.log("CREATELAYER: " + st.id, st, this.querymeta); 
                if (!st.src) {
                    map.addSource(st.id, {
                        "type": "geojson",
                        "data": {
                            "type": "FeatureCollection",
                            "features": rawdata.features
                        }
                    });
                } else { // console.log("REFRESH SRC from ", rawdata);
                    map.getSource(st.id).setData(rawdata);
                    // st.src.setData(features);
                }
                
                if (!st.layer) {
                    var vis = "none";
                    if (this.visible) vis = "visible";
                    map.addLayer({
                        "id": st.id,
                        "type": "circle",
                        "source": st.id,
                        "layout" : {
                            "visibility": vis
                        },
                        "paint": {
                            "circle-radius": 6,
                            "circle-color": "#B42222"
                        },
                        "filter": ["==", "$type", "Point"],
                    });
                }    

                if (this.clickAction) {
                    map.off('click', this._clickListener);
                    map.on('click', this._clickListener);
                } 
                if (this.hoverAction) {
                    map.off('hover', this.hoverListener);
                    map.on('hover', this.hoverListener);
                } 

                return st;
            }

        });
    </script>

</dom-module>