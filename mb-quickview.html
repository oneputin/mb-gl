<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-tools-behavior.html">

<!--
`mb-quickview`
quick preview of "mapcontent" supplied in "quickformat" fi. 
- derived from raw kml- or gpx-datasets
- created for routing-api

`quickformat` - object:

        quickmap[mapid] = {
            "layer": {
                "type": "line",
                "id": mapid,
                "source": mapid
            },
            "srcdata": srcdata,
            "raw": 1
        };

@demo demo/routinghandheld.html 
-->

<dom-module id="mb-quickview">

    <template>

        <style>
            :host {
                display: block;
                /*position: absolute;*/
            }
        </style>

    </template>

    <script>
        
        Polymer({
            is: 'mb-quickview',

            properties: {
                /**
                 *  map-object available for query and manipulation outside 
                 */
                map: {
                    type: Object,
                    observer: "setupTool"
                },
                // 
                mapcontent: {
                    type: Object
                },

                // features of (all) json-layers loaded
                // !! grouped by layer !!
                mapfeatures: {
                    type: Object,
                    value: {},
                },

                featurelist: {
                    type: Array,
                    value: [],
                    notify: true
                },

                featureselected: {
                    type: Object,
                    observer: 'zoomToFeature'
                },

                checked: {
                    type: Boolean,
                    value: true,
                    observer: "toggleTool"
                }

            },

            behaviors: [
                Polymer.ToolsBehavior
            ],

            observers: [
                'mapContentUpdate(mapcontent.*)',
                'mapContentFeatureList(mapfeatures.*)'
            ],

            setupTool: function(map) {
                if (!map) return;
                // console.log("setup map with content:", this.mapcontent);
                if (this.mapcontent) {
                    this.mapContentPrepare(this.mapcontent);
                }    
            },

            toggleTool: function(checked) {
                // console.log("checked Tool:", checked)
                // console.log("this=", this);
            },

            attached: function() {
                // this.installmap();
            },

            zoomToFeature: function(f) {
                if (!f.feature) return;
                // console.log("zoomToFeature: " + f.id, f.feature);
                this.setFeatureBounds([f.feature], this.map);
            },

            /**
             * Create a list of all features  contained in 'mapfeatures'-collection 
             * and supply to container ("notified" property)
             */
            mapContentFeatureList: function(mapfeatures) {
                if (!this.checked) return;

                if (mapfeatures.path == 'mapfeatures') mapfeatures = mapfeatures.value;
                if (!mapfeatures || !Object.keys(mapfeatures).length) return;
                // console.log("mapfeatures after change:", mapfeatures);

                var featurelist = [];
                Object.keys(mapfeatures).forEach(function(f) {
                    mapfeatures[f].forEach(function(item) {
                        featurelist.push(item);
                    })
                });
                // console.log("featurelist", featurelist); 
                this.featurelist = featurelist; // notifies !!
            },

            /**
             * Create/Refresh ii(maps)Layers 
             * delivered with mapcontent container
             */
            mapContentUpdate: function(mapcontent) {
                if (!this.map || !this.checked) return;
                // remove old content
                this.mapContentClear();
                // add new content
                this.mapContentPrepare(mapcontent); 
            },    
              
            mapContentClear: function() {
                var map = scope.map;
                var lastContent = Object.keys(this.mapfeatures);
                if (!lastContent.length) return; 

                lastContent.forEach(function(layername) { // console.log("remove Qview-layer(s)"+layername);
                    if (map.getLayer(layername)) map.removeLayer(layername);
                    if (map.getLayer(layername+"-hover")) map.removeLayer(layername+"-hover");
                    if (map.getLayer(layername+"-nodes")) map.removeLayer(layername+"-nodes");
                    if (map.getLayer(layername+"-trace")) map.removeLayer(layername+"-trace");
                });  
                lastContent.forEach(function(layername) { // console.log("remove source"+layername);
                    if (map.getSource(layername)) map.removeSource(layername);
                    if (map.getSource(layername+"-nodes")) map.removeSource(layername+"-nodes");
                    if (map.getSource(layername+"-trace")) map.removeSource(layername+"-trace");
                });  
                
                this.mapfeatures = {};
            },

            mapContentPrepare: function(mapcontent) {    
                // console.log("mapContentPrepare", mapcontent, this.map, this.checked);
                if (mapcontent.path == 'mapcontent') mapcontent = mapcontent.value;
                if (!mapcontent || !Object.keys(mapcontent).length) return;

                var scope = this,
                    map = scope.map,
                    mapfeatures = {};

                // Get Info about "complete track", not only features in actually "visible" tile(s)
                function getTrackInfo(aLine, layerid) {
                    
                    var trackLayer = map.getLayer(layerid),
                        trackSource = map.getSource(trackLayer.source),
                        srcFeatures = trackSource._data.features,

                        trackInfo = aLine.properties; // console.log("trackInfo", trackInfo, srcFeatures); 
                    
                    // Heuristik to identify suitable filter-key  
                    var keyname, idNames = ["id", "name", "key", "time"];
                    idNames.forEach(function(nom) {
                        if (trackInfo[nom] && !keyname) keyname = nom;
                    });

                    var coords; 
                    if (keyname) {
                        trackInfo.keyname = keyname;  
                        trackInfo.keyvalue = trackInfo[keyname];  
                        
                        srcFeatures.some(function(f){
                            if (f.properties[keyname] == trackInfo[keyname]) {
                                // console.log("detected", trackInfo[keyname], f);
                                trackInfo.bbox = scope.setFeatureBounds([f]);
                                trackInfo.coords = f.geometry.coordinates;
                                trackInfo.fromnode = trackInfo.coords[0];
                                trackInfo.tonode = trackInfo.coords[trackInfo.coords.length - 1];
                                trackInfo.length = scope.deltaL(f);
                                return true;
                            }
                        });
                    }
                    
                    if (trackInfo.coordTimes) {
                        var trackTimes = JSON.parse(trackInfo.coordTimes),
                            n = trackTimes.length, // equal to number of coords
                            von = scope.utcTime(scope.trackTime(trackTimes[0]), null, "h"),
                            bis = scope.utcTime(scope.trackTime(trackTimes[n - 1]), null, "h"),
                            dt = bis - von;
                        trackInfo.von = scope.logTime(von,"h");
                        trackInfo.bis = scope.logTime(bis,"h");
                        trackInfo.duration = scope.deltaT(dt);
                        trackInfo.count = n;
                    }

                    trackInfo.html = trackInfo.time +
                        "<br>Length: " + trackInfo.length +
                        "<br>Duration: " + trackInfo.duration +
                        "<br>TP's: " + trackInfo.count;

                    // console.log(trackTimes);
                    // console.log(info);
                    return trackInfo;
                }

                // Generic HILITE-function based on "id-Filter"	
                function hiliteTrack(e, layerid, featurekey) {

                    if (!map.getLayer(layerid)) return;
                    if (!map.getLayer(layerid + "-hover")) return;

                    // 
                    var hilayerid, hifilter;

                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [layerid]
                    });

                    map.getCanvas().style.cursor = (features.length) ? 'pointer' : ''; // crosshair';

                    if (features && features.length) { 

                        var trackInfo = getTrackInfo(features[0], layerid);

                        scope.popupOnMap(trackInfo.html);

                        if (!trackInfo.keyname) {
                             console.log("hi " + layerid + ":", trackInfo);
                        
                        } else {    // Filtering the HOVER-Layer

                            var keyname = trackInfo.keyname; 

                            hifilter = ["==", keyname, trackInfo[keyname]];
                            // console.log("hi " + layerid + ":", trackInfo.length+" km");

                            hilayerid = layerid + "-hover";
                           
                            map.setFilter(hilayerid, hifilter);
                        }
                    } else {
                        map.setFilter(layerid + "-hover", ["==", "name", ""]);
                    }

                }

                // Track-Select 
                //   - zooms to the track
                //   - show start/stop based on "id-Filter"	
                function selectTrack(e, layerid, featurekey) {
                    // console.log("selectTrack", layerid, featurekey); 
                    // ONLY for 
                    if (!map.getLayer(layerid)) return;
                    // if (!map.getLayer(layerid + "-select")) return;

                    // 
                    function setTrackNodes(id, trackInfo) {
                        // 
                        id = id + "-nodes";
                        if (map.getLayer(id)) map.removeLayer(id); 
                        if (map.getSource(id)) map.removeSource(id); 

                        var fromnode = trackInfo.fromnode.slice(0,2),
                            tonode = trackInfo.tonode.slice(0,2),
                            fromtime = trackInfo.von,
                            totime = trackInfo.bis;

                        map.addSource(id, {
                            "type": "geojson",
                            "data": {
                                "type": "FeatureCollection",
                                "features": [{
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Point",
                                        "coordinates": fromnode
                                    },
                                    "properties": {
                                        "title": fromtime,
                                        "icon": "monument"
                                    }
                                }, {
                                    "type": "Feature",
                                    "geometry": {
                                        "type": "Point",
                                        "coordinates": tonode
                                    },
                                    "properties": {
                                        "title": totime,
                                        "icon": "harbor"
                                    }
                                }]
                            }
                        });    
                       
                        map.addLayer({
                            "id": id,
                            "type": "symbol",
                            "source": id,
                            "layout": {
                                "icon-image": "{icon}-15",
                                "text-field": "{title}",
                                "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                "text-offset": [0, 0.6],
                                "text-anchor": "top"
                            }
                        });
                    } 

                    // Filtering the TRACE-Layer
                    function setTrackTrace(id, trackInfo) {
                        // 
                        var hilayerid = id + "-trace", // ?
                            keyname = trackInfo.keyname, 
                            hifilter = ["==", keyname, trackInfo[keyname]];
                        
                        if (!map.getLayer(hilayerid)) return ;

                        map.setFilter(hilayerid, hifilter);
                    } 

                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [layerid]
                    });

                    if (features && features.length) { 

                        var trackInfo = getTrackInfo(features[0], layerid);
                        // console.log("Selected feature(s)", trackInfo);  

                        // SHOW start- and stop-nodes
                        setTrackNodes(layerid, trackInfo); 

                        // SHOW start- and stop-nodes
                        setTrackTrace(layerid, trackInfo); 

                        // ZOOM to complete track
                        map.fitBounds(trackInfo.bbox, {
                            padding: 40
                        });

                    } else {
                        
                    }
                    
                }

                // Layer that occurs on-mose-hover only 
                function createHiliteLayer(layertemplate, hitype) {
                    var lhilite = {}; // layertemplate,
                    var basetype = layertemplate.type;
                    Object.keys(layertemplate).forEach(function(k) {
                        lhilite[k] = layertemplate[k];
                    })

                    var linecolor, linewidth, lineopacity, linedasharray;
                    if (hitype == "hover") {
                       linecolor = "#FF0000";
                       linewidth = 5;
                       lineopacity = 1;
                    } else {
                       linecolor = "#000000";
                       linewidth = 3;
                       lineopacity = 0.7;
                       linedasharray = [4,4];  
                    }

                    lhilite.id = layertemplate.id + "-" + hitype;

                    lhilite.filter = ["==", "id", ""];

                    if (basetype == "fill") {
                        lhilite.paint = {
                            "fill-color": "#627BC1",
                            "fill-opacity": 1
                        }

                    } else if (basetype == "line") {
                        lhilite.paint = {
                            "line-color": linecolor,
                            "line-width": linewidth,
                            "line-opacity": lineopacity,
                        }
                        if (linedasharray)  lhilite.paint["line-dasharray"] = linedasharray;

                    } else if (basetype == "symbol") {
                        lhilite.layout = {
                            "opacity": 1
                        }
                    }
                    //console.log("Created HOVER", basetype, lhilite);
                    return lhilite;
                }

                // add temporary paint-properties 
                // to better identify features (line-width, random colors)
                function rawBeautify(layerObject) {

                    var srcdata = layerObject.srcdata;

                    var lookuplist = [], paintObj;

                    srcdata.features.forEach(function(f) {
                        var col = f.properties.color;
                        lookuplist.push([col, col]);
                    });
                    paintObj = {
                        "line-width": 3,
                        "line-color": {
                            property: 'color',
                            type: 'categorical',
                            stops: lookuplist
                        }
                    }; // console.log("rawBeautify", paintObj);
                    
                    layerObject.layer.paint = paintObj;

                    return layerObject.layer;
                }

                // Create (multiple) layers to create "" 
                function getLayerTemplates(layerObject) {

                    var layerTemplates = []
                    layerTemplate = layerObject['layer'];

                    if (layerTemplate) layerTemplates.push(layerTemplate);

                    // Insert BELOW main layer 
                    if (layerObject['bglayer']) layerTemplates.splice(0, 0, layerObject['bglayer']); // !!! 

                    if (layerObject['selectlayer']) {
                        layerObject['selectlayer'].forEach(function(l) {
                            layerTemplates.push(l);
                        })

                    } else if (layerTemplate) { // "Standardisierte" HILITE-Layers
                        
                        let hoverTemplate = createHiliteLayer(layerTemplate, "hover");
                        if (hoverTemplate) layerTemplates.push(hoverTemplate);

                        let traceTemplate = createHiliteLayer(layerTemplate, "trace");
                        if (traceTemplate) layerTemplates.push(traceTemplate);
                    }

                    return layerTemplates;
                }

                // create linear list of features 
                // suitable for "menu-generation"
                function getFeatures(layerData, layername, longtitle) {

                    var flist = [],
                        fitem = {},
                        id, title;
                    if (!layerData || !layerData.features) return flist;

                    layerData.features.forEach(function(f) {
                        id = f.id;
                        if (!id) id = f.properties.name;
                        if (!id) id = f.properties.time;
                        // Typische Nachbearbeitung
                        id = id.replace("ACTIVE LOG:", "");
                        title = id.replace(/-/g, "_");

                        if (longtitle) title = layername + "_" + title;
                        title = title.replace(/ /g, "");

                        fitem = {
                            "layer": layername,
                            "id": id,
                            "title": title,
                            "feature": f
                        };
                        flist.push(fitem);
                    })

                    return flist;
                }

                // console.log("IIMAP-refresh of with:", mapcontent);

                // --------------------------------------------------

                var mapcontentLayers = Object.keys(mapcontent);  // console.log("Refreshing iimap-layers", mapcontentLayers);

                mapcontentLayers.forEach(function(layername, j) {

                    function hiliter(e) {
                        hiliteTrack(e, layername);
                    }
                    function selector(e) {
                        selectTrack(e, layername);
                    }

                    var layerObject = mapcontent[layername];

                    // 
                    if (layerObject.raw) rawBeautify(layerObject);

                    var layerTemplates = getLayerTemplates(layerObject);

                    // REMOVE layers (on demand) 
                    if (layerObject.delete) { // ??? 

                        if (map.getSource(layername)) map.removeSource(layername);

                        layerTemplates.forEach(function(l) {
                            if (map.getLayer(l.id)) map.removeLayer(l.id);
                        });

                        map.off("mousemove", hiliter)
                        map.off("click", selector)

                        return;
                    }

                    // CREATE / REFRESH mapContent
                    var layerData = layerObject.srcdata;

                    if (layerData) {

                        var layerSource = map.getSource(layername),
                            mapLayer = map.getLayer(layername);

                        // 1.A. (Re)Set datasources
                        if (!layerSource) {

                            map.addSource(layername, {
                                "type": "geojson",
                                "data": layerData
                            });

                            layerSource = map.getSource(layername);

                            // console.log("SRC", layername, layerData, layerSource);
                        } else {
                            // 1.B  CHECK 
                            if (true) {
                                layerSource.setData(layerData);
                            }
                        }

                        // 1.B Check type-FIT of layerName ??? 

                        // 1.C. (Re)Create layers 
                        if (!mapLayer) {
                            // console.log("layerTemplates for " + layername, layerTemplates, layerSource);
                    
                            layerTemplates.forEach(function(l) {
                                if (!map.getLayer(l.id)) {
                                    map.addLayer(l);
                                }
                            });

                            mapLayer = map.getLayer(layername);
                            // 
                            map.on("mousemove", hiliter);

                            map.on("click", selector);

                        }

                        // Check in ??? 
                        if (mapLayer) {
                            var features = map.querySourceFeatures(layername, {
                                sourceLayer: 'original',
                                filter: null
                            });

                            if (features.length) {
                                console.log("Loaded "+features.length + " features of layer [" + layername+ "]"); // , features, layerSource);
                            }    
                        }
                    }

                    // GET all source-features of layer 
                    var contentfeatures = getFeatures(layerData, layername);

                    if (contentfeatures.length) {
                        // console.log("contentfeatures of " + layername, contentfeatures);
                        mapfeatures[layername] = contentfeatures;
                    }

                }.bind(this));

                // console.log("mapContentPrepare: new mapfeatures", mapfeatures);
                this.mapfeatures = mapfeatures;
            },

        });
    </script>
</dom-module>