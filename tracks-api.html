<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="tracks-behavior.html">

<!--
`tracks-api`
create track-objects from alternative sources  
display as decorated route (fi with commented endpoints)

@demo demo/routingtracks.html 
-->
<dom-module id="tracks-api">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        Polymer({
            is: 'tracks-api',

            properties: {
                // disable events originating 
                // from multipurpose content-browser
                disable : {
                    type: Boolean
                },    
                /**
                 * Container with metadata of primary dataset 
                 */
                metadata: {
                    type: Object,
                    value: {},
                    notify: true
                },

                datasetlabel: "Static TrackLogs",

                /**
                 * Container for animation-data
                 */
                contentbox: {
                    type: Object,
                    notify: true
                },

                /**
                 * Container for raw track
                 */
                rawcontent: {
                    type: Object,
                },
                /**
                 * Container for available mapdata
                 */
                mapcontent: {
                    type: Object,
                },


                // 
                trackselected: {
                    type: Object,
                    // observer: 'trackActivate',
                    notify: true
                },
                // 
                trackdata: {
                    type: Array
                },

                trackpntindex: {
                    type: Number,
                    observer: 'trackPointRefresh',
                    notify: true
                },

                dragcoords: {
                    type: Array,
                    observer: 'dragPointRefresh',
                },

                mapevents: {
                    type: Object,
                    notify: true
                },

                maptoast: {
                    type: String,
                    notify: true
                },

            },

            behaviors: [
                Mbb.TracksBehavior,
                Mbb.MapBehavior
            ],

            observers: [
                'transfer(rawcontent.*)', // , metadata)'
                'onMapdataLoad(mapcontent.*)',
                'trackActivate(trackselected.id)' //,
            ],

            ready: function() {
                this.setTrackEvents(); // initialize map-events
            }, 

            // 
            transfer: function(rawcontent) { // , metadata) {
                if (this.disable) return;   

                rawcontent = rawcontent.value; 
                if (!rawcontent || !Object.keys(rawcontent).length) return; 
                // console.log("SETUP contentbox from raw tracks.", rawcontent); 

                this.set("metadata.datasetlabel",  this.datasetlabel);
                this.contentbox = rawcontent;
            },

            // Setup events related to UserInteractions with track-lines
            setTrackEvents: function(){
                var mapevents = {};
                var elemscope = this;

                // Get content of tilefeature selected	
                function srcFeatureContent(tileFeature, layerid, eventscope) {
                    var tilecontent = eventscope.tileFeatureContent(tileFeature, layerid, "src"),
                        selectid = tilecontent.id.replace(/-/g,'_'),
                        allcontent = elemscope.contentbox[layerid].srcdata.features,
                        srccontent; 
                    // console.log("map-selected content", selectid, tilecontent, allcontent);
                    allcontent.some(function(f){
                        // console.log(f.properties.id==selectid); 
                        if (f.properties.id == selectid) {
                            srccontent = {
                                layer: layerid,
                                id : selectid,
                                feature : f
                            }    
                            return false;
                        }
                    });
                    return srccontent;
                }


                // Generic HILITE-function based on "id-Filter"	
                mapevents["hilite"] = function featureHilite(e, layerid, scope) {
                    // console.log("featureHilite in ", layerid, e.point); 
                    if (!map.getLayer(layerid)) return;
                    if (!map.getLayer(layerid + "-hover")) return;

                    var hilayerid, hifilter;

                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [layerid]
                    });

                    // CHANGE cursor temporarily
                    map.getCanvas().style.cursor = (features.length) ? 'pointer' : ''; // crosshair';

                    if (features.length) {  // Apply HILITE-FILTER  

                        var fkeys = scope.guessFeatureKeys(features[0]); 

                        if (!fkeys) {

                            console.log("HILITING in " + layerid + ":", features[0]);
                        
                        } else {    // Filtering the HOVER-Layer
                            
                            hifilter = ["==", fkeys[0], fkeys[1]] ; // trackInfo[keyname]];
                            // console.log("hi " + layerid + ":", trackInfo.length+" km");

                            hilayerid = layerid + "-hover";
                        
                            map.setFilter(hilayerid, hifilter);
                        }

                    } else {                // remove HILITE decoration
                        map.setFilter(layerid + "-hover", ["==", "name", ""]);
                    }
                };

                // Feature-Select 
                //   supplies info-object of selected feature 
                mapevents["select"] =  function featureSelect(e, layerid, eventscope) {
                    // console.log("featureSelect in ", layerid, e.point); 

                    if (!map.getLayer(layerid)) return;
                    // if (!map.getLayer(layerid + "-select")) return;

                    // A. Trigger
                    //  - Zoom to trackLine-BBOX  
                    //  - SYNC of map-selection with item-selection in content-browser    

                    // A.1 Get  
                    var features = map.queryRenderedFeatures(e.point, {
                        layers: [layerid]
                    }); // console.log("featureSelect. tiles", features); 
                    if (!features || !features.length) return;  

                    var trackselected = srcFeatureContent(features[0], layerid, eventscope); 
                    if (!trackselected) return;  // console.log("srcContent:", srcContent);
                    
                    if (elemscope.trackselected.id != trackselected.id) {  
                        elemscope.trackselected = trackselected; // features[0];
                    }
                
                    // B. Select/Identify nearest point on trackLine 

                    var snapSet = elemscope.trackPointSnap(e.lngLat, trackselected); //  , elemscope);

                    // OPTION: refresh dragpntInfo in mapPopup at correct location
                    if (snapSet.index) { console.log("Selected TrackPoint at Index=" + snapSet.index, snapSet);

                        elemscope.trackpntindex = snapSet.index;
                        
                        var trackInfo =  elemscope.trackInfoCollect(snapSet); // snapped.properties);
                        if (trackInfo.toast) elemscope.maptoast = trackInfo.toast; 
                        // eventscope.popupOnMap(trackInfo);
                    } 

                };
               
               //     
                mapevents["mousemove"] =  function mouseMove(e) {
                    var layerid = 'dragpnt-glow';
                    var features = map.queryRenderedFeatures(e.point, { layers: [layerid] });
                    // Change point and cursor style as a UI indicator
                    // and set a flag to enable other mouse events.
                    if (features.length) {
                        map.setPaintProperty(layerid, 'circle-color', '#ff0000'); // '#3bb2d0');
                        canvas.style.cursor = 'move';
                        isCursorOverPoint = true;
                        map.dragPan.disable();
                        
                    } else {
                        map.setPaintProperty(layerid, 'circle-color', '#3887be');
                        canvas.style.cursor = '';
                        isCursorOverPoint = false;
                        map.dragPan.enable();
                    }
                }

                this.mapevents = mapevents; 
            },

            // (Basic) MAP-Action(s) to run after a trackContent is selected
            // further actions may run in separate elements
            trackActivate: function(fid) { // console.log("ACTIVATE track, ID=", fid);
                if (!fid || this.disable) return; 

                f = this.trackselected;                      
                if (!f.layer) return;   // console.log("ACTIVATE track", f); 

                var selectObj, layerid, feature = f;

                if (typeof f.layer == "string") {
                    layerid = f.layer;
                } else {
                    layerid = f.layer.id; 
                }

                if (f.feature) feature = f.feature; // console.log("") ; 

                this.trackdata = {
                    "coords": feature.geometry.coordinates,
                    "elevs": feature.properties.coordElevs, 
                    "times": feature.properties.coordTimes
                };     

                if (map) { 
                    
                    if (feature.properties.coordTimes)  { // console.log("TRACK DECORATE ", feature);
                        selectObj = this.trackDecorate(layerid, [feature]); 
                    }    

                } else {   console.log("TRACK VIEW", feature); // in non-map-mode

                    selectObj = this.setFeatureBounds([feature]);
                }     
                // console.log("processedTrack", selectObj); 
            },    

            // Special "permanent" HILITE of selected tracks
            // by HILITE-TRACE + "commented" end-nodes  
            //   - zooms to the feature
            //   - show start/stop based on "id-Filter"	
            trackDecorate: function(layerid, tiledata) {
                // by now for 1 feature only
                // var map = this.map; 
                var scope = this;

                // MB-Function for trackContent: 

                // 1. Create trackEndMarkers-layer
                function showTrackNodes(layerid, trackInfo) {
                    // layer of nodes symbols with text in HALO
                    var hilayerid = layerid + "-nodes",
                        hilayer = map.getLayer(hilayerid);

                    if (!hilayer) return; 
                    // console.log("NODES of "+ layerid, hilayer, trackInfo);                 

                    var fromicon = "monument",
                        toicon = "harbor";

                    var fromnode = trackInfo.fromnode.slice(0,2),
                        tonode   = trackInfo.tonode.slice(0,2),
                        fromtime = trackInfo.von,
                        totime = trackInfo.bis,
                        nodedata = { // for nodes-source = 2 points
                            "type": "FeatureCollection",
                            "features": [{
                                "type": "Feature",
                                "geometry": {
                                    "type": "Point",
                                    "coordinates": fromnode
                                },
                                "properties": {
                                    "title": fromtime,
                                    "icon": fromicon
                                }
                            }, {
                                "type": "Feature",
                                "geometry": {
                                    "type": "Point",
                                    "coordinates": tonode
                                },
                                "properties": {
                                    "title": totime,
                                    "icon": toicon
                                }
                            }]
                        } ;

                    // map.addSource(layerid, node);    
                    var src = map.getSource(hilayerid); 
                    if (src)  {
                        // console.log("set nodes-data into ", hilayerid, nodedata, src); 
                        src.setData(nodedata);                     
                    }    
                } 

                // 2. HILITE the TRACE of the track (Filtering-Layer)
                function showTrackLine(layerid, trackInfo) {
                    // 
                    var hilayerid = layerid + "-trace", // ?
                        hilayer = map.getLayer(hilayerid);  
                    if (!hilayer) return ;

                    var keyname = trackInfo.keyname,
                        hifilter = ["==", keyname, trackInfo[keyname]];

                    console.log("TRACE-filter of " + hilayerid, hifilter, hilayer); 

                    map.setFilter(hilayerid, hifilter);
                } 

                if (!tiledata) return;  // console.log("tiledata", tiledata); 

                this.debounce("decorate", function() {

                    if (Array.isArray(tiledata)) { // List of map-features
                        tiledata = this.tileFeatureContent(tiledata[0], layerid, "tile"); // map-behavior   
                    }
                    
                    var trackInfo =  this.trackInfoCollect(tiledata);

                    if (!trackInfo) return;  
                    
                    // console.log("TRACK DECORATE of", trackInfo)

                    // APPLY start- and stop-nodes of track
                    showTrackNodes(layerid, trackInfo); 

                    // APPLY trace-overlay (gestrichelt) on track
                    showTrackLine(layerid, trackInfo); 

                    // Single PanZoom-Event with MoveEnd-Action 
                    map.once('moveend', function() { 
                        this.popupOnMap(trackInfo, {center: true});
                    }.bind(this));
                
                    // Start PanZoom to "complete trackDecoration" 
                    if (trackInfo.bbox && trackInfo.bbox.bounds) {
                        map.fitBounds(trackInfo.bbox.bounds, {
                            padding: 40
                        });
                    } 
                    return trackInfo; 
                }, 200);    	
            },

            // Get app-specific Info about the "complete json-feature", 
            // the selected json-tile belongs to

            trackInfoCollect: function(trackident ) {
                var scope = this, 
                    trackInfo={}, trackLine, selectPnt, dragpnt, trackTimes, tpTime, trackZ, tpZ;    
                // console.log("trackInfoCollect", trackident); 

                // A. APP-SPECIFIC: derive line-specific props
                if (trackident.snap) {
                    // 
                    selectPnt = trackident.query; // features[1];
                    dragpnt = trackident.snap; // features[2];
                    trackLine = trackident.track; // features[0];

                    trackInfo = trackLine.properties;
                
                } else if (trackident.srcfeature) {

                    trackInfo = trackident; 
                    trackInfo.coords = trackident.srcfeature.geometry.coordinates; // **!!!** 
                    trackInfo.fromnode = trackident.coords[0];
                    trackInfo.tonode = trackident.coords[trackident.coords.length - 1];
                    trackInfo.bbox = this.setFeatureBounds([trackident.srcfeature]);
                    trackInfo.length = this.deltaL(trackident.srcfeature);
                }

                trackInfo.html = "Track LOG <hr>" + trackInfo.time;
                trackInfo.toast = "";

                // B. SPECIFIC: derive tracklog-specific time-parameters 
                if (trackInfo.coordTimes) { 
                    trackTimes = trackInfo.coordTimes;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                    if (typeof trackTimes == "string") {
                        trackTimes = JSON.parse(trackTimes);
                        trackInfo.coordTimes = trackTimes;
                    }
                    // console.log(trackInfo, trackTimes);
                    
                    var n = trackTimes.length, // equal to number of coords
                        tvon = scope.trackTime(trackTimes[0]);
                        tbis = scope.trackTime(trackTimes[n - 1])
                        von = scope.utcTime(tvon, "h"),
                        bis = scope.utcTime(tbis, "h"),
                        dt = bis - von;
                    // console.log(trackTimes[0],trackTimes[n-1], tvon, tbis, von, bis, dt);

                    trackInfo.duration = scope.deltaT(dt);
                    trackInfo.count = n;
                    trackInfo.von = scope.logTime(von, "h", "t");
                    trackInfo.bis = scope.logTime(bis, "h", "t");

                    // E. SPECIFIC: compile some parameters as HTML 
                    var vonbis = " [ " + trackInfo.von +" to " + trackInfo.bis + "] ";
                    trackInfo.html  += "<br>Duration: " 
                                    + trackInfo.duration
                                    + "<br>" + vonbis; 
                    // trackInfo.toast += vonbis;
                }
                
                if (dragpnt) { 
                    var tpinfo = dragpnt.properties,
                        coords = dragpnt.geometry.coordinates;
                    trackInfo.html += "<hr>TP-Index: "+ tpinfo.index; 
                    
                    trackInfo.lnglat = new mapboxgl.LngLat(coords[0],coords[1]);

                    if (trackTimes) {
                        tpTime = scope.trackTime(trackTimes[tpinfo.index]);
                        tpTime = scope.utcTime(tpTime, "h");
                        tpTime = scope.logTime(tpTime, "h", "t");
                        tpTime = tpTime + " [UTC]" ;
                    
                        trackInfo.html  += "<br>Time: " + tpTime; 
                        trackInfo.toast += tpTime ; // + trackInfo.toast;
                    }    

                    if (trackInfo.coordElevs) {
                        trackZ = trackInfo.coordElevs;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                        if (typeof trackZ == "string") {
                            trackZ = JSON.parse(trackZ);
                        }
                        trackZ = trackZ[tpinfo.index] + " m";
                        trackInfo.html += "<br>Elev : " + trackZ + " m NN"; 
                        trackInfo.toast += "  :  z = "+ trackZ ; 
                    }    
                    // console.log("TP:", dragpnt, trackLine); // , trackInfo);
                } else {
                    trackInfo.html += "<br>Length: " + trackInfo.length
                    trackInfo.html += "<br>TP's: " + trackInfo.count;
                } 

                return trackInfo;
            },


            // 
            trackPointRefresh: function(ix) { 
                if (ix) { console.log("RELOCATE DRAGPNT at track-index: " + ix);
                    this.dragPointLocate(ix, null, "elevs");  // console.log("Refreshing trackPoint", ix);
                }
            },

            dragPointRefresh: function(coords) { console.log("RELOCATE DRAGPNT at coords", coords); 
                this.dragPointLocate(null, coords);  // console.log("Refreshing trackPoint", ix);
            },

            // 
            dragPointLocate: function(index, coords, title, selectsymbol) {
                // A meaningful TrackPoint-presentation built from 3 symbol(Layer)s 
                var scope = this; 

                //this.debounce("refreshTP", function() {
                    if (!selectsymbol) selectsymbol = "toilet-15"; // "airport-15";
                    if (!this.trackdata) return;

                    if (index != null) {
                        coords = this.trackdata["coords"][index].slice(0,2);  // console.log(coords[0],typeof coords[0]);
                        if (title) title = this.trackdata[title][index]; 
                        if (!title) title = index;
                    } 
                    if (!coords) return; 
                    if (!title) title = "drag"; 

                    // Create a GeoJSON point to serve as a starting point
                    var geojsonpnt = {
                        "type": "FeatureCollection",
                        "features": [{
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": coords
                            },
                            "properties": {
                                "title" : title
                            }
                        }]
                    };

                    if (map.getSource("dragpnt")) { 
                        // console.log("REFRESH-TP: " + index, geojsonpnt, map.getSource("dragpnt")); // return;  
                        map.getSource("dragpnt").setData(geojsonpnt);

                    } else {  // ONCE at FIRST app-session-call only 

                        map.addSource('dragpnt', { 
                            type: 'geojson', 
                            data: geojsonpnt 
                        }); 

                        var dragpntLayers =  [
                            {
                                "id": "dragpnt-glow-strong",
                                "type": "circle",
                                "source": "dragpnt",
                                "paint": {
                                    "circle-radius": 18,
                                    "circle-color": "#ff0",
                                    "circle-opacity": 0.6
                                }
                            }, 
                            
                            {
                                "id": "dragpnt-glow",
                                "type": "circle",
                                "source": "dragpnt",
                                "paint": {
                                    "circle-radius": 40,
                                    "circle-color": "#ff0",
                                    "circle-opacity": 0.2
                                }
                            }, 
                        	{
                                "id": "dragpnt-select",
                                "type": "symbol",
                                "source": "dragpnt",
                                "layout": {
                                    "icon-image": selectsymbol,
                                    "icon-rotate": 0,
                                    "text-field": "{title}",
                                    "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                                    "text-size": 12,
                                    "text-offset": [0, 0.6],
                                    "text-anchor": "top"
                                }
                            }
                        ];

                        // Change point and cursor style as a UI indicator
                        // and set a flag to enable other mouse events.
                        function mouseMove(e) {
                            var circleid = 'dragpnt-glow',
                                iconid = 'dragpnt-select';
                            var features = map.queryRenderedFeatures(e.point, { layers: [circleid] });
                            
                            // Change point and cursor style as a UI indicator
                            // and set a flag to enable other mouse events.
                            if (features.length) {
                                map.setPaintProperty(circleid, 'circle-color', '#f00'); // '#3bb2d0');
                                map.setLayoutProperty(iconid, 'icon-image', 'rocket-15'); // '#3bb2d0');

                                this.isCursorOverPoint = true;
                                map.dragPan.disable();
                                
                            } else {
                                map.setPaintProperty(circleid, 'circle-color', '#ff0');
                                map.setLayoutProperty(iconid, 'icon-image', 'toilet-15'); // '#3bb2d0');

                                this.isCursorOverPoint = false;
                                map.dragPan.enable();
                            }
                        }

                        function mouseDown() {
                            if (!this.isCursorOverPoint) return;

                            this.isDragging = true; // console.log("start dragging");
                            // Set a cursor indicator
                            // canvas.style.cursor = 'grab';
                            // Mouse events
                            map.on('mousemove', onDragMove);
                            map.once('mouseup', onDragUp);
                        }

                        function onDragMove(e) {
                            if (!this.isDragging) return;

                            var lngLat = e.lngLat,
                                coords = [lngLat.lng, lngLat.lat];  // console.log(coordsjson);     
                            // Set a UI indicator for dragging.
                            // canvas.style.cursor = 'grabbing';

                            if (scope.trackselected) { // Update the "nearest" point on active track 
                                
                                var snapSet = scope.trackPointSnap(lngLat); // , scope.trackselected);
                                if (snapSet.index != null) {
                                    
                                    // A. SYNC location and all related elements
                                    // scope.trackpntindex = snapSet.index;

                                    // B. refresh dragPnt only 
                                    scope.dragPointLocate(snapSet.index, null, "elevs");
                                }
                            } else {
                                scope.dragcoords = coords;
                            }
                        }
                        // actions when mouse over point 
                        function onDragUp(e) {
                            if (!this.isDragging) return;

                            this.isDragging = false;

                            var lngLat = e.lngLat;
                            var maptoast = 'DRAGSTOP'; 

                            if (1) {
                                var snapSet = scope.trackPointSnap(lngLat),
                                    snapPnt = snapSet['snap'],
                                    trackLine = snapSet['track'],
                                    index = snapPnt.properties.index;
                                    console.log("onDragUp: snapSet at "+index, snapSet); 

                                // 1. TRIGGER track-SYNC
                                scope.trackpntindex = index;

                                // 2. 
                                var t = trackLine.properties["coordTimes"][index],
                                    s = scope.toFixed(snapPnt.properties.location, 2)+" km";
                                maptoast += ' after s= ' + s + ', at t= ' + t;

                            } else {
                                maptaoast = "Free " + maptoast ; // 
                            }

                            scope.maptoast = maptoast;

                            // Unbind mouse events
                            map.off('mousemove', onDragMove);
                        }

                        dragpntLayers.forEach(function(layer){
                            map.addLayer(layer);
                        }); //  console.log("dragpntLayers ADDED");


                        map.on('mousemove', mouseMove);
                        // Set `true` to dispatch the event before other functions call it. This
                        // is necessary for disabling the default map dragging behaviour.
                        map.on('mousedown', mouseDown, true);
                        
                    }

                // }, 100);      
            },

            // 
            trackPointSnap : function(queryPnt, track) { // , elemscope) {
                if (!track) track = this.trackselected; 

                var trackLine = track.feature; 

                queryPnt = { 
                    "type": "Feature",
                    "properties": {},
                    "geometry": {
                        "type": "Point",
                        "coordinates": [queryPnt.lng, queryPnt.lat]
                    }
                };  

                // B.2 Find/Eval nearest trackpoint
                var snapPnt = turf.pointOnLine(trackLine, queryPnt, 'kilometers');
                if (!snapPnt) return {}; 

                return {
                    "index" : snapPnt.properties.index,
                    "track": trackLine, 
                    "query": queryPnt, 
                    "snap": snapPnt
                };
            }

        });

    </script>
</dom-module>       