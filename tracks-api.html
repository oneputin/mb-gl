<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="tracks-behavior.html">

<!--
`tracks-api`
create track-objects from alternative sources  
display as decorated route (fi with commented endpoints)

@demo demo/routingtracks.html 
-->
<dom-module id="tracks-api">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        Polymer({
            is: 'tracks-api',

            properties: {
                // disable events originating 
                // from multipurpose content-browser
                disable : {
                    type: Boolean
                },    
                /**
                 * Container with metadata of primary dataset 
                 */
                metadata: {
                    type: Object,
                    value: {},
                    notify: true
                },

                datasetlabel: "Static TrackLogs",

                /**
                 * Container for animation-data
                 */
                contentcase: {
                    type: Object,
                    notify: true
                },

                /**
                 * Container for raw track
                 */
                rawcontent: {
                    type: Object,
                },
                /**
                 * Container for mapdata of track (rawcontent)
                 */
                mapcontent: {
                    type: Object,
                },

                // 
                tracksall: {
                    type: Object
                },

                // 
                trackitem: {
                    type: Object,
                    notify: true
                },
                // 
                tracklog: {
                    type: Object,
                    notify: true
                },

                trackevents: {
                    type: Object,
                    notify: true
                },

                popupflag : {
                    type: Boolean,
                    value: false
                },

                maptoast: {
                    type: String,
                    notify: true
                },

            },

            behaviors: [
                Mbb.TracksBehavior,
                Mbb.MapBehavior
            ],

            observers: [
                'transfer(rawcontent.*, disable)', // , metadata)'
                'trackActivate(trackitem.id, popupflag)' //,
                // 'trackLogActivate(tracklog.lnglat)'
                // 'onMapdataLoad(mapcontent.*)',
            ],

            ready: function() {
                this.setTrackEvents(); // initialize map-events
            }, 

            // 
            transfer: function(rawcontent, disabled) { // , metadata) {
                
                this.debounce("transfer", function(){
                    // console.log("TRANSFER TRACK into contentcase", disabled, rawcontent);
                    if (disabled) return;   

                    rawcontent = rawcontent.value; 
                    if (!rawcontent || !Object.keys(rawcontent).length) return; 
                    // console.log("SETUP contentcase from raw tracks.", rawcontent); 

                    this.set("metadata.datasetlabel",  this.datasetlabel);
                    this.contentcase = rawcontent;

                }, 200);
            },

            // Setup events related to UserInteractions with track-lines
            setTrackEvents: function(){
                var trackevents = {};
                var scope = this;
                var tapPrecision = 5; // half-width(px) of event-querybox 

                // Generic HILITE-function based on "id-Filter"	
                // 
                trackevents["hilite"] = function featureHilite(e, layerid, scope) {
                    // console.log("featureHilite in ", layerid, e.point); 
                    if (!map.getLayer(layerid)) return;
                    if (!map.getLayer(layerid + "-hover")) return;
                    var hilayerid, hifilter;
                    var delta = tapPrecision;

                    //var selgeo = e.point;
                    var selgeo = [[e.point.x - delta, e.point.y - delta], [e.point.x + delta, e.point.y + delta]];

                    var features = map.queryRenderedFeatures(selgeo, {
                        layers: [layerid]
                    });

                    // Toggle cursor (temporarily)
                    map.getCanvas().style.cursor = (features.length) ? 'pointer' : ''; // crosshair';

                    if (features.length) {  // Apply HILITE-FILTER  

                        var fkeys = scope.guessFeatureIdent(features[0]); 

                        if (!fkeys) {

                            console.log("Cannot HILITE in " + layerid + ":", features[0]);
                        
                        } else {    // Filtering the HOVER-Layer
                            
                            hifilter = ["==", fkeys[0], fkeys[1]] ; // tracklog[keyname]];
                            // console.log("hi " + layerid + ":", tracklog.length+" km");

                            hilayerid = layerid + "-hover";
                        
                            map.setFilter(hilayerid, hifilter);
                        }
                    } else {                // remove HILITE decoration
                        
                        map.setFilter(layerid + "-hover", ["==", "name", ""]);
                    }
                };

                // Feature-Select 
                //  - Zoom to trackLine-BBOX  
                //  - SYNC of map-selection with item-selection in content-browser    
                //  - supplies info-object of selected feature 
                trackevents["select"] =  function featureSelect(e, layerid, eventscope) {
                    if (!map.getLayer(layerid)) return; 
                    // e.originalEvent.stopPropagation();

                    // A. Get visible feature 
                    var selectGeometry = e.point;
                    if (tapPrecision) {
                        var delta = tapPrecision;
                        selectGeometry = [[e.point.x - delta, e.point.y - delta], [e.point.x + delta, e.point.y + delta]];                    
                    }
                    var features = map.queryRenderedFeatures(selectGeometry, {
                        layers: [layerid]
                    }); 
                    if (!features || !features.length) return;  
                    
                    var mbfeature = features[0];
                    var mapFeature = eventscope.mapFeatureGet(mbfeature); 
                    if (!mapFeature) return;   // console.log("SELECTED trackFeature:", trackitem);
                    
                    if (scope.trackitem.id != mapFeature.id) {  // activate ANOTHER track
                        // B. Refresh TrackItem 
                        scope.trackitem = mapFeature; 
                        //*************
                        // C. Refresh LOG (of TrackItem)
                        scope.tracklog = scope.getTrackLog(mbfeature, layerid);
                        //************
                        // console.log("MAP-SELECTED trackFeature", scope.tracklog);
                    }  // console.log("e.lngLat", e.lngLat); 
                    // D. Refresh lnglat-property of TrackItem 
                    scope.set("tracklog.lnglat", e.lngLat);
                    //************************  
                };
               
                /*     
                trackevents["mousemove"] =  function mouseMove(e) {
                    var layerid = 'dragpnt-glow';
                    var features = map.queryRenderedFeatures(e.point, { layers: [layerid] });
                    // Change point and cursor style as a UI indicator
                    // and set a flag to enable other mouse events.
                    if (features.length) {
                        map.setPaintProperty(layerid, 'circle-color', '#ff0000'); // '#3bb2d0');
                        canvas.style.cursor = 'move';
                        isCursorOverPoint = true;
                        map.dragPan.disable();
                        
                    } else {
                        map.setPaintProperty(layerid, 'circle-color', '#3887be');
                        canvas.style.cursor = '';
                        isCursorOverPoint = false;
                        map.dragPan.enable();
                    }
                }*/
                this.trackevents = trackevents; 
            },

            // (Basic) MAP-Action(s) to run after a new track is selected
            //  further actions may run in separate elements
            trackActivate: function(fid, popupflag) { 
                if (!fid || this.disable) return; 

                // Activate SINGLE track(-object)
                this.debounce("activate", function() {

                    // A. Operations on ALL features (tracks)
                    if (fid == "all") {

                        // A. DeActivate activeTrack-Styling (if there was any )
                        this.trackDecorate();

                        // B. Optional:  ZoomTo All
                        if (this.zoomall) {
                            var msg = "Zoomed to ALL tracks!";  // console.log("DEBUG", msg, tracksall); 
                            this.maptoast = msg;
                            
                            var ff = [];
                            this.tracksall.forEach(function(item){
                                ff.push(item.feature)
                            });
                            this.setFeatureBounds(ff, 10);
                        }
                        return;
                    } 

                    // B. Activate trackObject in "the suitable context"" (fi. as map-element) 
                    if (map) { 

                        var trackitem = this.trackitem,  
                            tracklog = this.tracklog;

                        if (!tracklog || (trackitem.id != tracklog.id)) {

                            tracklog = this.getTrackLog(trackitem);                          
                            this.tracklog = tracklog;
                            // console.log("ACTIVATED track. ID="+fid, trackitem, tracklog); // , tracksall);
                        }

                        // C.1 Optional: Assign a "Single popup"-Action 
                        //     bound to the MoveEnd-Event following a "panZoom"
                        if (popupflag && tracklog.html) {
                            map.once('moveend', function(e) { 
                                // console.log("track ACTIVATED&ZOOMED at ", e, tracklog); 
                                this.popupOnMap(tracklog.html, {center: true});
                            }.bind(this));
                        }
                    
                        // C.2 Start PanZoom to activated track ( + 40 px padding)
                        if (tracklog.bbox && tracklog.bbox.bounds) {
                            map.fitBounds(tracklog.bbox.bounds, {
                                padding: 40
                            });
                        } 

                        this.trackDecorate(tracklog); // , [feature]); 

                    } else {   console.log("TRACK activated", f); // in non-map-mode

                        this.setFeatureBounds([f]);
                    } 

                }, 300);   

            },    

            // Optional: 
            trackLogActivate: function(lnglat){
                if (this.tracklog && lnglat) {  // console.log("trackLogActivate", lnglat, this.tracklog); 
                    // this.trackActivate(this.tracklog.id);
                } 
            },

            // Compile a bunch of data 
            //  - based on gpx-track data  and 
            //  - useful for use in a mapclient
            getTrackLog : function(trackitem) {   console.log("get TrackLog of trackitem:", trackitem); 

                // A. Compile basic Data of selected track-vector
                var trackLog = this.mapFeatureGetlog(trackitem); // generic mb-behavior                       
                
                // B. Append app-specific details
                trackLog = this.trackLogAddDetails(trackLog);

                return trackLog; 
            },

            // Special "permanent" HILITE of selected track(s)
            // by HILITE-TRACE + "commented" end-nodes  
            //   - zooms to the feature
            //   - show start/stop based on "id-Filter"	
            trackDecorate: function(tracklog, decoratemode, layerid) {
                // by now for "1-feature-selection" only
                if (!decoratemode) decoratemode = "drag";
                if (!layerid) {
                    var ccase = this.contentcase,
                        ckeys = Object.keys(ccase);
                    if (ckeys.length) layerid = ccase[ckeys[0]].layer.id;
                    else layerid = "tracks"; 
                    // console.log("trackDecorate, layerid=", layerid);
                }

                var hiliteid = layerid + '-select',
                    tracklayer = map.getLayer(layerid),
                    hilitelayer = map.getLayer(hiliteid); 

                // A: RESET
                if (!tracklog) {  console.log("remove track-decoration on layer", tracklayer);
                    if (tracklayer)  map.setLayoutProperty(layerid, 'visibility', 'visible');
                    showTrackNodes(null, layerid);
                    showTrackLine(null, layerid);
                    return;
                }  

                // Set the filter to populate features into the layer.
                
                if (tracklayer && hilitelayer) {
                    // console.log("decoratelayers for",tracklog ,layerid, hilitelayer, tracklayer);
                    // A. UNIQUE filter-value
                    map.setFilter(hiliteid, ['in', 'id', tracklog.id]);
                    
                    // B. MULTIPLE filter-values
                    /* filtered = []; // [id1,id2,id3] 
                    map.setFilter('tracks-highlighted', ['in', 'id'].concat(filtered.map(function(feature) {
                        return feature.properties.id;
                    })));*/

                    // Optional: Additional map-elements related to  selected track
                    // ALTERNATIV : "DragPoint at Start" or "Track-Endpoints"

                    // C: 
                    map.setLayoutProperty(layerid, 'visibility', 'none');
                    console.log("decorate track based on:", tracklog, tracklayer); 
                }

                // Trigger DRAGPNT-presentation at Track-START 
                // INDIRECTLY  through  tracklog.lnglat  
                if (decoratemode == "drag") { 
                    var p1 = tracklog.coords[0],
                        c1 = {"lng":p1[0],"lat":p1[1]};  //  console.log("START track at ", p1, c1);  
                
                    this.set("tracklog.lnglat", c1); 
                    return; 
                } 

                // 1. Create/Refresh the layer of track's endMarkers
                function showTrackNodes(tracklog, layerid) {
                    // layer of nodes symbols with text in HALO
                    var hilayerid = layerid + "-nodes",
                        hilayer = map.getLayer(hilayerid),
                        src = map.getSource(hilayerid); // console.log("showTrackNodes:", hilayerid, hilayer, src); 
                    if (!hilayer) return;  

                    if (src && !tracklog) { // clear nodeLayer
                        src.setData({
                            "type": "FeatureCollection",
                            "features" : []
                        });
                        return;
                    }  

                    // console.log("Show NODES of "+ layerid, hilayer, tracklog);                 
                    var fromIcon = "monument",
                        toIcon   = "harbor";

                    var fromNode = tracklog.fromnode.slice(0,2),
                        toNode   = tracklog.tonode.slice(0,2);

                    var fromTitle = tracklog.von ? tracklog.von : "", 
                        toTitle   = tracklog.bis ? tracklog.bis : "";

                    var nodes_json = { // for nodes-source = 2 points
                        "type": "FeatureCollection",
                        "features": [{
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": fromNode
                            },
                            "properties": {
                                "title": fromTitle,
                                "icon": fromIcon
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": toNode
                            },
                            "properties": {
                                "title": toTitle,
                                "icon": toIcon
                            }
                        }]
                    } ;

                    if (!src) map.addSource(hilayerid, nodes_json);    
                    else      src.setData(nodes_json);                     
                } 

                // 2. HILITE the optional "TRACE"-layer of the track (Filtering-Layer)
                function showTrackLine(tracklog, layerid) {
                    var hilayerid = layerid + "-trace", // ?
                        hilayer = map.getLayer(hilayerid);  

                    if (!hilayer) return ;
                    if (!tracklog) { // remove filter
                        map.setFilter(hilayerid, ""); // hifilter);
                        return; 
                    }

                    //
                    var keyname = tracklog.keyname,
                        hifilter = ["==", keyname, tracklog[keyname]];
                    console.log("Set TRACE-filter of: " + hilayerid, hifilter, hilayer); 

                    map.setFilter(hilayerid, hifilter);
                } 

                // APPLY start- and stop-nodes of track
                showTrackNodes(tracklog, layerid); 

                // Option: APPLY trace-overlay (gestrichelt) on track
                showTrackLine(tracklog, layerid); 
                    // 

            }

        });

    </script>
</dom-module>       