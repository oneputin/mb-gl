<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="mb-map-behavior.html">
<link rel="import" href="tracks-behavior.html">

<!--
`tracks-api`
create track-objects from alternative sources  
display as decorated route (fi with commented endpoints)

@demo demo/routingtracks.html 
-->
<dom-module id="tracks-api">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        Polymer({
            is: 'tracks-api',

            properties: {
                // disable events originating 
                // from multipurpose content-browser
                disable : {
                    type: Boolean
                },    
                /**
                 * Container with metadata of primary dataset 
                 */
                metadata: {
                    type: Object,
                    value: {},
                    notify: true
                },

                datasetlabel: "Static TrackLogs",

                /**
                 * Container for animation-data
                 */
                contentbox: {
                    type: Object,
                    notify: true
                },

                /**
                 * Container for raw track
                 */
                rawcontent: {
                    type: Object,
                },
                /**
                 * Container for mapdata of track (rawcontent)
                 */
                mapcontent: {
                    type: Object,
                },

                // 
                tracksall: {
                    type: Object
                },

                // 
                trackselected: {
                    type: Object,
                    notify: true
                },

                mapevents: {
                    type: Object,
                    notify: true
                },

                maptoast: {
                    type: String,
                    notify: true
                },

            },

            behaviors: [
                Mbb.TracksBehavior,
                Mbb.MapBehavior
            ],

            observers: [
                'transfer(rawcontent.*, disable)', // , metadata)'
                // 'onMapdataLoad(mapcontent.*)',
                'trackActivate(trackselected.id, tracksall)' //,
            ],

            ready: function() {
                this.setTrackEvents(); // initialize map-events
            }, 

            // 
            transfer: function(rawcontent, disabled) { // , metadata) {
                
                this.debounce("transfer", function(){
                    // console.log("TRANSFER TRACK into contentBox", disabled, rawcontent);
                    if (disabled) return;   

                    rawcontent = rawcontent.value; 
                    if (!rawcontent || !Object.keys(rawcontent).length) return; 
                    // console.log("SETUP contentbox from raw tracks.", rawcontent); 

                    this.set("metadata.datasetlabel",  this.datasetlabel);
                    this.contentbox = rawcontent;

                }, 200);
            },

            // Setup events related to UserInteractions with track-lines
            setTrackEvents: function(){
                var mapevents = {};
                var scope = this;
                var delta = 5; // half-width(px) of event-querybox 

                // Get content of tilefeature selected	
                function srcFeatureContent(tileFeature, layerid, eventscope) {
                    var tilecontent = eventscope.tileFeatureContent(tileFeature, layerid, "src"),
                        selectid = tilecontent.id.replace(/-/g,'_'),
                        allcontent = scope.contentbox[layerid].srcdata.features,
                        srccontent; 
                    
                    // console.log("map-selected content", selectid, tilecontent, allcontent);
                    allcontent.some(function(f){
                        // console.log(f.properties.id==selectid); 
                        if (f.properties.id == selectid) {
                            srccontent = {
                                layer: layerid,
                                id : selectid,
                                feature : f
                            }    
                            return false;
                        }
                    });
                    return srccontent;
                }

                // Generic HILITE-function based on "id-Filter"	
                // 
                mapevents["hilite"] = function featureHilite(e, layerid, scope) {
                    // console.log("featureHilite in ", layerid, e.point); 
                    if (!map.getLayer(layerid)) return;
                    if (!map.getLayer(layerid + "-hover")) return;
                    var hilayerid, hifilter;
                    var hidelta = 5;
                    //var selgeo = e.point;
                    var selgeo = [[e.point.x - hidelta, e.point.y - hidelta], [e.point.x + hidelta, e.point.y + hidelta]];

                    var features = map.queryRenderedFeatures(selgeo, {
                        layers: [layerid]
                    });

                    // Toggle cursor (temporarily)
                    map.getCanvas().style.cursor = (features.length) ? 'pointer' : ''; // crosshair';

                    if (features.length) {  // Apply HILITE-FILTER  

                        var fkeys = scope.guessFeatureKeys(features[0]); 

                        if (!fkeys) {

                            console.log("HILITING in " + layerid + ":", features[0]);
                        
                        } else {    // Filtering the HOVER-Layer
                            
                            hifilter = ["==", fkeys[0], fkeys[1]] ; // trackInfo[keyname]];
                            // console.log("hi " + layerid + ":", trackInfo.length+" km");

                            hilayerid = layerid + "-hover";
                        
                            map.setFilter(hilayerid, hifilter);
                        }
                    } else {                // remove HILITE decoration
                        
                        map.setFilter(layerid + "-hover", ["==", "name", ""]);
                    }
                };

                // Feature-Select 
                //  - Zoom to trackLine-BBOX  
                //  - SYNC of map-selection with item-selection in content-browser    
                //  - supplies info-object of selected feature 
                mapevents["select"] =  function featureSelect(e, layerid, eventscope) {
                    if (!map.getLayer(layerid)) return; // console.log("featureSelect in ", layerid, e.point); 

                    // A. Get visible feature 
                    //var selgeo = e.point;
                    var selgeo = [[e.point.x - delta, e.point.y - delta], [e.point.x + delta, e.point.y + delta]];
                    
                    var features = map.queryRenderedFeatures(selgeo, {
                        layers: [layerid]
                    }); 
                    if (!features || !features.length) return;  // console.log("featureSelect. tiles", features); 

                    // B. get SRC-feture 
                    var trackselected = srcFeatureContent(features[0], layerid, eventscope); 

                    if (!trackselected) return;  // console.log("srcContent:", srcContent);
                    
                    if (scope.trackselected.id != trackselected.id) {  

                        trackselected.lnglat = e.lngLat;    // where track was selected

                        scope.trackselected = trackselected; 
                    
                    } else {
                        // 
                        scope.set("trackselected.lnglat", e.lngLat);    // where track was selected
                    }

                };
               
                /*     
                mapevents["mousemove"] =  function mouseMove(e) {
                    var layerid = 'dragpnt-glow';
                    var features = map.queryRenderedFeatures(e.point, { layers: [layerid] });
                    // Change point and cursor style as a UI indicator
                    // and set a flag to enable other mouse events.
                    if (features.length) {
                        map.setPaintProperty(layerid, 'circle-color', '#ff0000'); // '#3bb2d0');
                        canvas.style.cursor = 'move';
                        isCursorOverPoint = true;
                        map.dragPan.disable();
                        
                    } else {
                        map.setPaintProperty(layerid, 'circle-color', '#3887be');
                        canvas.style.cursor = '';
                        isCursorOverPoint = false;
                        map.dragPan.enable();
                    }
                }*/

                this.mapevents = mapevents; 
            },

            // (Basic) MAP-Action(s) to run after a trackContent is selected
            // further actions may run in separate elements
            trackActivate: function(fid, tracksall) { // console.log("ACTIVATE track, ID=", fid, tracksall);
                if (!fid || this.disable) return; 

                // Operate on ALL features (tracks)
                if (fid == "all") {

                    var msg = "Zoom to ALL tracks";  // console.log("DEBUG", msg, tracksall); 
                    this.maptoast = msg;
                    
                    var ff = [];
                    tracksall.forEach(function(item){
                        ff.push(item.feature)
                    });
                    this.setFeatureBounds(ff, 10);
                    return;
                } 

                // Activate SINGLE track
                var f = this.trackselected;                      
                if (!f.layer) return;   

                var selectObj, layerid, feature;
                if (typeof f.layer == "string") {
                    layerid = f.layer;
                } else {
                    layerid = f.layer.id; 
                }

                if (f.feature) feature = f.feature; // console.log("ACTIVATE track", feature); 
                else feature = f;

                this.trackdata = {
                    "coords": feature.geometry.coordinates,
                    "elevs": feature.properties.coordElevs, 
                    "times": feature.properties.coordTimes
                };     

                if (map) { 
                    
                    if (feature.properties.coordTimes)  { // console.log("TRACK DECORATE ", feature);
                        selectObj = this.trackDecorate(layerid, [feature]); 
                    }    

                } else {   console.log("TRACK VIEW", feature); // in non-map-mode

                    selectObj = this.setFeatureBounds([feature]);
                }     
                // console.log("processedTrack", selectObj); 
            },    

            // Special "permanent" HILITE of selected tracks
            // by HILITE-TRACE + "commented" end-nodes  
            //   - zooms to the feature
            //   - show start/stop based on "id-Filter"	
            trackDecorate: function(layerid, tiledata) {
                // by now for 1 feature only
                // var map = this.map; 
                if (!tiledata) return;  // console.log("tiledata", tiledata); 
                var scope = this;

                // MB-Function for trackContent: 

                // 1. Create trackEndMarkers-layer
                function showTrackNodes(layerid, trackInfo) {
                    // layer of nodes symbols with text in HALO
                    var hilayerid = layerid + "-nodes",
                        hilayer = map.getLayer(hilayerid),
                        src = map.getSource(hilayerid); 
                    if (!hilayer) return;  
                    // console.log("Show NODES of "+ layerid, hilayer, trackInfo);                 

                    var fromicon = "monument",
                        toicon   = "harbor";

                    var fromnode = trackInfo.fromnode.slice(0,2),
                        tonode   = trackInfo.tonode.slice(0,2),
                        fromtime = trackInfo.von,
                        totime = trackInfo.bis;

                    var nodes_json = { // for nodes-source = 2 points
                        "type": "FeatureCollection",
                        "features": [{
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": fromnode
                            },
                            "properties": {
                                "title": fromtime,
                                "icon": fromicon
                            }
                        }, {
                            "type": "Feature",
                            "geometry": {
                                "type": "Point",
                                "coordinates": tonode
                            },
                            "properties": {
                                "title": totime,
                                "icon": toicon
                            }
                        }]
                    } ;

                    if (!src) map.addSource(hilayerid, nodes_json);    
                    else      src.setData(nodes_json);                     
                } 

                // 2. HILITE the "TRACE" of the track (Filtering-Layer)
                function showTrackLine(layerid, trackInfo) {
                    // 
                    var hilayerid = layerid + "-trace", // ?
                        hilayer = map.getLayer(hilayerid);  
                    if (!hilayer) return ;

                    var keyname = trackInfo.keyname,
                        hifilter = ["==", keyname, trackInfo[keyname]];

                    console.log("TRACE-filter of " + hilayerid, hifilter, hilayer); 

                    map.setFilter(hilayerid, hifilter);
                } 

                this.debounce("decorate", function() {

                    if (Array.isArray(tiledata)) { // List of map-features
                        tiledata = this.tileFeatureContent(tiledata[0], layerid, "tile"); // map-behavior   
                    }
                    
                    var trackInfo =  this.trackInfoCollect(tiledata);
                    if (!trackInfo) return;  
                    
                    // console.log("TRACK DECORATE of", trackInfo)

                    // APPLY start- and stop-nodes of track
                    showTrackNodes(layerid, trackInfo); 

                    // APPLY trace-overlay (gestrichelt) on track
                    showTrackLine(layerid, trackInfo); 

                    // Single PanZoom-Event with MoveEnd-Action 
                    map.once('moveend', function() { 
                        this.popupOnMap(trackInfo, {center: true});
                    }.bind(this));
                
                    // Start PanZoom to "complete trackDecoration" 
                    if (trackInfo.bbox && trackInfo.bbox.bounds) {
                        map.fitBounds(trackInfo.bbox.bounds, {
                            padding: 40
                        });
                    } 
                    return trackInfo; 
                }, 200);    	
            },

            // Get app-specific Info about the "complete json-feature", 
            // the selected json-tile belongs to
            trackInfoCollect: function(trackident ) {
                var scope = this, 
                    trackInfo={}, trackLine, selectPnt, dragpnt, trackTimes, tpTime, trackZ, tpZ;    
                // console.log("trackInfoCollect", trackident); 

                // A. APP-SPECIFIC: derive line-specific props
                if (trackident.snap) {
                    // 
                    selectPnt = trackident.query; // features[1];
                    dragpnt = trackident.snap; // features[2];
                    trackLine = trackident.track; // features[0];

                    trackInfo = trackLine.properties;
                
                } else if (trackident.srcfeature) {

                    trackInfo = trackident; 
                    trackInfo.coords = trackident.srcfeature.geometry.coordinates; // **!!!** 
                    trackInfo.fromnode = trackident.coords[0];
                    trackInfo.tonode = trackident.coords[trackident.coords.length - 1];
                    trackInfo.bbox = this.setFeatureBounds([trackident.srcfeature]);
                    trackInfo.length = this.deltaL(trackident.srcfeature);
                }

                trackInfo.html = "Track LOG <hr>" + trackInfo.time;
                trackInfo.toast = "";

                // B. SPECIFIC: derive tracklog-specific time-parameters 
                if (trackInfo.coordTimes) { 
                    trackTimes = trackInfo.coordTimes;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                   
                    if (typeof trackTimes == "string") {
                        trackTimes = JSON.parse(trackTimes);
                        trackInfo.coordTimes = trackTimes;
                    }   // console.log(trackInfo, trackTimes);
                    
                    var n = trackTimes.length, // equal to number of coords
                        tvon = scope.trackTime(trackTimes[0]);
                        tbis = scope.trackTime(trackTimes[n - 1])
                        von = scope.utcTime(tvon, "h"),
                        bis = scope.utcTime(tbis, "h"),
                        dt = bis - von;
                    // console.log(trackTimes[0],trackTimes[n-1], tvon, tbis, von, bis, dt);

                    trackInfo.duration = scope.deltaT(dt);
                    trackInfo.count = n;
                    trackInfo.von = scope.logTime(von, "h", "t");
                    trackInfo.bis = scope.logTime(bis, "h", "t");

                    // E. SPECIFIC: compile some parameters as HTML 
                    var vonbis = " [ " + trackInfo.von +" to " + trackInfo.bis + "] ";
                    trackInfo.html  += "<br>Duration: " 
                                    + trackInfo.duration
                                    + "<br>" + vonbis; 
                    // trackInfo.toast += vonbis;
                }
                
                if (dragpnt) { 
                    var tpinfo = dragpnt.properties,
                        coords = dragpnt.geometry.coordinates;
                    trackInfo.html += "<hr>TP-Index: "+ tpinfo.index; 
                    
                    trackInfo.lnglat = new mapboxgl.LngLat(coords[0],coords[1]);

                    if (trackTimes) {
                        tpTime = scope.trackTime(trackTimes[tpinfo.index]);
                        tpTime = scope.utcTime(tpTime, "h");
                        tpTime = scope.logTime(tpTime, "h", "t");
                        tpTime = tpTime + " [UTC]" ;
                    
                        trackInfo.html  += "<br>Time: " + tpTime; 
                        trackInfo.toast += tpTime ; // + trackInfo.toast;
                    }    

                    if (trackInfo.coordElevs) {
                        trackZ = trackInfo.coordElevs;  // console.log("trackTimes", typeof trackTimes, trackTimes);
                        if (typeof trackZ == "string") {
                            trackZ = JSON.parse(trackZ);
                        }
                        trackZ = trackZ[tpinfo.index] + " m";
                        trackInfo.html += "<br>Elev : " + trackZ + " m NN"; 
                        trackInfo.toast += "  :  z = "+ trackZ ; 
                    }    
                    // console.log("TP:", dragpnt, trackLine); // , trackInfo);
                } else {
                    trackInfo.html += "<br>Length: " + trackInfo.length
                    trackInfo.html += "<br>TP's: " + trackInfo.count;
                } 
                return trackInfo;
            }

        });

    </script>
</dom-module>       