<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">
<link rel="import" href="mb-api.html">
<link rel="import" href="mb-tools-behavior.html">
<!--<link rel="import" href="mb-behavior-info-vendee.html">-->

<!--
`mb-routes`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="mb-routes">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        Polymer({
            is: 'mb-routes',

            properties: {
                /**
                 * Mapbox-js map to place routing elements 
                 */
                map: {
                    type: Object
                },

                /**
                 * Container for animation-ctrls
                 * timescale, 
                 */
                timer: {
                    type: Object,
                    notify: true,
                },

                /**
                 * Data-Container for app-supplied mapContent 
                 */
                animationsources: {
                    type: Object,
                    notify: true
                },

                mapcontent: {
                    type: Object,
                    notify: true
                },

                /**
                 * Basic mapbox-Info-popup 
                 */
                popup: {
                    type: Object
                },

                /**
                 * Url to source of trackable routes/waypoints
                 */
                url: {
                    type: String
                },

                /**
                 * StatusFlag toggling TrackingMap--NorthMap 
                 */
                trackmapmode: {
                    type: Boolean,
                    value: false,
                    observer: 'mapOrientationChange',
                    notify: true
                },

                /**
                 * Ctrl- and StatusFlag of Animation
                 */
                trackctrl: {
                    type: String,
                    notify: true
                },
                /**
                 * temp. copy of trackctrl during animation-interrupt
                 */
                _trackctrlsave: {
                    type: Boolean
                },

                /**
                 * tmp. Flag indicating move/zoom-status of map 
                 */
                _mapismoved: {
                    type: Boolean,
                    observer: '_animationTrigger'
                },


                /**
                 * { item_description }
                 */
                trackobj: {
                    type: Object,
                    observer: '_checkTrackobj'
                },

                /**
                 * id of trackObj
                 */
                trackid: {
                    type: String,
                    value: ""
                },

                /**
                 * Default symbol for map-display of selected trackObj 
                 */
                tracksymbol: {
                    type: String,
                    value: ""
                },

                /**
                 * Status of trackobj avilable to external services 
                 * processing the data for presentation u.Ã¤.  
                 */
                trackdata: {
                    type: Object,
                    notify: true,
                    observer: '_checkTrackdata'
                },

                /**
                 * User-defined Text generated from actual trackObj-properties
                 * z.B. for use in popups !!
                 */
                trackinfo: {
                    type: Object,
                    observer: '_checkTrackinfo'
                },

                // INTERNAL variables

                /**
                 * Animation counter
                 */
                _counter: {
                    type: Number
                },

                /**
                 * Container of animation-ids
                 */
                _requestframeref: {
                    type: Array,
                    value: []
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },
                /**
                 * { item_description }
                 */
                routeid: {
                    type: String,
                    observer: 'routeFilterApply'
                }
            },

            behaviors: [
                Polymer.ToolsBehavior
            ],

            observers: [
                '_animationSourcesSetup(routedata, timer.timescale, map)',
                '_animationMapSetup(map, animationsources.*)',
                '_animationTimerRefresh(timer.*)',
                'trackCtrlAction(trackctrl)',
                'trackInfoPopup(trackinfo.*)'
            ],


            // Create a mapContent-Object for basic Layers related to animation-datasrces 
            // id : "routes", "traces", "nodes", "tracks"
            // 
            _animationContentSetup: function(id, type, srcdata, metas, paintprops, layoutprops) {

                var paints = {},
                    layouts = {},
                    layerObj = {};

                if (id == "routes") {
                    paints = {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        "line-dasharray": [4, 4]
                            //"line-color": linecolor
                    }
                }

                if (id == "traces") { // C.2 TRACE
                    paints = {
                        "line-width": 2,
                        "line-opacity": 0.5,
                        //"line-color": linecolor
                    }
                }

                if (id == "nodes") {
                    layouts = {
                        // "icon-image": "{icon}",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 10,
                        "text-offset": [0, 0.3]
                    };
                }

                if (paintprops) paints = Object.assign({}, paints, paintprops);
                if (layoutprops) layouts = Object.assign({}, layouts, layoutprops);


                if (1) { // NEW : use standard Qickmap

                    layerObj = new QuickMap(id, type, srcdata, paints, layouts, metas);

                } else { // OLD : explicit builder

                    var mbLayer = {
                        "id": id,
                        "source": id,
                        "type": type
                    };

                    layerObj['layer'] = mbLayer;
                    layerObj['meta'] = metas;
                    layerObj['srcdata'] = srcdata;
                    if (paints.length) mbLayer["paint"] = paints;
                    if (layouts.length) mbLayer["layout"] = layouts;
                }

                return layerObj;
            },


            /**
             * Create/Refresh mapLayers for changed content (routed Data)
             *
             * @param      {object}  mapcontent  The iimapslayers for animation-apps 
             * @param      {object}  map         The map to show routetracker
             */
            _animationMapSetup: function(map, mapcontent) {
                var debounceTime = 200;

                this.debounce('tomap', function() {

                    if (mapcontent.path == 'animationsources') mapcontent = mapcontent.value;
                    if (!mapcontent || !Object.keys(mapcontent).length) return;

                    console.log("SET/REFRESH content of animationMap: ", mapcontent);

                    // 1. Create/Refresh (json)data-based animation-layers

                    // OLD : private addLayer-actions
                    // mba.mbLayersSetup(map, mapcontent);

                    // NEW : trigger the STANDARD addlayer-action off quickmap-content in mb-quickview
                    this.mapcontent = mapcontent;

                    // 2. Setup Map-Events to query track-features on "mouseover" and show info-popup 

                    if (!map.listens('mousemove')) {

                        map.on('mousemove', function(e) {
                            // during animation only !!
                            if (mba.trackctrl) mba.trackObjSelect(e);
                        });

                        map.on('click', function(e) {
                            // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                            mba.trackObjSelect(e, true);
                            mba.routeNodeSelect(e);
                        });

                        // only in DEFAULT mapmode (NORTH) 
                        map.on('movestart', function(e) {
                            if (!mba.trackmapmode) { // console.log("movestart");
                                this._mapismoved = true;
                            }
                        });
                        map.on('moveend', function(e) {
                            if (!mba.trackmapmode) { // console.log("moveend");
                                mba._mapismoved = false;
                            }
                        });
                    } else {

                    }

                    // 3. (Re)Start-action(s) 

                    mba._counter = 1;

                    // Primary Zoom to ALL features after Setup
                    var mapfeatures  = mapcontent["routes"].srcdata.features; // console.log("f's at start", mapfeatures); 
                    
                    mba.trackRoutesZoomTo(mapfeatures);

                    // Set Route and RouteCtrl for first "start-time" of animation-routes   
                    mba.animationMapRefresh(mba.timer["start"], null, "FIRST START");

                }, debounceTime);
            },

            /**
             * set 'quasiglobal' this-context for recursive calls during animation 
             * and setup track-features
             */
            attached: function() {
                // 1. setup global namespace 
                mba = this;

            },

            // 
            _animationTrigger: function(mapismoved, old) {
                // console.log("mapismoved", mapismoved, old);
                if (mapismoved) {
                    //this.debounce('movestarted', function() {
                    mba._trackctrlsave = false;
                    if (mba.trackctrl == true) {
                        mba._trackctrlsave = true;
                        mba.trackctrl = false;
                        console.log("INTERRUPT track-animation");
                    }
                    //}, 200);
                } else {
                    this.debounce('movestopped', function() {
                        if ((mba.trackctrl == false) && (mba._trackctrlsave == true)) {
                            mba._trackctrlsave = false;
                            mba.trackctrl = true;
                            console.log("RESUME track-animation");
                        }
                    }, 100);
                }
            },

            /*routeFilterSetup: function(routeids) {
            },*/

            // 
            routeFilterApply: function(routeid) {
                var routeFilter, srcFeatures,
                    timer = this.timer;
                if (!timer || !timer.routes) return;

                // A. Case-by-case
                var timerEntry; 
                if (routeid=="all") {
                    console.log("Zooming to all features"); 
                } else if (routeid=="clear") {
                    console.log("NOT implemented: CLEAR all features"); 
                    return; 
                } else {
                    timerEntry = timer.routes[routeid];
                    this.trackTimerRefresh(timerEntry);
                }

                // B. SPATIAL ZOOM and Query
                if (!timerEntry) { // 
                    this.trackRoutesZoomTo();
                    this.trackFilterApply("");
                    routeFilter = this.routeFilterSetup("all");
                } else {
                    this.trackRoutesZoomTo(null, routeid);
                    this.trackFilterApply(routeid);
                    routeFilter = this.routeFilterSetup(routeid);
                }

                // routeFilter is called from timer ...
                if (!routeFilter) {
                    delete this.timer.filter;
                } else {
                    this.timer.filter = routeFilter;
                }

                // 
                srcFeatures = this.animationMapRefresh(null, routeFilter);
                // console.log("srcFeatures filtered for:" + routeid, srcFeatures, this.timer);

                if (srcFeatures.routes) {
                    // C. TEMPORAL Location at START of selected routes
                    console.log("running FIRST animation-step");
                    this.trackStepAction(1);
                }
            },


            // A. 

            /**
             * Compile a timer from animated routes
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timescale  The timescale of animation
             * @return     {Object}  Collection of timeCtrls
             */
            trackTimerSetup: function(routedata, timescale) {

                if (!this.timer) this.timer = {};
                this.timer.routes = {};
                this.timer.traces = {};

                // A. Setup basic animation-parameters          

                var fpsmax = this.timer.fpsmax ? this.timer.fpsmax : 60; // Animationszeit 1s=6*60s=6min, 10s=1h Echtzeit 
                if (!timescale) timescale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                this.timer["timescale"] = timescale;

                this.timer.frametime = timescale / fpsmax; // Bsp: frametime: 6 s fuer scale = 360 und fps=60 !!

                // B. Convert tarcelength from time to number of animation steps
                if (this.timer.tracelength) {
                    if (typeof this.timer.tracelength == "string") {
                        var tl = this.utcTime(this.timer.tracelength, null, "s"),
                            nn = Math.round(tl / this.timer.frametime);
                        // console.log("trackTimerStart", this.timer, tl, nn);
                        this.timer.tracelength = nn;
                    }
                }


                // C.1 Assemble all waypoint-times for every route 
                var wptimer = {};

                routedata.forEach(function(route, j) {
                    // console.log("route-" + j, route);
                    if (route.nodes) {

                        var starts = [],
                            stops = [];

                        route.nodes.forEach(function(wp, p) {
                            if (wp.ab) starts.push(wp);
                            if (wp.an) stops.push(wp);
                        }.bind(this));

                        // Collect 
                        wptimer[route.id] = {
                            "starts": starts,
                            "stops": stops
                        }; // [starts, stops, passes];
                    }

                }.bind(this));
                // console.log("trackTimerSetup. timer=", wptimer, routedata); // return;

                // C.2 Get start&stop times for every route and overall animation period  
                // var start, stop;

                Object.keys(wptimer).forEach(function(id) {

                    var starts = wptimer[id]["starts"],
                        stops = wptimer[id]["stops"],
                        wpstart, wpstop, routestart, routestop;

                    if (starts.length) {
                        wpstart = starts[0];
                        wpstop = starts[starts.length - 1];
                    }
                    if (stops.length) wpstop = stops[stops.length - 1];

                    if (wpstart && wpstop) {
                        routestart = this.utcTime(wpstart.ab, wpstart.coords, "h");
                        routestop = wpstop.an ? wpstop.an : wpstop.ab;
                        routestop = this.utcTime(routestop, wpstop.coords, "h");
                    }

                    this.timer.routes[id] = {
                        "id": id,
                        "start": routestart,
                        "stop": routestop,
                    };
                    if (routestart) this.timer.routes[id]["date"] = this.logTime(routestart, "h", "/")

                    //if (!start || (routestart < start)) start = routestart;
                    //if (!stop || (routestop > stop)) stop = routestop;

                }.bind(this));
                // console.log("timer for waypoints:", wptimer, timer);


                // D. OPTION: Get a sorted sequence of start-times  
                var startTimes = [],
                    stopTimes = [],
                    routes = this.timer.routes;
                for (let key in routes) {
                    startTimes.push(routes[key]["start"]);
                    stopTimes.push(routes[key]["stop"]);
                }
                startTimes.sort();
                stopTimes.sort();
                this.timer["starts"] = startTimes;
                this.timer["stops"] = stopTimes;

                this.trackTimerRefresh();
                // ** SET explicitely to notify changes for data-binding to ctrl-elements
                // console.log("Timer after trackTimerSetup:", this.timer);
            },

            // includes databinding-FORCE
            trackTimerRefresh: function(timerEntry) {
                var start, stop, n;

                if (!timerEntry) {
                    start = this.timer.starts[0];
                    stop = this.timer.stops[this.timer.stops.length - 1];
                } else {
                    start = timerEntry.start;
                    stop = timerEntry.stop;
                }

                this.set("timer.start", start);
                this.set("timer.stop", stop);
                this.set("timer.time", start);
            },


            // prepare all map- and animationdata required to view tracks on the map 
            //  - for altered routedata
            //  - if basic(=max) timescale of animation changed
            _animationSourcesSetup: function(routedata, timescale, map) {
                if (!routedata || !routedata[0] || !routedata[0].nodes) return;

                console.log("ROUTESET rawdata:", routedata);

                this.ctrlflag = false;

                this._counter = 0;

                // Remove old mapThemes, that are named like the new ones 
                this.trackFeaturesReset();

                this.trackTimerSetup(routedata, timescale);
                console.log("ROUTESET timer=", this.timer); // , routedata);

                // Order(REIHENFOLGE) important, as wp-reduction in routedata possible during route-setup  

                // OLD 
                // var sourceData = {};
                // sourceData['routes'] = this.animationRoutesSetup(routedata, this.timer); // console.log("checked route-data", routedata);
                // sourceData['traces'] = this.animationSetupTraces(routedata, this.timer);
                // NEW                 
                sourceData = this.animationRoutesSetup(routedata, this.timer); // console.log("checked route-data", routedata);

                sourceData['nodes'] = this.animationNodesSetup(routedata); // wayPoints or trackPoints

                sourceData['tracks'] = this.animationTrackerSetup(routedata, this.timer);

                console.log("animationMapSources=", sourceData);
                // ??? Doubled assignment of sourceData to trigger multi-parameter observer  ???
                this.animationsources = {};
                this.animationsources = sourceData; // triggers "refresh-action

            },

            // B. TrackCtrls

            /**
             *   switch map-orientation between north and trackaligned
             *   maporientation: true = aligned along bearing of trackObject
             */
            mapOrientationChange: function(maporientation, old) {
                if (!this.map) return;
                var trackobj = this.trackobj;
                // No maporientation if no trackObj selected
                if (maporientation && !trackobj) {
                    var msg = "<b>trackObject</b> must be activated<br> to align map along its track!"
                    this.popupOnMap(msg);
                    this.maporientation = false; // set to base 
                    return;
                }

                this.trackctrl = false; // STOP animation

                var zoom = map.getZoom(),
                    bearing = 360 + map.getBearing();
                bearing = bearing == 360 ? 0 : bearing;
                // bearing = Math.abs(map.getBearing());
                // console.log("actual mapOrientation is:", bearing, zoom);
                // zoom = Math.round(zoom); // may cause irritation

                if (maporientation) {
                    //console.log("ALIGN mapOrientation to TRACK", "object=", trackobj, "zoom=" + zoom);

                    var cc = trackobj.geometry.coordinates;
                    bearing = trackobj.properties.bearing;
                    console.log("ALIGN mapOrientation to TRACK at cc=", cc, "bearing=", bearing, "zoom=" + zoom);

                    if (zoom < 4) zoom = 4;
                    map.flyTo({
                        center: cc,
                        bearing: bearing,
                        zoom: zoom
                    });

                } else if (bearing > 0) {
                    console.log("RESET mapOrientation to North from", "bearing=" + bearing, "zoom=" + zoom);

                    if (zoom > 8) zoom = 8; // ?

                    map.easeTo({
                        bearing: 0,
                        zoom: zoom
                            //speed: 0.2, // make the easeMove slower
                            //curve: 1,   // change the speed at which it changes zoom
                    });
                }

            },

            /**
             *  event-action after ...
             *
             * @param      {<type>}  trackctrl  The trackctrl
             */
            trackCtrlAction: function(trackctrl) {
                var ctrlflag = "STOP";
                // console.log("LOG: trackctrl", trackctrl);
                if (trackctrl) {
                    // console.log("trackCtrlActn:", typeof trackctrl, trackctrl);
                    if (trackctrl == "reset") {
                        this.trackctrl = false; // triggers this function (trackCtrlAction) again 
                        this.trackmapmode = false; // 
                        this._counter = 0;
                        this.trackid = undefined; // z.B. popup.remove();

                        this.trackRoutesZoomTo();

                    } else if (typeof trackctrl == "number") {
                        // console.log("ctrltime[h] set (slider o.Ã¤.)", trackctrl)
                        var mapTime = trackctrl,
                            located = this.trackStepAction(null, mapTime);
                        if (located) ctrlflag = "CONT";

                    } else {
                        ctrlflag = "START";
                    }

                } else {

                    if (this._counter) {
                        var trackObjs = [];
                        if (this.map) trackObjs = this.map.querySourceFeatures({
                            layers: ['tracks']
                        });
                        // console.log("STOPPED track at cnt=" + this._counter + " with objs", trackObjs);
                    }
                }

                if ((this._counter <= 1) && (this.map.getSource('routes'))) { // == 0
                    // RESET to START
                    // console.log("Reset tracking objects");
                    this.animationRoutesSetup(this.routedata, this.timer);
                    // Set the coordinates of the tracker and traces back to origin
                    this.animationTrackerSetup(this.routedata, this.timer);
                    //this.animationSetupTraces(this.routedata, this.timer);

                    this.map.getSource('routes').setData(this.routes);
                    this.map.getSource('tracks').setData(this.tracks);
                    this.map.getSource('traces').setData(this.traces);
                }

                this.trackStepAnimation(ctrlflag);
                // *******************************
            },


            // C. TrackStep-Animation 

            /**
             *  
             */
            trackStepAnimation: function(flag) {
                if (!mba) return;
                // var timer = mba.timer;
                if (!mba.timer) {
                    mba.popupOnMap("OOPS. AnimationTimer n.a.");
                    mba.trackctrl = false;
                    return;
                }
                // 1. Remove OLD animationRefs
                var rfr = mba._requestframeref;
                // console.log("CTRL " + flag, rfr, "timer=", mba.timer);
                if (rfr && rfr.length) {
                    rfr.forEach(function(r) {
                        cancelAnimationFrame(r);
                    })
                }

                if (flag == "STOP") {
                    return;
                }

                // 2. Start new animationFrame
                mba._requestframeref = [];
                // let timer = mba.timer;
                if (mba.timer.fps && (mba.timer.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                    setTimeout(function() {
                        mba._requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                    }, 1000 / mba.timer.fps);
                } else { // system-based Recall-frequency 
                    mba._requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                }
            },

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {

                var tracks = mba.tracks;
                if (!tracks || !tracks.features) {
                    mba.popupOnMap("OOPS. TrackData n.a.");
                    mba.trackctrl = false;
                    return;
                }

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.

                var mapTime = (mba.timer["start"]) + (mba._counter * mba.timer.frametime / 3600);

                // ******************************
                var located = mba.trackStepAction(mba._counter, mapTime);
                // ******************************

                // B. Transfer to map 

                if (!located) {
                    var t_msg = mba.logTime(mapTime, "h"),
                        s = mba.getNextStart(mapTime);

                    if (s) {
                        let ds = s - mapTime,
                            ds_msg = mba.deltaT(ds, "");
                        msg = "NextStart at: " + mba.logTime(s, "h") + "<hr>TTT: " + ds_msg;
                    } else {
                        msg = "IDLE: " + t_msg;
                    }

                    mba.popupOnMap(msg);

                } else {
                    // mba.map.getSource('tracks').setData(mba.tracks);
                }

                // C. Request the next frame of animation 
                mba._counter = mba._counter + 1;

                // D. Animation RECALL 
                if (mba.trackctrl) {
                    mba.trackStepAnimation("CONT");
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function ctrls 
                // - the location of trackObjects 
                // - the visibility (via Refresh of animationMap)  and  
                // at the mapTime (related to "counter")     
                var timer = mba.timer,
                    map = mba.map,
                    located = 0,
                    mapMsg = "",
                    routeFilter = timer.filter;
                // tracelength = timer.tracelength;

                // A.0 Sync alternative timing sources 
                // 
                if (!counter) {
                    counter = 0;
                    if (mapTime) {
                        counter = (mapTime - timer["start"]) * 3600 / timer.frametime;
                        counter = Math.round(counter);
                    }
                    // 
                    if (counter == 0) counter = 1;
                    mapMsg += "mapTIME"
                }

                if (counter && !mapTime) {
                    mapTime = (timer["start"]) + (counter * timer.frametime / 3600);
                }

                // A.1 Timesignal for other elements 
                mba._counter = counter;
                mba.set('timer.time', mapTime);
                // ****************************

                // A.2 Integrated RESET-function 
                //     after setting the animation-starttime
                if (counter == 1) {
                    // console.log("zoom at counter=0", timer);
                    mba.trackRoutesZoomTo(null, null, timer.filter); // zoom to max Extent of (all) route(s)
                    mba.trackctrl = false // RESET trackObject 
                }

                // B. REFRESH the srcdata of those trackObjects/trackTraces 
                //    whose start and stop imbed actual mapTime  
                mba.tracks.features.forEach(function(trackObj, j) {

                    // !!! routes and tracks(Objs) are linearely structured 
                    //     "in-sync" referenced through the same index j  
                    var route = mba.routes.features[j],
                        trackTrace = mba.traces.features[j];

                    var routeProps = route.properties,
                        routeid = routeProps.id,
                        legdata = routeProps.legs,
                        routeStartCounter = routeProps.startCounter;

                    if (mapTime > routeProps.stop) { // A. BREAK "" after end of this route 

                        if (routeStartCounter != null) { // must be valid for 0 too
                            routeProps.startCounter = null;

                            mba.trackStepTracer("STOP");
                            mapMsg += ",STOP:" + routeid;
                        }

                    } else if (mapTime >= routeProps.start) { // B.     

                        if (routeStartCounter == undefined) { // 
                            // FIRST access to this route during animation

                            routeStartCounter = Math.round((routeProps.start - (timer["start"])) / (timer.frametime / 3600));

                            routeProps.startCounter = routeStartCounter;
                            mapMsg += ",START:" + routeid;
                        }

                        var legStartAt = routeStartCounter;

                        var typ = route.geometry.type,
                            legCoordSet = route.geometry.coordinates;

                        if (typ == "MultiLineString") { // multiple legs
                        } else { // one leg only 
                            legCoordSet = [legCoordSet];
                        }

                        // Iterate along the route-legs until the track-counter is located within one. 
                        // Get legInfo and cc of the leg selected.

                        var legInfo, cc, traceCoords;

                        legCoordSet.every(function(legPositions, i) {
                            // return true if xxx, false if xxx

                            if (counter < (legStartAt + legPositions.length)) {
                                cc = legPositions[counter - legStartAt];
                                // *************************************
                                if (cc) {
                                    legInfo = legdata[i];
                                    return false;
                                }
                            }

                            legStartAt = legStartAt + legPositions.length;
                            return true; // wichtig !!
                        })

                        // Update the trackObj-properties according to its location on the route
                        if (cc) {
                            // console.log("route:"+routeid, legStartAt, counter,  mapTime, cc);
                            located += 1;

                            // Option: EXTEND/MOVE the trackTrace 
                            if (trackTrace && timer.traces && timer.traces[routeid]) {
                                traceCoords = mba.trackStepTracer(mapTime, routeid, timer);
                                trackTrace.geometry.coordinates = traceCoords;
                            }

                            // A. MOVE the trackObject 
                            trackObj.geometry.coordinates = cc;

                            // B. Eval STATUS between 2 animation-points 

                            if (trackObj.properties.lastPos) {
                                mba.trackStepStatus(trackObj, legInfo, mapTime);
                            }

                            // C. SYNC content (and location) of the info-popup 
                            //    if trackObj is selected as "tracked Object" 

                            if (mba.trackid == trackObj.properties.id) {

                                // REFRESH trackdata to trigger INFO-element(-popup) 
                                // NOT in trackmapmode
                                if (!mba.trackmapmode) {
                                    mba.trackdata = {
                                        "id": mba.trackid,
                                        "lnglat": cc,
                                        "trackobj": trackObj
                                    }
                                } else { // trigger CLOSE of tarckInfo (fi. on map)
                                    mba.trackdata = {
                                        "open": false
                                    };
                                }

                                // in track-align map-orientation 
                                // the map is continuously centered at trackObj 
                                // and the trackObj-symbol is aligned to bearing
                                var trackBearing = trackObj.properties.bearing;
                                console.log("trackBearing", trackBearing, mba.trackmapmode);
                                if (mba.trackmapmode) {

                                    let map = mba.map;
                                    map.easeTo({
                                        center: cc,
                                        bearing: trackBearing
                                    });

                                    map.setLayoutProperty('tracks-select', 'icon-rotate', 0);
                                } else {
                                    // align selected tracksymbol along bearing
                                    map.setLayoutProperty('tracks-select', 'icon-rotate', trackBearing);
                                }
                                // 
                                if (trackObj.properties.arrived) {
                                    // mba.trackmapmode = false;
                                }

                            } else {
                                // align all tracksymbols along its bearing
                                // requires filtering of the tracklayer-feature related to trackObj   
                                // map.setLayoutProperty('tracks', 'icon-rotate', trackObj.properties.bearing);
                            }

                            // D. 
                            trackObj.properties.lastPos = cc;
                        }
                    }
                });

                // C. APPLY the updated sources of the animation-layers
                var s1 = mba.map.getSource('tracks');
                var s2 = mba.map.getSource('traces');
                if (s1) s1.setData(mba.tracks);
                if (s2) s2.setData(mba.traces);

                // D. 
                if (mapMsg) { // console.log(mapMsg);
                    mba.animationMapRefresh(mapTime, routeFilter, mapMsg);
                    // ********************
                }

                return located;
            },

            // Calc status-parameters at mapTime and save as trackObj-properties
            trackStepStatus: function(trackObj, legInfo, mapTime) {

                var speedFlag = true;

                var routeunitsystem = trackObj.properties.unitsystem;
                // console.log("trackStepStatus with " + routeunitsystem + " unitsystem from ", legInfo, trackObj);

                trackObj.properties.time = this.logTime(mapTime, "h");

                var cc = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos,
                    legTarget = legInfo.to;

                // calc the bearing between "actual" and 'last' Position of trackObj 
                var bearing = turf.bearing(new TrackSource(lastPos), trackObj);
                if (bearing < 0) bearing = bearing + 360;
                if (bearing > 360) bearing = bearing - 360;

                // temporary Leg to calculate DTA
                var legToArrival = new LegSource([cc, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers");

                var v = legInfo.speed,
                    dist = legInfo.dist,
                    speedUnit = "kmh",
                    distUnit = "km";

                if (v && Math.round(dta / 10)) { // TrackObj is "Moving" 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.tta = tta;
                    trackObj.properties.bearing = Math.round(bearing); // Â°
                    trackObj.properties.arrived = null;
                    trackObj.properties.ttt = null;

                    if (routeunitsystem == "nautic") {
                        speedUnit = "nds";
                        distUnit = "nm";

                        trackObj.properties.speed = Math.round(v / 1.856); // nds
                        trackObj.properties.dist = Math.round(dist / 1.856); // nm
                        trackObj.properties.dta = Math.round(dta / 1.856); // nm

                    } else if (routeunitsystem == "angloamerican") {
                        speedUnit = "mph";
                        distUnit = "mil";

                        trackObj.properties.speed = Math.round(v / 1.609); // mph
                        trackObj.properties.dist = Math.round(dist / 1.609); // miles
                        trackObj.properties.dta = Math.round(dta / 1.609); // miles

                    } else {

                        trackObj.properties.speed = Math.round(v); // km/h
                        trackObj.properties.dist = Math.round(dist); // km
                        trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    }

                    if (speedFlag) {
                        trackObj.properties.title = trackObj.properties.speed + speedUnit;
                        console.log("speed=", trackObj.properties.title);
                    }

                } else { // Resting(pausing) objects 

                    if (!v) trackObj.properties.bearing = 0; // stÃ¶rend on track-animation
                    trackObj.properties.speed = 0;
                    trackObj.properties.dist = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;

                    if (legTarget.ab && (legTarget.ab != legTarget.an)) {

                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        trackObj.properties.arrived = "Stopover: " + stoptime;

                        let cntdwn = this.deltaT(legTarget.dep - mapTime, ":");
                        trackObj.properties.ttt = cntdwn;

                    } else {

                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },

            // Get the trace of a route at a mapTime
            trackStepTracer: function(mapTime, routeid, timer) {
                if (mapTime == "STOP") return [];

                var tracelength = timer.traces[routeid].length;
                if (typeof timer.tracelength == "number") tracelength = timer.tracelength;

                var tracetemplate = timer.traces[routeid],
                    startTime = timer.routes[routeid].start,
                    traceCounter = Math.round((mapTime - startTime) / (timer.frametime / 3600)),
                    first = traceCounter < tracelength ? 0 : traceCounter - tracelength,
                    last = traceCounter;
                // console.log(traceCounter, first, last, tracelength);
                // return traceCoords;
                return tracetemplate.slice(first, last);
            },



            // D. SETUP elements ctrling and/or illustrating the tracking 

            // Initialisierung der animation-feature(collections)
            trackFeaturesReset: function() {
                var lnames = ["routes", "traces", "tracks", "nodes"];
                // console.log("trackFeaturesReset for objects:", lnames);
                lnames.forEach(function(lname) {
                    // console.log("RES:", lname);
                    if (mba.map.getLayer(lname)) mba.map.removeLayer(lname);
                    if (mba.map.getLayer(lname + "-select")) mba.map.removeLayer(lname + "-select");
                    if (mba.map.getLayer(lname + "-glow")) mba.map.removeLayer(lname + "-glow");
                    if (mba.map.getLayer(lname + "-glow-strong")) mba.map.removeLayer(lname + "-glow-strong");
                    if (mba.map.getLayer(lname + "-bg")) mba.map.removeLayer(lname + "-bg");

                    if (mba.map.getSource(lname)) mba.map.removeSource(lname);

                    this[lname] = {
                        "type": "FeatureCollection"
                    };
                }.bind(this));

            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationNodesSetup: function(routedata) {
                // console.log("setupAnimationNodes. srcdata:", routedata);
                this.nodes.features = [];
                var allnodes = this.nodes,
                    nodemetas = {},
                    id;

                routedata.forEach(function(route, j) {
                    // locate trackObj at 'origin'
                    if (route.nodes) {
                        // console.log("route-" + j, route.nodes);
                        route.nodes.forEach(function(wp, p) {
                            var key,
                                coords,
                                newNode,
                                props = {},
                                meta = wp.meta;

                            if (wp.id) key = wp.id;
                            else if (meta && meta.id) key = meta.id;
                            else key = p;

                            allnodes.features.forEach(function(nod) {
                                // do NOT add nodes multiple times (fi airports of different flights)
                                if ((key != p) && (nod.id == key)) {
                                    // console.log("doubling routenode", key, route.id);
                                    newNode = nod;
                                }
                            });

                            if (!newNode) {
                                if (wp.coords) coords = wp.coords;
                                else if (meta.coords) coords = meta.coords;
                                else key = p;

                                Object.keys(wp).forEach(function(k) {
                                    if (k != "coords") props[k] = wp[k];
                                });

                                // console.log("wp-" + p, key, wp, props);
                                newNode = new NodeSource(coords, key, route.id, props);
                                if (wp.meta) {
                                    newNode.properties = Object.assign({}, newNode.properties, wp.meta);
                                    nodemetas[key] = wp.meta;
                                }

                                allnodes.features.push(newNode);
                            }
                        });
                    }
                });
                // console.log("all waypoints collected", allwaypoints.features);

                // Prepare ddr-styling (circle-size of symbol-bg)
                var nodesize = 2,
                    size, smin, smax;
                Object.keys(nodemetas).forEach(function(id) {
                    size = nodemetas[id].size;
                    if (size) {
                        if (!smin || (size < smin)) smin = size;
                        if (!smax || (size > smax)) smax = size;
                    }
                })

                if (smin && smax && (smin < smax)) {
                    nodesize = {
                        property: 'size',
                        stops: [
                            [smin, 4],
                            [smax, 12]
                        ]
                    }
                }

                var mapObjNodes = this._animationContentSetup("nodes", "symbol", allnodes, nodemetas);

                // additional layer to the same src
                mapObjNodes['bglayer'] = {
                    "id": "nodes-bg",
                    "type": "circle",
                    "source": "nodes",
                    "paint": {
                        "circle-radius": nodesize,
                        "circle-opacity": 0.5,
                        "circle-color": "red"
                    }
                };

                //console.log("nodeLayer", nodeLayer);
                return mapObjNodes;
            },

            /**
             * create the mapContentObj for trackLayer
             *
             * @param      {object}  routedata     The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationTrackerSetup: function(routedata, timer) {
                // console.log("routedata at setupAnimationTracker", routedata);
                // the trackLayerObj contains the data, the styling of the baseLayer AND the styling for the selectLayer

                var tracksymbol = this.tracksymbol;
                if (!tracksymbol) tracksymbol = "airport-15";

                // A. setup data 
                this.tracks.features = [];

                var allTracks = this.tracks,
                    startort, trackmeta,
                    props = {},
                    routemetas = {};

                routedata.forEach(function(route, j) {
                    // console.log(route);
                    if (route.nodes && route.nodes.length) {
                        // Basic properties 
                        trackmeta = route.item;
                        if (!trackmeta) trackmeta = route.meta;
                        if (!trackmeta) trackmeta = route.master;
                        if (!trackmeta) trackmeta = {};
                        trackmeta["id"] = route.id;

                        routemetas[route.id] = trackmeta;
                        // console.log(route,trackmeta);

                        props = {
                            "routeid": route.id,
                            "id": trackmeta.id,
                            "title": trackmeta.id,
                            "unitsystem": route.unitsystem,
                            "bearing": 0,
                            "start": timer.routes[route.id]["start"],
                            "stop": timer.routes[route.id]["stop"]
                        };
                        // Optional: masterdata-properties
                        props["master"] = trackmeta;

                        // Required : icon; 
                        if (trackmeta.icon) props.icon = trackmeta.icon;

                        // Optional: 
                        if (trackmeta.iconsize) props.iconsize = trackmeta.iconsize;

                        // Create Tracker and locate at start 
                        startort = route.nodes[0].coords;

                        var aTrack = new TrackSource(startort, route.id, props);

                        allTracks.features.push(aTrack);
                    }
                });


                // B. Setup ONE Layer for multiple trackers (DynamicPoints)
                // = trackers should use "ddr styling" 

                var type, layouts, paints;

                var hasIcon = (routedata[0].item && routedata[0].item.icon);
                if (hasIcon) { //  EITHER: RotatingSymbol-Layer 

                    type = "symbol";

                    // ddr styling enables  
                    // A. in Quick-Mode: variable Icon and text 
                    // B. in LUT-Mode: symbol-rotation according to bearing 
                    // var symbolrotation = 0;
                    var symbolrotation = {
                        property: 'bearing',
                        stops: [
                            [0, 0],
                            [360, 360]
                        ]
                    };

                    layouts = {
                        "icon-image": "{icon}",
                        "icon-rotate": symbolrotation,
                        "text-field": "{title}",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 12,
                        "text-offset": [0, 0.6],
                        "text-anchor": "top"
                    };

                } else { // OR : ColorableCircle-Layer 

                    type = "circle";

                    // ddr styling enables different colors for every tracker
                    var symbolcolor = "black";
                    var ddrSymbolcolor = {
                        property: 'id',
                        type: 'categorical',
                        stops: []
                    };

                    Object.keys(routemetas).forEach(function(id) {
                        var col = routemetas[id].color;
                        // if (!col) col = symbolcolor;
                        if (!col) col = this.getRandomColor();
                        ddrSymbolcolor.stops.push([id, col]);
                    }.bind(this))

                    if (ddrSymbolcolor.stops.length) {
                        symbolcolor = ddrSymbolcolor;
                    }

                    paints = {
                        'circle-radius': 6,
                        'circle-color': symbolcolor
                    }
                }

                // B. SET Basic-Presentation of multiple Trackers

                var trackLayerObj = this._animationContentSetup("tracks", type, allTracks, routemetas, paints, layouts);

                // C. ADD SPECIFIC presentation of one!! "filtered" trackInfoObj (app-specific)
                //    
                trackLayerObj['selectlayer'] =
                    // A meaningful TrackPoint-presentation built from 3 Layers 
                    // 
                    [{
                        "id": "tracks-glow-strong",
                        "type": "circle",
                        "source": "tracks",
                        "paint": {
                            "circle-radius": 18,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.6
                        }
                    }, {
                        "id": "tracks-glow",
                        "type": "circle",
                        "source": "tracks",
                        "paint": {
                            "circle-radius": 40,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.2
                        }
                    }, {
                        "id": "tracks-select",
                        "type": "symbol",
                        "source": "tracks",
                        "layout": {
                            "icon-image": tracksymbol,
                            "icon-rotate": 0,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        }
                    }];
                // console.log("trackLayerObj", trackLayerObj);
                return trackLayerObj;
            },

            /**
             * Setup routes optimized for animation with "requestAnimationFrame (60 fps)"
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            animationRoutesSetup: function(routedataset, timer) {
                // console.log("setupAnimationRoutes, configdata:", routedataset);

                /** Basic routeCreate-action   
                 * compile coords of all route-legs into one coordinatecollection 
                 */
                function animationRouteCreate(routedata, timer) {
                    // console.log("Initialize route from", data, timer);

                    var frametime = timer.frametime;

                    var nextNode, legDistance, legStepCount;

                    var routeid = routedata.id,
                        legsData = [], // mean props of every leg    
                        legsCoords = [], // coords of every leg
                        legTimeSec, legStopSec, legSpeed, routespeed;

                    var props = {
                        "id": routeid,
                        "start": timer.routes[routeid]["start"],
                        "stop": timer.routes[routeid]["stop"]
                    };
                    if (routedata.speed) {
                        props.speed = routedata.speed;
                    }

                    // console.log("Initialize route from", data, timer, props);

                    var srces = {};

                    // A. Create route-object consisting of 1-n legs

                    // Create route-legs between 2 waypoints at any one time 
                    var routeNodes = routedata.nodes; // wps as given

                    routeNodes.forEach(function(wp, p) {

                        legStopSec = 0;
                        nextNode = routeNodes[p + 1];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("waypoints:" + p, wp, nextNode);
                            // Calculate the distance in kilometers between waypoints
                            var leg = new LegSource([wp.coords, nextNode.coords]),
                                legDistance = turf.lineDistance(leg, 'kilometers');

                            // legDistance = Math.round(legDistance);

                            // Calculate a mean leg-speed between wp's with ab/an times
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                    arv = mba.utcTime(nextNode.an, nextNode.coords, "h");
                                legSpeed = legDistance / (arv - dep);
                                nextNode.arv = arv;
                            } else if (nextNode.speed) {
                                legSpeed = nextNode.speed;
                            }
                            // legSpeed = Math.round(legSpeed);
                            //console.log("leg-speed-calc", legDistance, legSpeed, nextNode, wp);

                            // Calculate arv and dep at "stopover"
                            if (nextNode.an && nextNode.ab) {
                                let arv = mba.utcTime(nextNode.an, nextNode.coords, "h"),
                                    dep = mba.utcTime(nextNode.ab, nextNode.coords, "h");
                                legStopSec = (dep - arv) * 3600;
                                nextNode.arv = arv;
                                nextNode.dep = dep;
                            } else if (nextNode.stopover) {
                                legStopSec = nextNode.stopover;
                            }
                            // 3. Calc leg-animation 

                            // Time and number of animation-steps to travel between waypoints in legTimeSec
                            legTimeSec = legDistance / legSpeed * 3600;
                            legStepCount = Math.round(legTimeSec / frametime);

                            // console.log(p + ". leg-data for dx=" + legDistance, "n=" + legStepCount);

                            // Assign basic leg-properties
                            var legInfo = {};
                            legInfo.from = wp;
                            legInfo.to = nextNode;

                            legInfo.dist = legDistance;
                            legInfo.speed = legSpeed;

                            legInfo.time = legTimeSec;
                            legInfo.steps = legStepCount;

                            // Assign time-properties
                            var h = Math.floor(legTimeSec / 3600),
                                m = Math.round((legTimeSec - (h * 3600)) / 60);
                            legInfo.timetext = h + "h" + m + "min";

                            // Insert animation-positions along the leg
                            var startPosition = 0;
                            var legPositions = [];

                            for (let i = 0; i < legStepCount; i++) {
                                let dist = i * (legDistance / legStepCount);
                                let position = turf.along(leg, dist, 'kilometers');
                                legPositions.push(position.geometry.coordinates);
                            }

                            // 4. Append "STOPOVER-animation" 
                            //    into 
                            if (legStopSec) { // INSERT some "zero-steps" at stopover waypoint 
                                // console.log("INSERT STOPover at ", nextNode, legStopSec);
                                h = Math.floor(legStopSec / 3600);
                                m = Math.round((legStopSec - (h * 3600)) / 60);
                                legInfo.stopTime = h + "h" + m + "min";
                                var n = Math.round(legStopSec / frametime);
                                legInfo.stopSteps = n;
                                // append the "stop-coordinates" to the leg 
                                for (let i = 0; i < n; i++) {
                                    legPositions.push(legPositions[legPositions.length - 1]);
                                }
                            }

                            // 4. Compile leg-data in route-collections of legs  
                            // console.log("leg-data ", legInfo, legPositions);
                            legsData.push(legInfo);
                            legsCoords.push(legPositions);
                        }
                    });

                    srces["routeSrc"] = new RouteSource(routeid, props, legsCoords, legsData, routeNodes);

                    // B. Save the complete trace of a route as template for dynamic traces 
                    // 
                    if (timer.tracelength) {
                        var coordinates = [];
                        legsCoords.forEach(function(legcoords) {
                            coordinates = coordinates.concat(legcoords);
                        });
                        timer.traces[routeid] = coordinates;

                        // Create "complete" trace-object with startpoint only
                        // var tSrc = new TraceSource(coordinates, routeid);
                        // Create "initial" trace-object with startpoint only
                        srces["traceSrc"] = new TraceSource(coordinates.slice(0, 1), routeid);
                    }

                    // console.log("New routeSrces: " + routeid, rSrc, tSrc);
                    return srces;
                }

                this.routes.features = [];
                this.traces.features = [];
                var routemetas = {},
                    rr, r, t, m;

                // A. Interpolate the Routes between waypoints(trackpoints) 
                //    based on info about speed and/or arrival-/departure-times at waypoints
                routedataset.forEach(function(routedata, j) {
                    if (routedata.nodes && routedata.nodes.length) {
                        // A.1 track-based routes should be preprocessed to minimie gps-noise 
                        if (routedata.trackmode) {
                            routedata = this.trackedDataCheck(routedata, timer);
                        }

                        // A.2 **********************
                        rr = animationRouteCreate(routedata, timer);
                        // **********************

                        // A.3 
                        if (rr) {
                            // console.log("setupAnimationRoute:" + j, rr);
                            r = rr.routeSrc;
                            if (!routedata.meta) routedata.meta = {};
                            if (!routedata.meta.color) routedata.meta.color = this.getRandomColor();

                            routemetas[r.id] = routedata.meta;

                            r.properties = Object.assign({}, r.properties, routedata.meta);
                            this.routes.features.push(r);

                            // IF prepared, add trace-features 
                            t = rr.traceSrc;
                            if (t) {
                                t.properties = r.properties;
                                this.traces.features.push(t);
                            }
                        }
                    }

                }.bind(this));
                // console.log("Srces:", this.routes.features, this.traces.features);
                // return;

                // B. STYLING the color of different routes() line-color 
                var linecolor = "#007cbf";

                // optional: ddr-styling based on routeid
                var ddrLinecolors = {
                    property: 'id',
                    type: 'categorical',
                    stops: []
                };

                // insert different colors into "stops" 
                // of linecolor-styling with ddrLinecolors 
                if (Object.keys(routemetas).length) {
                    Object.keys(routemetas).forEach(function(id) {
                        var col = routemetas[id].color;
                        if (!col) col = linecolor;
                        if (!col) col = this.getRandomColor();
                        ddrLinecolors.stops.push([id, col]);
                    }.bind(this));

                    linecolor = ddrLinecolors;
                }

                var routePaintProps = {
                    "line-color": linecolor
                };

                // C. FINAL mb-Objects

                var mapObjRoutes = this._animationContentSetup("routes", "line", this.routes, routemetas, routePaintProps);

                var mapObjTraces = this._animationContentSetup("traces", "line", this.traces, routemetas, routePaintProps);

                // RETURN: 
                // console.log("ThemeObjs:", mapObjRoutes, mapObjTraces);
                return {
                    "routes": mapObjRoutes,
                    "traces": mapObjTraces
                };
            },

            // Conditional routecreate-action (If a route is based on "trackPoints")  
            trackedDataCheck: function(data, timer) {

                var trackpoints = [],
                    routeNodes = data.nodes, // waypoints/trackpoints 
                    frametime = timer.frametime,
                    deltaX = 10, // stdDev of device
                    legspeed, legTimeSec, wp, nextNode;
                // console.log("original trackpoints", routeNodes);

                var p = 0;
                while (p < routeNodes.length) {
                    wp = routeNodes[p];
                    i = 1;
                    while (i > 0) {

                        nextNode = routeNodes[p + i];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("routeNodes:" + p, wp, nextNode);
                            // A. Check 
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, wp.coords, "s"),
                                    arv = mba.utcTime(nextNode.an, nextNode.coords, "s");
                                legTimeSec = (arv - dep);
                            } else {
                                legTimeSec = wp.stopover;
                            }

                            // CHECK time-diff between wps
                            // ABANDON wp, if smaller then timeframe 
                            if (legTimeSec > frametime / 2) {
                                // B. Check DIST between routeNodes
                                //    ABANDON wp, if smaller then deltaX
                                var leg = new LegSource([wp.coords, nextNode.coords]),
                                    legDistance = turf.lineDistance(leg, 'kilometers'),
                                    legDistMeters = Math.round(legDistance * 1000);

                                if (legDistMeters > deltaX) {

                                    // Time and number of animation-steps to travel between routeNodes in legTimeSec
                                    // legTimeSec = legDistance / legSpeed * 3600;
                                    legStepCount = Math.round(legTimeSec / frametime);

                                    // console.log("leg-data ", "dx=" + legDistance, "dt=" + legTimeSec, "steps=" + legStepCount); // , frametime);
                                    // return;
                                    p = p + i;
                                    trackpoints.push(wp)
                                    i = 0;

                                } else {
                                    i = i + 1;
                                }

                            } else {
                                i = i + 1;
                            }

                        } else {
                            p = routeNodes.length;
                            i = 0;
                        }
                    }
                }

                if (nextNode) trackpoints.push(nextNode);
                // console.log("checked trackpoints", trackpoints);
                data.nodes = trackpoints;
                return data;
            },

            // E. Additional Functions
            trackFilterApply: function(filter) {
                // A. HIDE the SELECT-Track-symbols
                var names = ["tracks-select", "tracks-glow", "tracks-glow-strong"];
                names.forEach(function(lname) {
                    if (mba.map.getLayer(lname)) mba.map.setFilter(lname, ["==", "id", filter]);
                });
                
                //mba.map.setFilter("tracks-select", ["==", "id", filter]);
                //mba.map.setFilter("tracks-glow", ["==", "id", filter]);
                //mba.map.setFilter("tracks-glow-strong", ["==", "id", filter]);
            },

            // SYNC visibility at "mapTime"
            // of TrackObjects and related map-layers 
            animationMapRefresh: function(mapTime, routeFilter, syncflag) {
                // console.log("DEBUG", mapTime, routeFilter, syncflag);
                var stopDelay = 2000; // time to let last situation "visible" before reset 

                // TIME filter: applied, on every maptime ??
                function applyTrackFilter(mapTime, routeFilter, flag) {
                    if (!flag) flag = "noflag";

                    var routeids = [],
                        routeid,
                        trackFilter;

                    // A. Apply TIME-FILTER on "ALL" trackObjects 
                    //    with start- and stop-properties  
                    //    (is applied on sourcedata)

                    if (mapTime) {
                        trackFilter = [
                            'all', ['<=', 'start', mapTime],
                            ['>=', 'stop', mapTime]
                        ];
                        if (routeFilter) trackFilter.push(routeFilter)

                    } else if (routeFilter) {
                        trackFilter = routeFilter

                    } else {
                        trackFilter = null;
                    }
                    // console.log("trackFilter", trackFilter);

                    // Refresh tracks on map
                    var trackObjs = [];

                    if (mba.map.getLayer("tracks")) {
                        // A.1. Filter the visibility of tracks-theme-elements
                        mba.map.setFilter('tracks', trackFilter);

                        // A.2 Query the Features 
                        trackObjs = this.map.querySourceFeatures("tracks", {
                            filter: trackFilter
                        });
                    }

                    if (mapTime && !trackObjs.length) {

                        var msgTime = mba.logTime(mapTime, "h"),
                            nextTime = mba.getNextStart(mapTime);

                        if (!nextTime) { // CHECK for STOP
                            // B.1 No trackfeature defined for filtertime
                            //  STOP animation, if no further track-Start is pendig 

                            mba.trackctrl = false;
                            mba.trackmapmode = false;
                            let msg = "STOPPED. No more data after: " + msgTime;

                            // console.log(msg);
                            mba.popupOnMap(msg);

                            // Triggers view of all routes after Animation-STOP
                            trackObjs = this.map.querySourceFeatures("tracks", {
                                filter: null
                            });

                        } else {
                            // B.2 
                            let msg = msgTime + ". WAITING for next track at: " + mba.logTime(nextTime, "h");
                            // console.log(msg);
                        }

                    }

                    // B.2 Some trackObjs animated at filter-time  
                    if (flag.indexOf('TIME') >= 0) {
                        // console.log("trackObjs filtered at ", msgTime, trackObjs, startStopFilter);
                    }

                    // C. Get route-ids of active trackers
                    //    to prepare SECONDARY FILTER 
                    //    to Sync the filters for "related" layers (traces, routes, waypoints)  

                    // collect ROUTES of all actually "active" trackObjs    
                    trackObjs.forEach(function(to) {
                        routeid = to.properties.routeid;
                        if (routeid) routeids.push(routeid);
                    });

                    // remove possible "DUPLICATES" ? 
                    routeids = routeids.filter(function(item, pos, self) {
                        return self.indexOf(item) == pos;
                    })

                    // Create STATUS-Msg  
                    var info = flag.substring(0, 15) + "...",
                        msg = "<b>" + info + "</b>" +
                        "<br>" + routeids.length + " track(s) active";

                    if (mapTime) msg += "<br> at " + mba.logTime(mapTime, "h", "_");

                    mba.popupOnMap(msg);

                    return routeids;
                };

                // 1. Optional BREAK! 
                // Sync trackObjects(and it's routes) only as long as they are tracked 
                if (!mba.map.getLayer("tracks") && mapTime) {
                    var syncTime = this.logTime(mapTime, "h"),
                        msg = "<b>No trackers on map to track</b>" + " at " + syncTime;
                    mba.popupOnMap(msg);
                    return;
                }

                // 2. Additional HIDE-Filters after STOP-action
                if (syncflag && syncflag.indexOf("STOP") >= 0) {
                    // Always apply syncfilter "immediately"
                    // BUT "stopfilter" after some "stopDelay"
                    // to let user observe arrived tracker during this delay before removing the tracker and related features 

                    // B. Apply "empty mapTime-Filter" on trackLayers after stopDelay  
                    setTimeout(function() {
                        mba.trackFilterApply("");
                    }, stopDelay);
                    // return;
                }

                // 3. Apply filter for All other flags but STOP 
                var trackids = applyTrackFilter(mapTime, routeFilter, syncflag);
                //console.log("REFRESH: ids of trackFeatures", trackids);

                // 4. 
                var syncFilter = mba.routeFilterSetup(trackids);

                var srcFeatures = mba.syncFilterApply(syncFilter); // ,trackids);
                //console.log("REFRESH: srcFeatures with", routeFilter, srcFeatures);
                return srcFeatures;
            },

            routeFilterSetup: function(routeids) {

                var syncFilter = ["in", "routeid"];

                if (typeof routeids == "string") { // select one or none ("") 

                    if (routeids == "none") {
                        syncFilter.push("");

                    } else if (routeids == "all") {
                        syncFilter = null;

                    } else {
                        syncFilter.push(routeids);
                    }

                } else if (!routeids || !routeids.length) { // select all
                    //syncFilter = null; //n = "all";
                    syncFilter.push("");

                } else { // 
                    // syncFilter = syncFilter.concat(routeids);
                    routeids.forEach(function(id) {
                        syncFilter.push(id);
                    });
                }
                // console.log("routeFilterSetup", routeids, syncFilter);

                return syncFilter;
            },

            // SYNC "related" animationLayers with tracker of active route
            syncFilterApply: function(syncFilter) { // , boxflag) {
                // Filter  mapFeatures "related"  to animating trackers (identified by routeid-property) 
                // or none 
                // or all 

                // 1. Generate "syncfilter" 
                var srcNames = ["traces", "routes", "nodes"],
                    srcFeatures = {},
                    msg = 0;

                if (!syncFilter) { // select one or none ("") 
                    msg = "all";
                } else {
                    msg = "???"
                }

                // 2. Get src-features of animationThemes related to syncFilter 

                srcNames.forEach(function(sname) {
                    var src = mba.map.getSource(sname);
                    if (src) {
                        var features = mba.map.querySourceFeatures(sname, {
                            filter: syncFilter
                        });
                        // console.log(sname, features, src);
                        if (features.length) srcFeatures[sname] = features;
                    }
                });
                // console.log("Apply SYNC-Filter", syncFilter);

                // 3. Update the mapLayers

                srcNames.forEach(function(sname) {
                    if (mba.map.getLayer(sname)) {
                        mba.map.setFilter(sname, syncFilter);
                        if (sname == "nodes") mba.map.setFilter(sname + '-bg', syncFilter);
                    }
                })

                return srcFeatures;
            },

            // Zoom to bbox of all raw route-nodes (waypoints, trackpoints) 
            // 
            trackRoutesZoomTo: function(routeFeatures, routeid, filter, msg) {
                if (!msg) msg = "Route-Feature-Zoom.";
                var bboxFilter = null,
                    timer,
                    timemsg;

                if (!routeFeatures) {

                    if (filter && !routeid) {
                        bboxFilter = filter;
                        routeid = filter.slice(2, 3); // ???? 
                    }

                    // A. Zoom to Rawfeatures
                    // SPECIAL
                    routeFeatures = this.trackRouteGetRawFeatures(routeid);

                    if (routeid) {
                        bboxFilter = ["in", "routeid", routeid];
                        timer = mba.timer.routes[routeid];
                        console.log("trackRoutesZoomTo: routeid=" + routeid, "VON " + this.logTime(timer.start, "h"), "BIS " + this.logTime(timer.stop, "h")); // , timer);
                    }

                    // B. Zoom to mapbox-features
                    if (!routeFeatures) {
                        console.log("trackRoutesZoomTo, applyFilter:", routeid, bboxFilter);
                        routeFeatures = this.map.querySourceFeatures("routes", {
                            filter: bboxFilter
                        });
                    }
                }

                if (!routeFeatures || !routeFeatures.length) {
                    console.log("BREAK. Route-Layer-Zoom. No features supplied!");
                    return;
                }

                // console.log(msg, routeFeatures); // .getCoordinates());

                mba.setFeatureBounds(routeFeatures, mba.map);
            },

            /**
             *  ??? 
             *
             */
            trackRouteGetRawFeatures: function(routeid) {
                var rrall = this.animationsources.routes.srcdata.features;
                if (!routeid || !rrall.length) {
                    console.log("NO Features queried for id=" + routeid);
                    return rrall;
                }
                var rr = [];
                rrall.forEach(function(r) {
                    if (r.id == routeid) {
                        rr.push(r);
                    }
                });
                // console.log("trackRouteGetRawFeatures. queried raw routeData for id=" + routeid, rr);
                return rr;
            },

            // Check if more starts before end of animated routeSet (timer.stop)
            getNextStart: function(mapTime) {
                var starts = mba.timer.starts,
                    nextStart;
                if (!starts) return;
                starts.some(function(start) {
                    if (mapTime < start) {
                        nextStart = start;
                        return true;
                    }
                });
                if (nextStart && (nextStart < mba.timer.stop)) { // console.log("t=", mapTime, "nextStart=" + nextStart, starts);
                    return nextStart;
                }
            },

            // updates "popupOnMap" if a trackinfo-property changes
            trackInfoPopup: function(trackinfo) {
                // console.log("LOG", trackinfo.value, trackinfo);
                if (!trackinfo.value) return;

                // trackinfo = trackinfo.value;
                this.popupOnMap(trackinfo.value);
            },


            /**
             * Activate a trackObject,  on mouse-over ;selected by gui-event e (mode-over, click, ...) 
             */
            trackObjSelect: function(e, clickflag) {
                // console.log("mousemove-event", e);
                var features = [];

                if (map.getLayer('tracks') || map.getLayer('tracks-select')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['tracks', 'tracks-select']
                    });
                }

                // Alternative for nodes
                if (!features.length) {
                    // Check waypoints/trackpoints    
                    if (map.getLayer('nodes')) {
                        features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes']
                        });
                    }
                    if (!features.length) return;

                    // popup-strategy 1: 
                    // Remove popup if pointer not on any feature
                    // this.popup.remove();
                    let wp = features[0];
                    if (this.wpid != wp.properties.id) {
                        this.wpid = wp.properties.id;
                        var msg = "WP/TP " + wp.properties.ab;
                        this.popupOnMap(msg); // console.log(msg, wp);
                    }
                    return;
                }

                // NO action if INFO already visible
                // 
                if (mba.trackid == features[0].properties.id) {
                    if (clickflag) {
                        console.log("clear trackObj", mba.trackid, features[0]);
                        mba.popup.remove();
                        mba.trackFilterApply("");
                        mba.trackobj = null;
                        mba.trackid = null;
                    }
                    return;
                } else if (1) {

                }
                // console.log("filtering new object", features[0]);

                // Update GLOBAL objects
                mba.trackobj = features[0];
                mba.trackid = mba.trackobj.properties.id;

                mba.trackFilterApply(mba.trackid);

                // Change the cursor style as a UI indicator.
                // map.getCanvas().style.cursor = 'pointer';

                // popup-strategy 2: 
                // Update and reconnect the this.popup to the map at new object
                mba.popup.remove();

                // Trackdata with "Override dirty checking" 
                if (mba.trackobj) {
                    mba.trackdata = {
                        "lnglat": mba.trackobj.geometry.coordinates,
                        "trackobj": mba.trackobj,
                        "open": true
                    }
                }

            },

            /*
             *   get wp-(tp-) info on CLICK-query
             */
            routeNodeSelect: function(e) {
                // Check waypoints(trackpoints)    
                if (map.getLayer('nodes')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['nodes']
                    });
                }
                if (!features.length) return;
                // popup-strategy 1: 
                // Remove popup if pointer not on any feature
                // this.popup.remove();
                let wp = features[0];
                if (this.wpid != wp.properties.id) {
                    this.wpid = wp.properties.id;
                    var msg = "WP/TP " + wp.properties.ab;
                    this.popupOnMap(msg); // console.log(msg, wp);
                }
                return;
            },

            // DEBUG-utilities
            _animationTimerRefresh: function(timer) {
                // console.log("checking timer", timer.value, timer);
            },
            _checkTrackdata: function(data) {
                //console.log("checking trackdata", data);
            },
            _checkTrackobj: function(trackobj) {
                // console.log("New TRACK obj", trackobj);
            },
            _checkTrackinfo: function(trackinfo) {
                // console.log("New TRACKinfo", trackinfo);
            }
        });
    </script>

</dom-module>