<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="mb-api.html">
<link rel="import" href="mb-routes-behavior.html">

<!--
`mb-routes`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="mb-routes">

    <template>
    
        <iron-ajax
            auto
            url="[[url]]"
            handle-as="json"
            on-response="dataToApp">
        </iron-ajax>
    
    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        /**
         * A waypoint along a tracked route
         */
        class Waypoint {
            /**
             * Constructs the object.
             *
             * @param      {array}   coordinates  The wp's coordinates as [lng,lat]-array
             * @param      {string}  id           The wp's identifier
             * @param      {string}  icon         The mapbox-icon name 
             */
            constructor(coordinates, id, routeid, icon) {
                if (!id) id = "wp";
                if (!icon) icon = "star";
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }
                this.id = id;
                this.properties = {
                    'routeid': routeid,
                    "title": id,
                    "icon": icon
                }
            };
        };

        /**
         * A route-segment between two waypoints
         */
        class Leg {
            /**
             * Constructs the object.
             *
             * @param      {array}  coordinates  The coordinates of the legs start/stop
             */

            constructor(coordinates) {
                this.type = "Feature";
                this.geometry = {
                    "type": "LineString",
                    "coordinates": coordinates
                }
                this.properties = {

                }
            }
        };

        /**
         * A mb-multi-object joining the animation points between multiple waypoints into a mb-geometry   
         */
        class Route {
            /**
             * Constructs the object.
             *
             * @param      {<type>}  coordinates  The coordinates
             * @param      {<type>}  data         The data
             * @param      {<type>}  wps          The wps
             */
            constructor(routeid, props, coordinates, legdata, wps) { // coordinates = array of coordinate-arrays (multiLine) 
                this.type = "Feature";
                this.geometry = {
                    "type": "MultiLineString",
                    "coordinates": coordinates
                };
                /**
                 * Metadata of route-componets 
                 */
                this.id = routeid;
                props.routeid = routeid;
                props.legs = legdata;
                props.wps = wps;
                this.properties = props;
            }
        };

        /**
         * A mapbox-point-feature ilustrationg the track on the map  
         */
        class Track {
            /**
             * Constructs the object.
             * @param      {array}  coordinates   The coordinates
             * @param      {string}  routeid      The identifier of route
             * @param      {string}  plane        The id(name) of the obj (fi plane-code)
             * @return     {mb-feature}  { mapbox point feature }
             */
            constructor(coordinates, routeid, props) {
                if (!props) props = {};
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                };
                this.id = routeid;
                props.id = routeid;
                props.bearing = 45;
                props.time = 0;
                props.speed = 0;
                this.properties = props;
            }
        };


        Polymer({

            is: 'mb-routes',

            properties: {

                /**
                 * Mapbox-js map to place routes on 
                 */
                map: {
                    type: Object
                },
                /**
                 * Basic Info-popup 
                 */
                popup: {
                    type: Object
                },

                /**
                 * Url to source of trackable routes/waypoints
                 */
                url: {
                    type: String
                },

                /**
                 * AnimationCtrlFlag
                 */
                trackctrl: {
                    type: Boolean,
                    notify: true
                },

                /**
                 * Toggles TrackingMap/NorthMap 
                 */
                trackmode: {
                    type: Boolean,
                    value: false,
                    notify: true
                },


                trackid: {
                    type: String,
                    value: ""
                },

                trackobj: {
                    type: Object,
                    notify: true
                },

                trackinfo: {
                    type: String
                },

                // internal variables

                /**
                 * Animation counter
                 */
                counter: {
                    type: Number
                },

                //
                requestframeref: {
                    type: String,
                    value: '1'
                },
                /**
                 * FramePerSecond of animation
                 */
                fps: {
                    type: Number,
                    value: 60
                },
                /**
                 * { item_description }
                 */
                timescale: {
                    type: Number,
                    value: 1080
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },

                // 
                routelayers: {
                    type: Object
                },

            },

            behaviors: [
                Polymer.RoutesBehavior
            ],

            observers: [
                'setupTracking(routedata, timescale)',
                'dataToMap(map, routelayers.*, routedata)',
                'ctrlTrackmove(trackctrl)',
                'ctrlTrackmode(trackmode, trackid, map)'
            ],

            attached: function() {

                /**
                 * quasiglobal context for animation 
                 */
                mba = this;

                this.trackFeaturesInit();

            },

            // A. 

            /**
             * Setup of animation framework from new track(wp)-dataset
             *
             * @param      {<type>}  routedata  Routedata as wp-dataset
             */
            dataToApp: function(ajaxresponse) {

                var routedata = ajaxresponse.detail.response;
                if (!routedata) return;
                this.routedata = routedata; // triggers 'setupTracking'
            },

            setupTracking: function(routedata, timescale) {
                console.log("ORIGINAL routedata:", routedata, " with timescale=" + timescale);

                this.counter = 0;
                this.trackTimer = this.setupTrackTimer(routedata, this.timescale);

                var routelayers = {};
                routelayers['waypoints'] = this.setupTrackWaypoints(routedata);
                routelayers['routes'] = this.setupTrackRoutes(routedata, this.trackTimer);
                routelayers['tracks'] = this.setupTrackObjects(routedata, this.trackTimer);
                // console.log("RouteAppData Ready", this.routelayers, this.routedata);

                // Double assignment to trigger multi-parameter observer 
                this.routelayers = {};
                this.routelayers = routelayers; // triggers "dataToMap""
            },

            /**
             * Insert (new) trackData into map-features
             *
             * @param      {object}  routedata     The routetrack-data
             * @param      {object}  layerObjects  The layerObjects to 
             * @param      {object}  map           The map to show routetracker
             */
            dataToMap: function(map, layerObjects, routedata) {
                if (layerObjects.path == 'routelayers') layerObjects = layerObjects.value;
                // console.log("Set Routes To Map: layerObjects, routedata, ", layerObjects, routedata);

                var layerObject, layerData, layerSourec, layer;

                // 1. Create/Refresh json-based layers (sources and layers)
                //    (of tracking-layers)     
                var layernames = Object.keys(layerObjects);
                layernames.forEach(function(lname, j) {
                    layerObject = layerObjects[lname];
                    layerData = layerObject['data'];

                    // 1.A. (Re)Set datasources
                    layerSource = map.getSource(lname);
                    if (!layerSource) {
                        map.addSource(lname, {
                            "type": "geojson",
                            "data": layerData
                        });
                    } else {
                        layerSource.setData(layerData);
                    }

                    // 1.B. Create layers 
                    if (!map.getLayer(lname)) {
                        map.addLayer(layerObject['layer']);
                    }
                });


                // 2. Prepare a "" Info-Popup
                if (!this.popup) {
                    this.popup = new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: false
                    });
                }

                // 3. Start-Zoom & trigger animation-start if no ctrls available 
                this.trackRoutesZoomTo(routedata);
                if (0) this.trackctrl = true;

                this.counter = 1;

                // 4. Query track-features in "mouseover" and show info-popup 
                map.on('mousemove', function(e) {
                    // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                    var features = [];
                    if (map.getLayer('tracks')) {
                        features = map.queryRenderedFeatures(e.point, {
                            layers: ['tracks']
                        });
                    }

                    if (!features || !features.length) {
                        // strategy 1: 
                        // Remove popup if pointer not on any feature
                        // this.popup.remove();
                        return;
                    }
                    // console.log("mousemove-event", e);

                    // Change the cursor style as a UI indicator.
                    map.getCanvas().style.cursor = 'pointer';

                    // strategy 2: 
                    // A. remove popup, if object selected (changes)
                    mba.popup.remove();

                    // B. Update and reconnect the this.popup to the map at new objectnew 
                    mba.trackobj = features[0];
                    mba.trackid = mba.trackobj.properties.id;

                    mba.trackinfo = mba.calcTrackInfo(mba.trackobj);

                    mba.popup
                        .setLngLat(mba.trackobj.geometry.coordinates)
                        .setHTML(mba.trackinfo)
                        .addTo(map);

                });

                // Update visible tracking content at different times  
                mba.syncTrackFilter(mba.trackTimer["start"], "FIRST START");

                // console.log("dataToMap OK!");
            },

            // B. TrackCtrls

            /**
             * { function_description }
             *
             * @param      {<type>}  trackctrl  The trackctrl
             */
            ctrlTrackmove: function(trackctrl) {
                // console.log("trackctrl", trackctrl)

                if (trackctrl) {

                    if (trackctrl == "reset") {
                        this.trackctrl = false; // triggers this function again 
                        this.trackmode = false;
                        this.counter = 0;
                        this.trackid = undefined; // z.B. popup.remove();
                        this.trackRoutesZoomTo();
                    } else {
                        this.requestframeref = requestAnimationFrame(this.trackStepContainer);
                        // this.trackctrl = false; // triggers this function again 
                    }

                } else {

                    if (this.counter) {
                        var trackObjs = [];
                        if (this.map) trackObjs = this.map.queryRenderedFeatures({
                            layers: ['tracks']
                        });
                        console.log("STOPPED animation at counter=" + this.counter + " with ", trackObjs);
                    }
                    cancelAnimationFrame(this.requestframeref);
                }

                // Reset 
                if (this.counter == 0) {
                    console.log("Reset tracking objects");
                    // Set the coordinates of the original point back to origin
                    this.setupTrackObjects(this.routedata, this.trackTimer);
                    this.setupTrackRoutes(this.routedata, this.trackTimer);

                    this.map.getSource('tracks').setData(this.tracks);
                    this.map.getSource('routes').setData(this.routes);
                }

            },

            /**
             * switch euler/lagrange
             */
            ctrlTrackmode: function(trackmode, trackid, map) {

                // No trackmode if no trackObj selected
                if (trackmode && !trackid) {
                    var msg = "<b>Object</b> must be activated to track!"
                    this.trackMapInfo(msg);

                    this.trackmode = false; // set to base 
                    return;
                }

                var zoom = map.getZoom();
                // zoom = Math.round(zoom); // may cause irritation

                if (trackmode) {
                    // this.trackctrl = false; // temporarily STOP ??
                    var trackobj = this.trackobj,
                        cc = trackobj.geometry.coordinates;

                    bearing = trackobj.properties.bearing;
                    console.log("Aligning map with bearing of", trackobj.properties.id);

                    if (zoom < 4) zoom = 4;
                    map.flyTo({
                        center: cc,
                        bearing: bearing,
                        zoom: zoom
                    });

                } else {

                    bearing = 0;
                    if (zoom > 4) zoom = 4;

                    map.easeTo({
                        bearing: bearing,
                        zoom: zoom
                            //speed: 0.2, // make the easeMove slower
                            //curve: 1,   // change the speed at which it changes zoom
                    });
                }

            },

            // C. TrackStep-Animation 

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {

                if (!mba.trackTimer) {
                    mba.trackMapInfo("OOPS. trackTimer n.a.");
                    return;
                }
                // console.log("trackStepContainer", mba.tracks);

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.
                var mapTime = (mba.trackTimer["start"]) + (mba.counter * mba.frameTime / 3600);

                var located = mba.trackStepAction(mba.counter, mapTime);

                // B. Transfer to map 

                if (!located) {
                    var msg = mba.logTime(mapTime * 3600 * 1000),
                        s = mba.getNextStart(mapTime);
                    if (s) {
                        msg = "NextStart at:" + mba.logTime(s * 3600 * 1000) + "<hr>" + msg;
                    } else {
                        msg = "IDLE: " + msg;
                    }
                    mba.trackMapInfo(msg);
                } else {
                    mba.map.getSource('tracks').setData(mba.tracks);
                }

                // C. Request the next frame of animation 

                mba.counter = mba.counter + 1;

                // D. Animation RECALL 

                if (mba.trackctrl) {
                    if (mba.fps && (mba.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                        setTimeout(function() {
                            mba.requestframeref = requestAnimationFrame(mba.trackStepContainer);
                        }, 1000 / mba.fps);
                    } else { // system-based Recall-frequency 
                        mba.requestframeref = requestAnimationFrame(mba.trackStepContainer);
                    }
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function ctrls 
                // - the visibility (using syncTrackFilter)  and  
                // - location of trackObjects 
                // at mapTime related to counter                
                if (!mapTime) mapTime = (mba.trackTimer["start"]) + (counter * mba.frameTime / 3600);

                var map = mba.map,
                    located = 0;

                // Show and animate those trackObjects 
                // whose start and stop imbed actual mapTime  
                mba.tracks.features.forEach(function(trackObj, j) {

                    // routes and tracks(Objs) are structured "in-sync" 
                    // referenced through the same index j  
                    var route = mba.routes.features[j];

                    var routeProps = route.properties,
                        routeid = routeProps.id,
                        legStartCounter = routeProps.startCounter;

                    // console.log(mapTime, routeprops);
                    if (mapTime > routeProps.stop) {

                        if (legStartCounter != null) { // must be valid for 0 too
                            routeProps.startCounter = null;
                            // console.log("STOP track on route:" + routeid, counter, mapTime, routeProps);
                            mba.syncTrackFilter(mapTime, "STOP:" + routeid);
                        }

                    } else if (mapTime >= routeProps.start) {

                        if (legStartCounter == undefined) {
                            legStartCounter = counter - 1;
                            routeProps.startCounter = legStartCounter;
                            // console.log("START track on route:" + routeid, legStartCounter, counter, mapTime, routeProps);
                            mba.syncTrackFilter(mapTime, "START:" + routeid);
                        }

                        var typ = route.geometry.type,
                            legSet = route.geometry.coordinates,
                            legdata = routeProps.legs,
                            wpdata = routeProps.wps;

                        if (typ == "MultiLineString") {
                            // legs = coords;
                        } else {
                            // one leg only 
                            legSet = [legSet];
                        }

                        // Checkout the routes leg the trackObj is located  
                        // at animation-step "counter", get legInfo and cc 
                        var legInfo, cc;

                        legSet.every(function(legPositions, i) {
                            // return true if xxx, false if xxx
                            if (counter < (legStartCounter + legPositions.length)) {
                                cc = legPositions[counter - legStartCounter];
                                if (cc) {
                                    legInfo = legdata[i];
                                    return false;
                                }
                            }
                            legStartCounter = legStartCounter + legPositions.length;
                            return true; // wichtig !!
                        })

                        // Update the trackObj-properties according to its location on the route
                        if (cc) {
                            // console.log("route:"+routeid, legStartCounter, counter,  mapTime, cc);

                            located += 1;

                            // A. 
                            trackObj.geometry.coordinates = cc;
                            //********************************

                            // B. Eval status between 2 animation-points 
                            if (trackObj.properties.lastPos) {
                                mba.trackStepStatus(trackObj, legInfo, mapTime);
                            }

                            // C. update content and location of the trackObj's info-popup
                            if (mba.trackid == trackObj.properties.id) {
                                // sync coordinates of trackobj
                                mba.trackobj.geometry.coordinates = cc;

                                mba.trackinfo = mba.calcTrackInfo(trackObj);

                                mba.popup.setHTML(mba.trackinfo); //console.log("popup", mba.popup, trackinfo, cc);

                                mba.popup.setLngLat(cc);

                                // in lagrange-mode the trackObj is conituously 
                                // centered on map and aligned to bearing  
                                if (mba.trackmode) {
                                    let map = mba.map;
                                    map.easeTo({
                                        center: cc,
                                        bearing: trackObj.properties.bearing,
                                    });
                                }

                                if (trackObj.properties.arrived) {
                                    mba.trackmode = false;
                                }
                            }

                            // D. 
                            trackObj.properties.lastPos = cc;
                        }
                    }
                });

                return located;
            },

            // Calc status-parameters at mapTime and save as properties
            trackStepStatus: function(trackObj, legInfo, mapTime) {
                // console.log(legInfo, trackObj);
                trackObj.properties.time = this.logTime(mapTime * 3600 * 1000);

                var cc = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos,
                    legTarget = legInfo.to;

                // calc last steps bearing (between plane and its 'lastPosition')
                var bearing = turf.bearing(new Track(lastPos), trackObj);
                if (bearing < 0) bearing = bearing + 360;

                var legToArrival = new Leg([cc, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers");

                var v = legInfo.speed;
                if (v && Math.round(dta / 10)) {
                    // Moving 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.bearing = Math.round(bearing); // Â°
                    trackObj.properties.speed = v; // km/h
                    trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    trackObj.properties.tta = tta;
                    trackObj.properties.arrived = null;

                } else {
                    // Resting
                    trackObj.properties.bearing = 0;
                    trackObj.properties.speed = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;
                    if (legTarget.ab) {
                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        let ttt = this.deltaT(legTarget.dep - mapTime, "TakeOff");
                        trackObj.properties.time = "Start - " + ttt;
                        trackObj.properties.arrived = "Stopover: " + stoptime;
                    } else {
                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },


            // D. SETUP elements ctrling and/or illustrating the tracking 

            /**
             * Compile the some timeflags of animated tracks
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timeScale  The timeScale of animation
             * @return     {Object}  Descriptor of timeCtrls
             */
            setupTrackTimer: function(routedata, timeScale) {
                if (!timeScale) timeScale = this.timescale;
                if (!timeScale) timeScale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                var fpsmax = 60; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                this.frameTime = timeScale / fpsmax; // Bsp: frameTime: 6 s fuer scale = 360 und fps=60 !!
                // console.log("timeScale=" + timeScale, ", frameTime=" + this.frameTime + "sec");

                var start, trackTimer = {};

                routedata.forEach(function(route, j) {
                    var starts = [],
                        stops = [];
                    route.waypoints.forEach(function(wp, p) {
                        if (wp.ab) starts.push(wp);
                        if (wp.an) stops.push(wp);
                    }.bind(this));
                    trackTimer[route.id] = [starts, stops];
                }.bind(this));
                // console.log("trackTimerRaw", trackTimer);

                Object.keys(trackTimer).forEach(function(id) {
                    var starts = trackTimer[id][0],
                        stops = trackTimer[id][1],
                        wpstart = starts[0],
                        wpstop = stops[stops.length - 1],
                        routestart = this.utcTime(wpstart.ab, wpstart.coords, "h"),
                        routestop = this.utcTime(wpstop.an, wpstop.coords, "h");
                    trackTimer[id] = {
                        "start": routestart,
                        "stop": routestop
                    };
                    if (!start || (routestart < start)) start = routestart;
                }.bind(this));

                // 
                var routeStarts = {},
                    startTimes = [];
                for (let id in trackTimer) {
                    let t = trackTimer[id]["start"];
                    if (!startTimes.length || (startTimes[0] <= t)) startTimes.push(t);
                    else startTimes.splice(0, 0, t);
                }

                trackTimer["start"] = start;
                trackTimer["startList"] = startTimes;
                trackTimer["timeScale"] = timeScale;
                trackTimer["frameTime"] = this.frameTime;

                console.log("APPLIED trackTimer:", trackTimer);

                return trackTimer;
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupTrackWaypoints: function(routedata) {

                this.waypoints.features = [];
                var allwaypoints = this.waypoints;

                routedata.forEach(function(route, j) {
                    // locate plane at 'origin'
                    // console.log("route-" + j, route.waypoints);

                    route.waypoints.forEach(function(wp, p) {
                        allwaypoints.features.push(new Waypoint(wp.coords, wp.id, route.id));
                    });
                });
                // console.log("all waypoints collected", allwaypoints.features);

                // 
                var wpLayer = {};

                wpLayer['data'] = allwaypoints;

                wpLayer['layer'] = {
                    "id": "waypoints",
                    "type": "symbol",
                    "source": "waypoints",
                    "layout": {
                        "icon-image": "{icon}-15",
                        //"icon-image": "harbor-15",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-offset": [0, -0.6]
                    }
                };
                return wpLayer;
            },

            /**
             * { function_description }
             *
             * @param      {number}  startcounter  The startcounter
             * @param      {<type>}  routedata     The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupTrackObjects: function(routedata, trackTimer, startcounter) {
                if (!startcounter) startcounter = 0;

                var trackLayer = {};

                // setup data 
                this.tracks.features = [];
                var allTracks = this.tracks,
                    props = {};

                routedata.forEach(function(route, j) {
                    // locate plane at 'origin'

                    props = {
                        "routeid": route.id,
                        "title": route.plane,
                        "start": trackTimer[route.id]["start"],
                        "stop": trackTimer[route.id]["stop"]
                    }
                    var aTrack = new Track(route.waypoints[startcounter].coords, route.id, props);

                    allTracks.features.push(aTrack);
                });

                trackLayer['data'] = allTracks;

                // setup styling
                trackLayer['layer'] = {
                    "id": "tracks",
                    "source": "tracks",
                    "type": "symbol",

                    "layout": {
                        "icon-image": "airport-15",
                        "icon-size": 2,
                        "icon-rotate": 90,
                        //"icon-image": "{icon}-15",
                        //"icon-rotate": "{bearing}",  
                        "text-field": "{routeid}",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 12,
                        "text-offset": [0, 0.6],
                        "text-anchor": "top"
                    }
                };

                return trackLayer;
            },

            /**
             * Setup routes for animation with "requestAnimationFrame (60 fps)"
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {number}  timeScale  The time scale
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupTrackRoutes: function(allroutedata, trackTimer) {

                this.routes.features = [];

                // Interpolate the Routes between waypoints 
                // based on info about speed and/or arrival-/departure-times at waypoints

                allroutedata.forEach(function(data, j) {
                    r = this.trackRouteCreate(data, trackTimer);
                    this.routes.features.push(r);
                }.bind(this));

                var routeLayer = {};

                routeLayer['data'] = this.routes;

                routeLayer['layer'] = {
                    "id": "routes",
                    "source": "routes",
                    "type": "line",
                    "paint": {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        "line-dasharray": [4, 4],
                        "line-color": "#007cbf"
                    }
                };
                return routeLayer;
            },

            //  
            trackRouteCreate: function(data, trackTimer, frameTime) {
                // Initialize 
                var demoSpeed = 900;
                if (!frameTime) frameTime = this.frameTime;

                var wpnext, legDistance, legStepCount;

                var routeid = data.id,
                    legdata = [], // mean props of every leg    
                    legs = [], // routepoints of every leg
                    legTimeSec, legStopSec,
                    legSpeed, routeSpeed = data.speed;

                if (!routeSpeed) routeSpeed = demoSpeed;

                var props = {
                    "id": routeid,
                    "start": trackTimer[routeid]["start"],
                    "stop": trackTimer[routeid]["stop"]
                }

                // Create route-legs between 2 waypoints at any one time 
                var waypoints = data.waypoints; // wps as given

                waypoints.forEach(function(wp, p) {

                    legStopSec = 0;
                    wpnext = waypoints[p + 1];
                    // Calculate leg-properties
                    if (wpnext) {
                        // console.log("waypoints:" + p, wp, wpnext);
                        // Calculate the distance in kilometers between waypoints
                        var leg = new Leg([wp.coords, wpnext.coords]),
                            legDistance = turf.lineDistance(leg, 'kilometers');
                        legDistance = Math.round(legDistance);
                        // console.log("Route-" + j + ", leg to", wpnext, legDistance); 

                        // Calculate a mean leg-speed between wp's with ab/an times
                        legSpeed = routeSpeed;
                        if (wpnext.an && wp.ab) {
                            let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                arv = mba.utcTime(wpnext.an, wpnext.coords, "h");
                            legSpeed = legDistance / (arv - dep);
                            wpnext.arv = arv;
                        } else if (wpnext.speed) {
                            legSpeed = wpnext.speed;
                        }
                        legSpeed = Math.round(legSpeed);
                        // console.log("leg-speed for dx=", legDistance, legSpeed);

                        // Calculate arv and dep at "stopover"
                        if (wpnext.an && wpnext.ab) {
                            let arv = mba.utcTime(wpnext.an, wpnext.coords, "h"),
                                dep = mba.utcTime(wpnext.ab, wpnext.coords, "h");
                            legStopSec = (dep - arv) * 3600;
                            wpnext.arv = arv;
                            wpnext.dep = dep;
                        } else if (wpnext.stopover) {
                            legStopSec = wpnext.stopover;
                        }

                        // 3. Calc leg-animation 

                        // Time and number of animation-steps to travel between waypoints in legTimeSec
                        legTimeSec = legDistance / legSpeed * 3600;
                        legStepCount = Math.round(legTimeSec / frameTime);

                        // Assign basic leg-properties
                        var legInfo = {};
                        legInfo.from = wp;
                        legInfo.to = wpnext;

                        legInfo.dist = legDistance;
                        legInfo.speed = legSpeed;

                        legInfo.time = legTimeSec;
                        legInfo.steps = legStepCount;

                        // Assign time-properties
                        var h = Math.floor(legTimeSec / 3600),
                            m = Math.round((legTimeSec - (h * 3600)) / 60);
                        legInfo.timetext = h + "h" + m + "min";

                        // Insert animation-positions along the leg
                        var startPosition = 0;
                        var legPositions = [];

                        for (let i = 0; i < legStepCount; i++) {
                            let dist = i * (legDistance / legStepCount);
                            let position = turf.along(leg, dist, 'kilometers');
                            // if (i == 10) console.log(i, dist, position);
                            legPositions.push(position.geometry.coordinates);
                        }

                        // 4. Calc stopover-animation 

                        if (legStopSec) {
                            // console.log("INSERT STOPover at ", wpnext, legStopSec);
                            // INSERT some "zero-steps" at stopover waypoint 
                            h = Math.floor(legStopSec / 3600);
                            m = Math.round((legStopSec - (h * 3600)) / 60);
                            legInfo.stopTime = h + "h" + m + "min";
                            var n = Math.round(legStopSec / frameTime);
                            legInfo.stopSteps = n;
                            // append the "stop-coordinates" to the leg 
                            for (let i = 0; i < n; i++) {
                                legPositions.push(legPositions[legPositions.length - 1]);
                            }
                        }

                        // 4. Compile leg-data in route-collections of legs  
                        legdata.push(legInfo);
                        legs.push(legPositions);
                    }

                });

                // Create route-object consisting of 1-n legs
                var r = new Route(routeid, props, legs, legdata, waypoints);

                return r;
            },



            // E. Additional Functions

            // 
            trackFeaturesInit: function() {
                this.routes = {
                    "type": "FeatureCollection"
                };
                this.waypoints = {
                    "type": "FeatureCollection"
                };
                this.tracks = {
                    "type": "FeatureCollection"
                };
            },

            // Zoom to all bbox of all waypoints
            trackRoutesZoomTo: function(routedata, routeid) {
                if (!routedata) routedata = this.routedata;

                // Collect waypoint-coordinates
                var coordinates = [],
                    bounds, center,
                    startmode = false; // routedata[0].waypoints[0].coords ];

                routedata.forEach(function(route, j) {
                    route.waypoints.forEach(function(wp, i) {
                        coordinates.push(wp.coords);
                        startmode = startmode || (wp.coords[0] > 150);
                    })
                });

                // Specialcase !!
                if (startmode) { // workaround for coords around dateline
                    center = coordinates[0];
                } else { // create bounds around all wp-coordinates
                    bounds = coordinates.reduce(function(bounds, coord) {
                            return bounds.extend(coord);
                        },
                        new mapboxgl.LngLatBounds(coordinates[0], coordinates[0])
                    );
                    center = bounds.getCenter();
                }
                // console.log("center, wp-coordinates", center, coordinates);

                if (bounds) map.fitBounds(bounds, {
                    padding: 20
                });
            },

            // Sync map-layers with TrackObjects "visible" at "mapTime"
            syncTrackFilter: function(mapTime, flag) {

                // apply startfilter "immediately"
                // but stopfilter "after some delay"
                // to let user observe arrived objects for 2 more seconds before removing the tracker and related features 
                var stopDelay = 200;

                // show trackObjects(and it's routes) only as long as they are tracked 
                if (!map.getLayer("tracks")) {
                    mba.trackMapInfo("<b>Nothing to track</b>" + " at " + evtTime);
                    return;
                }

                var startstopfilter = [
                    'all', ['<=', 'start', mapTime],
                    ['>=', 'stop', mapTime]
                ];

                var evtTime = this.logTime(mapTime * 3600 * 1000);

                function applyFilters() {
                    // PRIMARY FILTER of trackObjects  
                    // on MAP 
                    mba.map.setFilter('tracks', startstopfilter);
                    // on DATA
                    var trackObjs = this.map.querySourceFeatures("tracks", {
                        filter: startstopfilter
                    });

                    // Use SECONDARY FILTER 
                    // to Sync the MAP-filters for "related" layers (routes waypoints)  
                    if (!trackObjs.length) { // CHECK for STOP
                        if (!mba.getNextStart(mapTime)) {
                            mba.trackctrl = false;
                            mba.trackmode = false;
                            console.log(flag, evtTime, "No more starts");
                            mba.map.setFilter('routes', null);
                            mba.map.setFilter('waypoints', null);
                        }
                    } else { // APPLY 

                        var trackids = [],
                            routeids = [],
                            routeid;

                        // collect ROUTES of all actually "visible" trackObjs    
                        trackObjs.forEach(function(to) {
                            routeid = to.properties.routeid;
                            if (routeid) trackids.push(routeid);
                        });
                        // remove duplicates
                        routeids = trackids.filter(function(item, pos, self) {
                            return self.indexOf(item) == pos;
                        })

                        // Filter  related mapFeatures on MAP 
                        if (routeids.length) {
                            // BUILD secondary filter
                            var routeFilter = ["in", "routeid"]
                            routeids.forEach(function(id) {
                                routeFilter.push(id);
                            });
                            console.log("Refreshed SecondaryFilter", routeFilter);
                            mba.map.setFilter('routes', routeFilter);
                            mba.map.setFilter('waypoints', routeFilter);
                        } // console.log(flag, evtTime, trackObjs);
                    }

                    mba.trackMapInfo("<b>" + flag + "</b>" + " at " + evtTime);
                };

                if (flag.indexOf("STOP") < 0) {

                    applyFilters();

                } else {

                    setTimeout(function() {
                        applyFilters();
                    }, stopDelay);
                }

            },

            // Check if more starts 
            getNextStart: function(mapTime) {
                var starts = mba.trackTimer.startList,
                    nextStart;
                starts.some(function(start) {
                    if (mapTime < start) {
                        nextStart = start;
                        return false;
                    }
                }); //console.log(mapTime, "nextStart=" + nextStart, starts);
                return nextStart;
            },

            // Refresh the appInfo at map-center 
            trackMapInfo: function(html) {
                if (mba && mba.popup) { //  console.log("check popup", mba.popup)
                    mba.popup.remove;
                    mba.popup
                        .setLngLat(mba.map.getCenter())
                        .setHTML(html)
                        .addTo(mba.map);
                }
            }

        });
    </script>
</dom-module>