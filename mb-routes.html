<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="mb-api.html">

<link rel="import" href="mb-tools-behavior.html">
<!--<link rel="import" href="mb-behavior-info-vendee.html">-->

<!--
`mb-routes`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="mb-routes">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        // Templates for mapbox-layer-data
        //  - points, lines

        /**
         * A waypoint along a tracked route
         */
        class NodeSource {
            /**
             * Constructs the object.
             *
             * @param      {array}   coordinates  The wp's coordinates as [lng,lat]-array
             * @param      {string}  id           The wp's identifier on maps
             * @param      {string}  routeid      The wp's identifier
             * @param      {string}  props        Descriptive wp-properties
             */
            constructor(coordinates, id, routeid, props) {
                // if (!id) id = "wp";
                this.id = id;
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }

                if (!props) props = {};
                props.id = id;
                props.routeid = routeid;
                // props.title = id;
                if (!props.icon) props.icon = "dot-10";
                this.properties = props;
            };
        };

        /**
         * A route-segment between two nodes (way- or track-points)
         */
        class LegSource {
            /**
             * Constructs the object.
             *
             * @param      {array}  coordinates  The coordinates of the legs start/stop
             */
            constructor(coordinates) {
                this.type = "Feature";
                this.geometry = {
                    "type": "LineString",
                    "coordinates": coordinates
                }
                this.properties = {

                }
            }
        };

        /**
         * A mb-multi-object joining the animation points between multiple waypoints into a mb-geometry   
         */
        class RouteSource {
            /**
             * Constructs the object.
             *
             * @param      {<type>}  legsCoords   CoordinateSet
             * @param      {<type>}  legsData     The data
             * @param      {<type>}  nodes        Nodes or trackpoints
             */
            constructor(routeid, props, legsCoords, legsData, routeNodes) { // coordinates = array of coordinate-arrays (multiLine) 
                this.id = routeid;
                this.type = "Feature";
                this.geometry = {
                    "type": "MultiLineString",
                    "coordinates": legsCoords
                };

                /**
                 * Metadata of route-components 
                 */
                props.routeid = routeid;
                props.trackid = props.key;
                props.legs = legsData;
                props.nodes = routeNodes;

                // Compile all route-pnts into one list of coordinates, 
                // usable for trace-extraction
                /*var trace = [];
                legsCoords.forEach(function(coords) {
                    trace = trace.concat(coords);
                });
                props.trace = trace;*/

                this.properties = props;
                // console.log("ROUTE" + routeid, this.properties);
            }
        };

        /**
         * A mapbox-point-feature ilustrationg the track on the map  
         */
        class TrackSource {
            /**
             * Constructs the object.
             * @param      {array}  coordinates   The coordinates
             * @param      {string}  routeid      The identifier of route
             * @param      {string}  props        Some props
             * @return     {mb-feature}  { mapbox point feature }
             */
            constructor(coordinates, routeid, props) {
                this.id = routeid;
                this.type = "Feature";

                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                };

                // add variable properties
                if (!props) props = {};
                props.id = routeid;
                if (!props.unitsystem) props.unitsystem = "metric";
                if (!props.icon) props.icon = "circle-15";
                props.bearing = 0;
                props.time = 0;
                props.speed = 0;

                this.properties = props;
            }
        };

        /**
         * A route-trace 'behind' the animation-tracker
         */
        class TraceSource {
            /**
             * Constructs a line from the coordinatesets of all legs of a route
             * = list of points the tracker has passed 
             * alternatively "all" or "some only" (sich auflösender kondensstreifen)  
             *
             * @param      {array}  coordinates  The coordinates of the legs start/stop
             */

            constructor(coordinates, routeid, props) {
                this.id = routeid;
                this.type = "Feature";

                // coordinates = [coordinates]; // only  IF geometry.type=="MultiLineString"

                this.geometry = {
                    "type": "LineString",
                    "coordinates": coordinates
                }

                // add variable properties
                if (!props) props = {};
                props.id = routeid;
                props.routeid = routeid;

                this.properties = props;
            }
        };


        Polymer({
            is: 'mb-routes',

            properties: {
                /**
                 * Mapbox-js map to place routes on 
                 */
                map: {
                    type: Object
                },
                /**
                 * Basic Info-popup 
                 */
                popup: {
                    type: Object
                },
                /**
                 * Enhanced Info-popup 
                 */
                popupenhanced: {
                    type: Number
                },

                /**
                 * Url to source of trackable routes/waypoints
                 */
                url: {
                    type: String
                },

                /**
                 * AnimationCtrlFlag
                 */
                trackctrl: {
                    type: String,
                    notify: true
                },

                /**
                 * Toggles TrackingMap/NorthMap 
                 */
                trackmode: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                /**
                 * FramePerSecond of animation
                 */
                fps: {
                    type: Number,
                    value: 60
                },
                /**
                 * timescale of animation 
                 */
                timescale: {
                    type: Number,
                    value: 1080
                },


                trackid: {
                    type: String,
                    value: ""
                },

                timer: {
                    type: Object,
                    notify: true,
                },

                trackobj: {
                    type: Object,
                    observer: '_checkTrackobj'
                },

                tracksymbol: {
                    type: String,
                    value: "airport-15"
                },


                // for use in popups !!
                trackinfo: {
                    type: Object,
                    observer: '_checkTrackinfo'
                },


                /**
                 * make status of trackobj avilable to external services 
                 * processing the data for presentation u.ä.  
                 */
                trackdata: {
                    type: Object,
                    notify: true,
                    observer: '_checkTrackdata'
                },

                // INTERNAL variables

                /**
                 * Animation counter
                 */
                counter: {
                    type: Number
                },

                //
                requestframeref: {
                    type: String
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },

                // 
                animationSourceData: {
                    type: Object
                },

                /**
                 * default Icon used for wayPoint-mapping
                 */
                wpicon: {
                    value: "lighthouse"
                },
                /**
                 * default Symbol used for trackPoint-mapping
                 */
                trackicon: {
                    value: "harbor"
                },

            },

            behaviors: [
                Polymer.ToolsBehavior,
            ],

            observers: [
                '_animationTimerRefresh(timer.*)',
                '_animationDataSetup(routedata, timer.timescale)',
                '_animationLayersRefresh(map, animationSourceData.*)',
                'ctrlTrackmove(trackctrl)',
                'ctrlTrackmode(trackmode, trackid, map)',
                'getMapInfo(trackinfo.*)'
            ],

            /**
             * set 'quasiglobal' this-context for recursive calls during animation 
             * and setup track-features
             */
            attached: function() {

                // 1. setup global namespace 
                mba = this;

                // this.trackFeaturesInit();

                // 2. Prepare a "" Info-Popup
                if (!this.popup) {
                    this.popup = new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: false
                    });
                }
            },

            // DEBUG-utilities
            _animationTimerRefresh: function(timer) {
                // console.log("checking timer", timer.value, timer);
            },
            _checkTrackdata: function(data) {
                //console.log("checking trackdata", data);
            },
            _checkTrackobj: function(trackobj) {
                // console.log("New TRACK obj", trackobj);
            },
            _checkTrackinfo: function(trackinfo) {
                // console.log("New TRACKinfo", trackinfo);
            },

            // A. 
            // prepare all map- and animationdata required to view tracks on the map 
            //  - for altered routedata
            //  - if basic(=max) timescale of animation changed
            _animationDataSetup: function(routedata, timescale) {
                if (!routedata || !routedata[0] || !routedata[0].nodes) return;

                this.trackFeaturesInit();

                this.counter = 0;

                this.setupTrackTimer(routedata, timescale);
                console.log("ORIGINAL routedata:", routedata, " with timer=", this.timer);

                // Order(REIHENFOLGE) important, as wp-reduction in routedata possible during route-setup  

                // OLD 
                // var sourceData = {};
                // sourceData['routes'] = this.setupAnimationRoutes(routedata, this.timer); // console.log("checked route-data", routedata);
                // sourceData['traces'] = this.setupAnimationTraces(routedata, this.timer);
                // NEW                 
                sourceData = this.setupAnimationRoutes(routedata, this.timer); // console.log("checked route-data", routedata);

                sourceData['nodes'] = this.setupAnimationNodes(routedata); // wayPoints or trackPoints

                sourceData['tracks'] = this.setupAnimationTracker(routedata, this.timer);

                // console.log("AnimationData Ready", sourceData, routedata);

                // Doubled assignment of sourceData to trigger multi-parameter observer 
                this.animationSourceData = {};
                this.animationSourceData = sourceData; // triggers "refresh-action
            },

            /**
             * Insert (new) routing Data into map-features
             *
             * @param      {object}  routedata     The routetrack-data
             * @param      {object}  layerObjects  The layerObjects to 
             * @param      {object}  map           The map to show routetracker
             */
            _animationLayersRefresh: function(map, layerObjects) {
                var debounceTime = 200;

                this.debounce('tomap', function() {

                    if (layerObjects.path == 'animationSourceData') layerObjects = layerObjects.value;
                    if (!layerObjects || !Object.keys(layerObjects).length) return;

                    // console.log("SETTING RouteLayers inTo Map: ", layerObjects);
                    var layerObject, layerData, layerSource, layer;

                    // 1. Create/Refresh json-based layers (sources and layers)
                    //    (of tracking-layers)     
                    var layernames = Object.keys(layerObjects);
                    // console.log("refresh layers:", layernames);

                    layernames.forEach(function(layername, j) {

                        layerObject = layerObjects[layername];

                        if (layerObject && layerObject['data']) {
                            // console.log("addToMap:" + layername, layerObject);

                            layerData = layerObject['data'];

                            // 1.A. (Re)Set datasources
                            layerSource = map.getSource(layername);

                            if (!layerSource) {
                                map.addSource(layername, {
                                    "type": "geojson",
                                    "data": layerData
                                });
                                layerSource = map.getSource(layername);
                            } else {
                                layerSource.setData(layerData);
                            }

                            // 1.B. Create layers 
                            if (!map.getLayer(layername)) {
                                // console.log("Adding layer", layername, layerObject['layer'], map.getSource(layername));

                                var bl = layerObject['layer'];
                                var bgl = layerObject['bglayer'];
                                var sls = layerObject['selectlayer'];
                                // console.log("ADD layers of [" + layername + "]: src,bl,bgl,sls", layerSource, bl, bgl, sls);

                                // OPTIONAL: bglayer(s) of the same source
                                if (bgl) {
                                    // console.log("adding bg-layer of "+layername, bgl);
                                    // sls.forEach(function(sl) { // console.log("sl",sl);
                                    map.addLayer(bgl);
                                    // }
                                }

                                // BASIC layer
                                map.addLayer(bl);

                                // OPTIONAL: selectlayer of the same source
                                if (sls && sls.length) {
                                    sls.forEach(function(sl) { // console.log("sl",sl);
                                        map.addLayer(sl);
                                        map.setFilter(sl.id, ["==", "id", ""]);
                                    })
                                }
                            }

                            if (layername == "routes") {
                                mba.trackRoutesZoomTo(layerData.features);
                            }
                        }
                    });

                    // 3. Start-actions 

                    // Zoom auf RoutedData BBOX 
                    // this.trackRoutesZoomTo();

                    this.counter = 1;

                    // 4. Setup Events to query track-features on "mouseover" and show info-popup 

                    map.on('mousemove', function(e) {
                        // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                        mba.trackObjSelect(e);
                    });

                    map.on('click', function(e) {
                        // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                        mba.routeNodeSelect(e);
                    });

                    // Update visible tracking content at different times  
                    mba.syncMapElements(mba.timer["start"], "FIRST START");

                }, debounceTime);
                // console.log("Layers Refreshed: OK!");
            },

            // B. TrackCtrls

            /**
             * { function_description }
             *
             * @param      {<type>}  trackctrl  The trackctrl
             */
            ctrlTrackmove: function(trackctrl) {
                // console.log("trackctrlCheck:", trackctrl)

                if (trackctrl) {
                    // console.log("trackctrl", trackctrl, typeof trackctrl);

                    if (trackctrl == "reset") {
                        // 
                        this.trackctrl = false; // triggers this function again 
                        this.trackmode = false;
                        this.counter = 0;
                        this.trackid = undefined; // z.B. popup.remove();
                        this.trackRoutesZoomTo();

                    } else if (typeof trackctrl == "number") {
                        var mapTime = trackctrl;
                        if (this.trackStepAction(null, mapTime)) {
                            // console.log("manually set ctrltime[h]=", trackctrl)
                        };

                    } else {
                        this.trackStepAnimation("START");
                        //if (this.requestframeref) cancelAnimationFrame(this.requestframeref);
                        //this.requestframeref = requestAnimationFrame(this.trackStepContainer);
                        // this.trackctrl = false; // would trigger this function again 
                    }

                } else {

                    if (this.counter) {
                        var trackObjs = [];
                        // if (this.map) trackObjs = this.map.queryRenderedFeatures({
                        if (this.map) trackObjs = this.map.querySourceFeatures({
                            layers: ['tracks']
                        });
                        // console.log("STOPPED track at cnt=" + this.counter + " with objs", trackObjs);
                    }
                    // console.log("debug");
                    this.trackStepAnimation("STOP");
                }

                // Reset to START
                if (this.counter == 0) {

                    console.log("Reset tracking objects");

                    this.setupAnimationRoutes(this.routedata, this.timer);
                    // Set the coordinates of the tracker and traces back to origin
                    this.setupAnimationTracker(this.routedata, this.timer);
                    //this.setupAnimationTraces(this.routedata, this.timer);

                    this.map.getSource('routes').setData(this.routes);
                    this.map.getSource('tracks').setData(this.tracks);
                    this.map.getSource('traces').setData(this.traces);
                }

            },

            /**
             * switch euler/lagrange
             */
            ctrlTrackmode: function(trackmode, trackid, map) {

                // No trackmode if no trackObj selected
                if (trackmode && !trackid) {
                    var msg = "<b>Object</b> must be activated to track!"
                    this.trackMapInfo(msg);

                    this.trackmode = false; // set to base 
                    return;
                }

                var zoom = map.getZoom();
                // zoom = Math.round(zoom); // may cause irritation

                if (trackmode) {

                    var trackobj = this.trackobj,
                        cc = trackobj.geometry.coordinates;

                    bearing = trackobj.properties.bearing;
                    console.log("Aligning map with bearing of", trackobj.properties.id);

                    if (zoom < 4) zoom = 4;
                    map.flyTo({
                        center: cc,
                        bearing: bearing,
                        zoom: zoom
                    });

                } else {

                    bearing = 0;
                    if (zoom > 4) zoom = 4;

                    map.easeTo({
                        bearing: bearing,
                        zoom: zoom
                            //speed: 0.2, // make the easeMove slower
                            //curve: 1,   // change the speed at which it changes zoom
                    });
                }

            },

            // C. TrackStep-Animation 

            /**
             * 
             */
            trackStepAnimation: function(flag) {
                if (!mba) return;
                if (mba.requestframeref) cancelAnimationFrame(mba.requestframeref);

                if (flag == "STOP") {
                    console.log("CTRL " + flag, mba.requestframeref, "timer=", mba.timer);
                    return;
                }
                // console.log("CTRL "+flag, mba.requestframeref);
                let timer = mba.timer;
                if (timer.fps && (timer.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                    setTimeout(function() {
                        mba.requestframeref = requestAnimationFrame(mba.trackStepContainer);
                    }, 1000 / timer.fps);
                } else { // system-based Recall-frequency 
                    mba.requestframeref = requestAnimationFrame(mba.trackStepContainer);
                }
            },

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {
                var timer = mba.timer;
                if (!timer) {
                    mba.trackMapInfo("OOPS. TrackTimer n.a.");
                    mba.trackctrl = false;
                    return;
                }
                var tracks = mba.tracks;
                if (!tracks || !tracks.features) {
                    mba.trackMapInfo("OOPS. TrackData n.a.");
                    mba.trackctrl = false;
                    return;
                }

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.

                var mapTime = (timer["start"]) + (mba.counter * timer.frametime / 3600);

                // ******************************
                var located = mba.trackStepAction(mba.counter, mapTime);
                // ******************************

                // B. Transfer to map 

                if (!located) {
                    var msg = mba.logTime(mapTime * 3600 * 1000),
                        s = mba.getNextStart(mapTime);
                    if (s) {
                        msg = "NextStart at:" + mba.logTime(s * 3600 * 1000) + "<hr>" + msg;
                    } else {
                        msg = "IDLE: " + msg;
                    }
                    mba.trackMapInfo(msg);
                } else {
                    // mba.map.getSource('tracks').setData(mba.tracks);
                }

                // C. Request the next frame of animation 

                mba.counter = mba.counter + 1;

                // D. Animation RECALL 

                if (mba.trackctrl) {
                    mba.trackStepAnimation("CONT");
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function ctrls 
                // - the visibility (via syncMapElements-action)  and  
                // - the location of trackObjects 
                // at the mapTime related to "counter"     
                var timer = mba.timer,
                    map = mba.map,
                    located = 0;

                // A.0 Sync alternative timing sources 
                // 
                if (counter && !mapTime) {

                    mapTime = (timer["start"]) + (counter * timer.frametime / 3600);
                }

                if (!counter && mapTime) {

                    mba.syncMapElements(mapTime, "mapTIME");

                    // counter = (mapTime - timer["start"]) / (timer.frametime / 3600);
                    counter = (mapTime - timer["start"]) * 3600 / timer.frametime;
                    counter = Math.round(counter);
                    // console.log("mapTime=" + mapTime + ":", "cnt=" + counter);
                    mba.counter = counter;
                }

                // A.1 Timesignal for other elements 
                mba.set('timer.time', mapTime);
                // ****************************

                // A.2 Integrated RESET-function 
                if (counter == 0) {
                    mba.trackRoutesZoomTo();
                }

                // A.3 Optional trace-templates 
                var tracetemplates = {};
                if (timer.traces) tracetemplates = timer.traces;


                // B. RECALCULATE the srces of those trackObjects/trackTraces 
                //    whose start and stop imbed actual mapTime  
                mba.tracks.features.forEach(function(trackObj, j) {

                    // !!! routes and tracks(Objs) are structured "in-sync" 
                    // !!! referenced through the same index j  
                    var route = mba.routes.features[j],
                        trackTrace = mba.traces.features[j];

                    // 
                    var routeProps = route.properties,
                        routeid = routeProps.id,
                        legdata = routeProps.legs,
                        tracetemplate = tracetemplates[routeid];
                    // console.log(routeid, mapTime, routeProps);

                    var routeStartAt = routeProps.startCounter;

                    if (mapTime > routeProps.stop) { // A. BREAK after end

                        if (routeStartAt != null) { // must be valid for 0 too
                            routeProps.startCounter = null;

                            // NOPE 
                            // trackTrace.geometry.coordinates = [];

                            // console.log("STOP track on route:" + routeid, counter, mapTime, routeProps);
                            mba.syncMapElements(mapTime, "STOP:" + routeid);

                        }

                    } else if (mapTime >= routeProps.start) { // B.     

                        if (routeStartAt == undefined) { // 
                            // legStartAt = counter - 1;

                            mba.trackRoutesZoomTo();

                            routeStartAt = Math.round((routeProps.start - (timer["start"])) / (timer.frametime / 3600));

                            routeProps.startCounter = routeStartAt;
                            // console.log("START track on route:" + routeid, routeStartAt, counter, mapTime, routeProps);
                            mba.syncMapElements(mapTime, "START:" + routeid);
                        }

                        var legStartAt = routeStartAt;

                        var typ = route.geometry.type,
                            legCoordSet = route.geometry.coordinates;

                        if (typ == "MultiLineString") { // multiple legs
                        } else { // one leg only 
                            legCoordSet = [legCoordSet];
                        }

                        // Iterate along the route-legs until the track-counter is located within one. 
                        // Get legInfo and cc of the leg selected.

                        var legInfo, cc;

                        legCoordSet.every(function(legPositions, i) {
                            // return true if xxx, false if xxx

                            if (counter < (legStartAt + legPositions.length)) {
                                cc = legPositions[counter - legStartAt];
                                // *************************************
                                if (cc) {
                                    legInfo = legdata[i];
                                    return false;
                                }
                            }

                            legStartAt = legStartAt + legPositions.length;
                            return true; // wichtig !!
                        })

                        // Update the trackObj-properties according to its location on the route
                        if (cc) {
                            // console.log("route:"+routeid, legStartAt, counter,  mapTime, cc);
                            located += 1;

                            // A.1 MOVE the trackObject 
                            trackObj.geometry.coordinates = cc;

                            // A.2 EXTEND/MOVE the trackTrace 
                            if (tracetemplate) {
                                var startTime = timer.routes[routeid].start,
                                    traceCounter = Math.round((mapTime - startTime) / (timer.frametime / 3600)),
                                    first = traceCounter < 100 ? 0 : traceCounter - 100,
                                    last = traceCounter;
                                // console.log(routeid, counter, traceCounter, first, last);

                                var traceCoords = tracetemplate.slice(first, last);

                                trackTrace.geometry.coordinates = traceCoords;
                            }

                            // B. Eval STATUS between 2 animation-points 
                            if (trackObj.properties.lastPos) {
                                mba.trackStepStatus(trackObj, legInfo, mapTime);
                            }

                            // C. SYNC content (and location) of the info-popup 
                            //    if trackObj is selected as "tracked Object" 

                            if (mba.trackid == trackObj.properties.id) {

                                // REFRESH trackdata to trigger INFO-element(-popup) 
                                mba.trackdata = {
                                    "id": mba.trackid,
                                    "lnglat": cc,
                                    "trackobj": trackObj
                                }

                                // in track-align map-orientation 
                                // the map is continuously centered at trackObj 
                                // and the trackObj-symbol is aligned to bearing  
                                if (mba.trackmode) {
                                    let map = mba.map;
                                    map.easeTo({
                                        center: cc,
                                        bearing: trackObj.properties.bearing,
                                    });
                                    map.setLayoutProperty('tracks-select', 'icon-rotate', 0);
                                } else {
                                    // align selected tracksymbol along bearing
                                    map.setLayoutProperty('tracks-select', 'icon-rotate', trackObj.properties.bearing);
                                }

                                // 
                                if (trackObj.properties.arrived) {
                                    mba.trackmode = false;
                                }
                            } else {
                                // align all tracksymbols along its bearing
                                // requires filtering of the tracklayer-feature related to trackObj   
                                // map.setLayoutProperty('tracks', 'icon-rotate', trackObj.properties.bearing);
                            }

                            // D. 
                            trackObj.properties.lastPos = cc;
                        }
                    }
                });

                // C. APPLY the updated sources of the animation-layers
                // *********************************************
                mba.map.getSource('tracks').setData(mba.tracks);
                mba.map.getSource('traces').setData(mba.traces);
                // *********************************************
                return located;
            },

            // Calc status-parameters at mapTime and save as trackObj-properties
            trackStepStatus: function(trackObj, legInfo, mapTime) {

                var routeunitsystem = trackObj.properties.unitsystem;
                // console.log("trackStepStatus with " + routeunitsystem + " unitsystem from ", legInfo, trackObj);

                trackObj.properties.time = this.logTime(mapTime * 3600 * 1000);

                var cc = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos,
                    legTarget = legInfo.to;

                // calc the bearing between "actual" and 'last' Position of trackObj 
                var bearing = turf.bearing(new TrackSource(lastPos), trackObj);
                if (bearing < 0) bearing = bearing + 360;
                if (bearing > 360) bearing = bearing - 360;

                // temporary Leg to calculate DTA
                var legToArrival = new LegSource([cc, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers");

                var v = legInfo.speed,
                    dist = legInfo.dist;

                if (v && Math.round(dta / 10)) {
                    // Moving 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.tta = tta;
                    trackObj.properties.bearing = Math.round(bearing); // °
                    trackObj.properties.arrived = null;

                    if (routeunitsystem == "nautic") {
                        trackObj.properties.speed = Math.round(v / 1.856); // nds
                        trackObj.properties.dist = Math.round(dist / 1.856); // nm
                        trackObj.properties.dta = Math.round(dta / 1.856); // nm

                    } else if (routeunitsystem == "angloamerican") {
                        trackObj.properties.speed = Math.round(v / 1.609); // mph
                        trackObj.properties.dist = Math.round(dist / 1.609); // miles
                        trackObj.properties.dta = Math.round(dta / 1.609); // miles

                    } else {
                        trackObj.properties.speed = Math.round(v); // km/h
                        trackObj.properties.dist = Math.round(dist); // km
                        trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    }

                } else {
                    // Resting(pausing) objects 
                    if (!v) trackObj.properties.bearing = 0; // störend on track-animation
                    trackObj.properties.speed = 0;
                    trackObj.properties.dist = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;

                    if (legTarget.ab && (legTarget.ab != legTarget.an)) {
                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        let ttt = this.deltaT(legTarget.dep - mapTime, "TakeOff");
                        trackObj.properties.time = "Start - " + ttt;
                        trackObj.properties.arrived = "Stopover: " + stoptime;
                    } else {
                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },


            // D. SETUP elements ctrling and/or illustrating the tracking 

            // Initialisierung der animation-feature(collections)
            trackFeaturesInit: function() {
                var lnames = ["routes", "traces", "tracks", "nodes"];
                // console.log("trackFeaturesInit for objects:", lnames);
                lnames.forEach(function(lname) {
                    if (mba.map.getLayer(lname)) mba.map.removeLayer(lname);
                    if (mba.map.getLayer(lname + "-select")) mba.map.removeLayer(lname + "-select");
                    if (mba.map.getLayer(lname + "-glow")) mba.map.removeLayer(lname + "-glow");
                    if (mba.map.getLayer(lname + "-glow-strong")) mba.map.removeLayer(lname + "-glow-strong");
                    if (mba.map.getLayer(lname + "-bg")) mba.map.removeLayer(lname + "-bg");
                    if (mba.map.getSource(lname)) mba.map.removeSource(lname);

                    this[lname] = {
                        "type": "FeatureCollection"
                    };
                }.bind(this));

            },

            /**
             * Compile a timer from animated routes
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timescale  The timescale of animation
             * @return     {Object}  Collection of timeCtrls
             */
            setupTrackTimer: function(routedata, timescale) {

                if (!this.timer) this.timer = {};
                this.timer.routes = {};
                this.timer.traces = {};
                // var timer = this.timer ? this.timer : {};

                // A. Setup basic animation-parameters                
                var fpsmax = this.timer.fpsmax ? this.timer.fpsmax : 60; // Animationszeit 1s=6*60s=6min, 10s=1h Echtzeit 
                if (!timescale) timescale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                // B. Assemble all waypoint-times for every route 
                var wptimer = {};
                routedata.forEach(function(route, j) {
                    // console.log("route-" + j, route);
                    var starts = [],
                        stops = [];

                    route.nodes.forEach(function(wp, p) {
                        if (wp.ab) starts.push(wp);
                        if (wp.an) stops.push(wp);
                    }.bind(this));

                    // Collect 
                    wptimer[route.id] = {
                        "starts": starts,
                        "stops": stops
                    }; // [starts, stops, passes];

                }.bind(this));
                // console.log("setupTrackTimer. timer=", wptimer, routedata); // return;

                // C. Get start&stop times for every route and overall animation period  
                var start, stop;

                Object.keys(wptimer).forEach(function(id) {

                    var starts = wptimer[id]["starts"],
                        stops = wptimer[id]["stops"],
                        wpstart, wpstop, routestart, routestop;

                    if (starts.length) wpstart = starts[0];
                    if (stops.length) wpstop = stops[stops.length - 1];
                    else wpstop = starts[starts.length - 1];

                    routestart = this.utcTime(wpstart.ab, wpstart.coords, "h");
                    routestop = wpstop.an ? wpstop.an : wpstop.ab;
                    routestop = this.utcTime(routestop, wpstop.coords, "h");


                    this.timer.routes[id] = {
                        "start": routestart,
                        "stop": routestop
                    };

                    if (!start || (routestart < start)) start = routestart;
                    if (!stop || (routestop > stop)) stop = routestop;

                }.bind(this));
                // console.log("timer for waypoints:", wptimer, timer);

                this.timer["timescale"] = timescale;
                this.timer.frametime = timescale / fpsmax; // Bsp: frametime: 6 s fuer scale = 360 und fps=60 !!

                // ** SET explicitely to notify changes for data-binding 
                this.set("timer.start", start);
                this.set("timer.stop", stop);
                this.set("timer.time", start);

                // D. OPTION: Get a sorted sequence of start-times  
                var routeStarts = {},
                    startTimes = [],
                    routes = this.timer.routes;
                for (let key in routes) {
                    let t = routes[key]["start"];
                    if (t) {
                        if (!startTimes.length || (startTimes[0] <= t)) startTimes.push(t);
                        else startTimes.splice(0, 0, t);
                    }
                }
                this.timer["starts"] = startTimes;
                // console.log("Timer after setupTrackTimer:", this.timer);
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupAnimationNodes: function(routedata) {
                // console.log("setupAnimationNodes. srcdata:", routedata);
                this.nodes.features = [];
                var allnodes = this.nodes,
                    nodemetas = {},
                    id;

                routedata.forEach(function(route, j) {
                    // locate trackObj at 'origin'
                    // console.log("route-" + j, route.nodes);
                    route.nodes.forEach(function(wp, p) {
                        var key,
                            coords,
                            newNode,
                            props = {},
                            meta = wp.meta;

                        if (wp.id) key = wp.id;
                        else if (meta && meta.id) key = meta.id;
                        else key = p;

                        allnodes.features.forEach(function(nod) {
                            // do NOT add nodes multiple times (fi airports of different flights)
                            if ((key != p) && (nod.id == key)) {
                                // console.log("doubling routenode", key, route.id);
                                newNode = nod;
                            }
                        });

                        if (!newNode) {
                            if (wp.coords) coords = wp.coords;
                            else if (meta.coords) coords = meta.coords;
                            else key = p;

                            Object.keys(wp).forEach(function(k) {
                                if (k != "coords") props[k] = wp[k];
                            });

                            // console.log("wp-" + p, key, wp, props);
                            newNode = new NodeSource(coords, key, route.id, props);
                            if (wp.meta) {
                                newNode.properties = Object.assign({}, newNode.properties, wp.meta);
                                nodemetas[key] = wp.meta;
                            }

                            allnodes.features.push(newNode);
                        }
                    });

                });
                // console.log("all waypoints collected", allwaypoints.features);

                // Prepare ddr-styling (circle-size of symbol-bg)
                var nodesize = 2,
                    size, smin, smax;
                Object.keys(nodemetas).forEach(function(id) {
                    size = nodemetas[id].size;
                    if (size) {
                        if (!smin || (size < smin)) smin = size;
                        if (!smax || (size > smax)) smax = size;
                    }
                })

                if (smin && smax && (smin < smax)) {
                    nodesize = {
                        property: 'size',
                        stops: [
                            [smin, 4],
                            [smax, 12]
                        ]
                    }
                }

                // 
                var nodeLayer = {};

                nodeLayer['meta'] = nodemetas;

                nodeLayer['data'] = allnodes;

                nodeLayer['layer'] = {
                    "id": "nodes",
                    "type": "symbol",
                    "source": "nodes",
                    "layout": {
                        // "icon-image": "{icon}",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 10,
                        "text-offset": [0, 0.3]
                    },
                };
                // 
                nodeLayer['bglayer'] = {
                    "id": "nodes-bg",
                    "type": "circle",
                    "source": "nodes",
                    "paint": {
                        "circle-radius": nodesize,
                        "circle-opacity": 0.5,
                        "circle-color": "red",

                    }
                };
                //console.log("nodeLayer", nodeLayer);
                return nodeLayer;
            },

            /**
             * create the app-obj for trackLayer
             *
             * @param      {object}  routedata     The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupAnimationTracker: function(routedata, timer) {
                // console.log("routedata at setupAnimationTracker", routedata);
                // the trackLayerObj contains the data, the styling of the baseLayer AND the styling for the selectLayer
                var trackLayerObj = {};
                var tracksymbol = this.tracksymbol;
                if (!tracksymbol) tracksymbol = "airport-15";

                // setup data 
                this.tracks.features = [];
                var allTracks = this.tracks,
                    startort, trackmeta, props = {};

                routedata.forEach(function(route, j) {

                    // Basic properties 
                    trackmeta = route.item;
                    if (!trackmeta) trackmeta = route.master;
                    if (!trackmeta) trackmeta = {
                        "id": route.id
                    };

                    props = {
                        "routeid": route.id,
                        "id": trackmeta.id,
                        "title": trackmeta.id,
                        "unitsystem": route.unitsystem,
                        "bearing": 0,
                        "start": timer.routes[route.id]["start"],
                        "stop": timer.routes[route.id]["stop"]
                    };
                    // Optional: masterdata-properties
                    props["master"] = trackmeta;

                    // Required : icon; 
                    if (trackmeta.icon) props.icon = trackmeta.icon;
                    // Optional: 
                    if (trackmeta.iconsize) props.iconsize = trackmeta.iconsize;

                    // Create Tracker and locate at start 
                    startort = route.nodes[0].coords;

                    var aTrack = new TrackSource(startort, route.id, props);

                    allTracks.features.push(aTrack);

                });

                trackLayerObj['data'] = allTracks;

                // A. Setup ONE Layer for multiple features,
                // = trackers should use "ddr styling" 
                // A. Quick-Mode for Icon and text 
                // B. LUT-Mode for symbol-rotation 
                var symbolrotation = 0;
                //if (props.bearing) {
                symbolrotation = {
                        property: 'bearing',
                        stops: [
                            [0, 0],
                            [360, 360]
                        ]
                    }
                    //}

                trackLayerObj['layer'] = {

                    "id": "tracks",
                    "source": "tracks",
                    "type": "symbol",

                    "layout": {
                        "icon-image": "{icon}",
                        "icon-rotate": symbolrotation,
                        // a: "icon-rotate": {bearing},
                        // b. "icon-rotate": "{bearing}",
                        "text-field": "{title}",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 12,
                        "text-offset": [0, 0.6],
                        "text-anchor": "top"
                    }
                };

                // B. Setup MULTIPLE Layers to style the InfoTrackObj (app-specific)
                trackLayerObj['selectlayer'] =
                    // A meaningful Symbol built from 3 Layers 
                    [{
                        "id": "tracks-glow-strong",
                        "type": "circle",
                        "source": "tracks",
                        "paint": {
                            "circle-radius": 18,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.6
                        }
                    }, {
                        "id": "tracks-glow",
                        "type": "circle",
                        "source": "tracks",
                        "paint": {
                            "circle-radius": 40,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.2
                        }
                    }, {
                        "id": "tracks-select",
                        "type": "symbol",
                        "source": "tracks",
                        "layout": {
                            "icon-image": tracksymbol,
                            "icon-rotate": 0,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        }
                    }];

                // console.log("trackLayerObj", trackLayerObj);

                return trackLayerObj;
            },

            /**
             * Setup routes optimized for animation with "requestAnimationFrame (60 fps)"
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupAnimationRoutes: function(routeconfigdata, timer) {
                // console.log("setupAnimationRoutes, configdata:", routeconfigdata);

                this.routes.features = [];
                this.traces.features = [];
                var routemetas = {},
                    rr, r, t, m;

                // A. Interpolate the Routes between waypoints(trackpoints) 
                //    based on info about speed and/or arrival-/departure-times at waypoints
                routeconfigdata.forEach(function(routedata, j) {
                    // console.log("setupAnimationRoute:" + j, routedata);
                    // track-based routes should be preprocessed to minimie gps-noise 
                    if (routedata.trackmode) {
                        routedata = this.trackedDataCheck(routedata, timer);
                    }
                    // **************************
                    rr = this.animationRouteCreate(routedata, timer);
                    // **************************

                    if (rr) {
                        // console.log("route: " + r.id, r);
                        r = rr.routeSrc;
                        t = rr.traceSrc;
                        if (routedata.meta) {
                            m = Object.assign({}, r.properties, routedata.meta);
                            r.properties = m;
                            t.properties = m;
                            // 
                            routemetas[r.id] = routedata.meta;
                            // console.log("meta,r,t", routedata.meta, r, t);
                        }
                        this.routes.features.push(r);
                        this.traces.features.push(t);
                    }

                }.bind(this));
                // console.log("Srces:", this.routes.features, this.traces.features);
                // return;

                // B. STYLING: line-color 
                var linecolor = "#007cbf";
                // optional: ddr-styling based on routestyling
                if (Object.keys(routemetas).length) {
                    var ddrLinecolors = {
                        property: 'id',
                        type: 'categorical',
                        stops: []
                    };
                    Object.keys(routemetas).forEach(function(id) {
                        // 
                        var col = routemetas[id].color;
                        // if (!col) col = linecolor;
                        if (!col) col = this.getRandomColor();
                        ddrLinecolors.stops.push([id, col]);
                    })
                    linecolor = ddrLinecolors;
                }

                // C. FINALE Objekte
                var routeLayer = {};
                routeLayer['meta'] = routemetas;
                routeLayer['data'] = this.routes;
                routeLayer['layer'] = {
                    "id": "routes",
                    "source": "routes",
                    "type": "line",
                    "paint": {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        "line-dasharray": [4, 4],
                        "line-color": linecolor
                    }
                };

                var traceLayer = {};
                traceLayer['meta'] = routemetas;
                traceLayer['data'] = this.traces;
                traceLayer['layer'] = {
                    "id": "traces",
                    "source": "traces",
                    "type": "line",
                    "paint": {
                        "line-width": 2,
                        "line-opacity": 0.5,
                        "line-color": linecolor
                    }
                };
                // RETURN: 
                // console.log("ThemeObjs:", routeLayer, traceLayer);
                return {
                    "routes": routeLayer,
                    "traces": traceLayer
                };
            },

            // Conditional routecreate-action (If a route is based on "trackPoints")  
            trackedDataCheck: function(data, timer) {
                var trackpoints = [],
                    routeNodes = data.nodes, // waypoints/trackpoints 
                    frametime = timer.frametime,
                    deltaX = 10, // stdDev of device
                    legspeed, legTimeSec, wp, nextNode;
                // console.log("original trackpoints", routeNodes);
                var p = 0;
                while (p < routeNodes.length) {
                    // routeNodes.forEach(function(wp, p) {
                    wp = routeNodes[p];
                    i = 1;

                    while (i > 0) {

                        nextNode = routeNodes[p + i];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("routeNodes:" + p, wp, nextNode);
                            // A. Check 
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, wp.coords, "s"),
                                    arv = mba.utcTime(nextNode.an, nextNode.coords, "s");
                                legTimeSec = (arv - dep);
                            } else {
                                legTimeSec = wp.stopover;
                            }

                            // CHECK time-diff between wps
                            // ABANDON wp, if smaller then timeframe 
                            if (legTimeSec > frametime / 2) {

                                // B. Check DIST between routeNodes
                                //    ABANDON wp, if smaller then deltaX
                                var leg = new LegSource([wp.coords, nextNode.coords]),
                                    legDistance = turf.lineDistance(leg, 'kilometers'),
                                    legDistMeters = Math.round(legDistance * 1000);

                                if (legDistMeters > deltaX) {

                                    // Time and number of animation-steps to travel between routeNodes in legTimeSec
                                    // legTimeSec = legDistance / legSpeed * 3600;
                                    legStepCount = Math.round(legTimeSec / frametime);

                                    // console.log("leg-data ", "dx=" + legDistance, "dt=" + legTimeSec, "steps=" + legStepCount); // , frametime);
                                    // return;
                                    p = p + i;
                                    trackpoints.push(wp)
                                    i = 0;

                                } else {
                                    i = i + 1;
                                }

                            } else {
                                i = i + 1;
                            }

                        } else {
                            p = routeNodes.length;
                            i = 0;
                        }
                    }
                }

                if (nextNode) trackpoints.push(nextNode);
                // console.log("checked trackpoints", trackpoints);
                data.nodes = trackpoints;
                return data;
            },

            /** Basic routeCreate-action   
             * 
             * compile coords of all route-legs into one coordinatecollection 
             */
            animationRouteCreate: function(data, timer) {
                // console.log("Initialize route from", data, timer);

                var demoSpeed = 900;
                var frametime = timer.frametime;

                var nextNode, legDistance, legStepCount;

                var routeid = data.id,
                    legsData = [], // mean props of every leg    
                    legsCoords = [], // coords of every leg
                    legTimeSec, legStopSec,
                    legSpeed, routeSpeed = data.speed;

                if (!routeSpeed) routeSpeed = demoSpeed;

                var props = {
                    "id": routeid,
                    "speed": routeSpeed,
                    "start": timer.routes[routeid]["start"],
                    "stop": timer.routes[routeid]["stop"]
                };
                // console.log("Initialize route from", data, timer, props);

                // Create route-legs between 2 waypoints at any one time 
                var routeNodes = data.nodes; // wps as given

                routeNodes.forEach(function(wp, p) {

                    legStopSec = 0;
                    nextNode = routeNodes[p + 1];
                    // Calculate leg-properties
                    if (nextNode) {
                        // console.log("waypoints:" + p, wp, nextNode);
                        // Calculate the distance in kilometers between waypoints
                        var leg = new LegSource([wp.coords, nextNode.coords]),
                            legDistance = turf.lineDistance(leg, 'kilometers');

                        // legDistance = Math.round(legDistance);

                        // Calculate a mean leg-speed between wp's with ab/an times
                        legSpeed = routeSpeed;
                        if (nextNode.an && wp.ab) {
                            let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                arv = mba.utcTime(nextNode.an, nextNode.coords, "h");
                            legSpeed = legDistance / (arv - dep);
                            nextNode.arv = arv;
                        } else if (nextNode.speed) {
                            legSpeed = nextNode.speed;
                        }
                        // legSpeed = Math.round(legSpeed);
                        //console.log("leg-speed-calc", legDistance, legSpeed, nextNode, wp);

                        // Calculate arv and dep at "stopover"
                        if (nextNode.an && nextNode.ab) {
                            let arv = mba.utcTime(nextNode.an, nextNode.coords, "h"),
                                dep = mba.utcTime(nextNode.ab, nextNode.coords, "h");
                            legStopSec = (dep - arv) * 3600;
                            nextNode.arv = arv;
                            nextNode.dep = dep;
                        } else if (nextNode.stopover) {
                            legStopSec = nextNode.stopover;
                        }
                        // 3. Calc leg-animation 

                        // Time and number of animation-steps to travel between waypoints in legTimeSec
                        legTimeSec = legDistance / legSpeed * 3600;
                        legStepCount = Math.round(legTimeSec / frametime);

                        // console.log(p + ". leg-data for dx=" + legDistance, "n=" + legStepCount);

                        // Assign basic leg-properties
                        var legInfo = {};
                        legInfo.from = wp;
                        legInfo.to = nextNode;

                        legInfo.dist = legDistance;
                        legInfo.speed = legSpeed;

                        legInfo.time = legTimeSec;
                        legInfo.steps = legStepCount;

                        // Assign time-properties
                        var h = Math.floor(legTimeSec / 3600),
                            m = Math.round((legTimeSec - (h * 3600)) / 60);
                        legInfo.timetext = h + "h" + m + "min";

                        // Insert animation-positions along the leg
                        var startPosition = 0;
                        var legPositions = [];

                        for (let i = 0; i < legStepCount; i++) {
                            let dist = i * (legDistance / legStepCount);
                            let position = turf.along(leg, dist, 'kilometers');
                            legPositions.push(position.geometry.coordinates);
                        }

                        // 4. Append "STOPOVER-animation" 
                        //    into 
                        if (legStopSec) { // INSERT some "zero-steps" at stopover waypoint 
                            // console.log("INSERT STOPover at ", nextNode, legStopSec);
                            h = Math.floor(legStopSec / 3600);
                            m = Math.round((legStopSec - (h * 3600)) / 60);
                            legInfo.stopTime = h + "h" + m + "min";
                            var n = Math.round(legStopSec / frametime);
                            legInfo.stopSteps = n;
                            // append the "stop-coordinates" to the leg 
                            for (let i = 0; i < n; i++) {
                                legPositions.push(legPositions[legPositions.length - 1]);
                            }
                        }

                        // 4. Compile leg-data in route-collections of legs  
                        // console.log("leg-data ", legInfo, legPositions);
                        legsData.push(legInfo);
                        legsCoords.push(legPositions);
                    }
                });

                // A. Create route-object consisting of 1-n legs
                var rSrc = new RouteSource(routeid, props, legsCoords, legsData, routeNodes);

                // B. Save the complete trace of a route as template for dynamic traces 
                var coordinates = [];
                legsCoords.forEach(function(legcoords) {
                    coordinates = coordinates.concat(legcoords);
                });
                timer.traces[routeid] = coordinates;

                // Create "complete" trace-object with startpoint only
                // var tSrc = new TraceSource(coordinates, routeid);
                // Create "initial" trace-object with startpoint only
                var tSrc = new TraceSource(coordinates.slice(0, 1), routeid);

                // console.log("New routeSrces: " + routeid, rSrc, tSrc);
                return {
                    "routeSrc": rSrc,
                    "traceSrc": tSrc
                };
            },

            // E. Additional Functions
            // Sync visibility at "mapTime"
            // of TrackObjects and map-layers 
            syncMapElements: function(mapTime, syncflag) {
                var stopDelay = 2000, // time to let last situation "visible" before reset 
                    trackids;

                // BASE filter: applied, on every maptime ??
                function applyTrackFilter(mapTime, flag) {

                    var routeids = [];
                    // A. Apply PRIMARY FILTER for "ALL trackObjects on MAP" 
                    //    (is applied on sourcedata)

                    var startstopfilter = [
                        'all', ['<=', 'start', mapTime],
                        ['>=', 'stop', mapTime]
                    ];

                    mba.map.setFilter('tracks', startstopfilter);

                    var trackObjs = this.map.querySourceFeatures("tracks", {
                        filter: startstopfilter
                    });

                    // B. Check trackObjs remaining after filter was applied 
                    //    and stop animation, if no further track-Start is pendig 
                    if (!trackObjs.length) { // CHECK for STOP
                        if (!mba.getNextStart(mapTime)) {
                            mba.trackctrl = false;
                            mba.trackmode = false;
                            var msgTime = mba.logTime(mapTime * 3600 * 1000),
                                msg = "STOPPED. No more data after: " + msgTime; // console.log(msg);
                            mba.trackMapInfo(msg);
                            return;
                        }
                    } else if (flag.indexOf('TIME') >= 0) {
                        // console.log("trackObjs filtered at ", msgTime, trackObjs, startstopfilter);
                    }

                    // C. Apply SECONDARY FILTER 
                    //    to Sync the MAP-filters for "related" layers (traces, routes, waypoints)  

                    var trackids = [],
                        routeid;

                    // collect ROUTES of all actually "active" trackObjs    
                    trackObjs.forEach(function(to) {
                        routeid = to.properties.routeid;
                        if (routeid) routeids.push(routeid);
                    });

                    // remove possible "duplicates" ? 
                    routeids = routeids.filter(function(item, pos, self) {
                        return self.indexOf(item) == pos;
                    })

                    var msgTime = mba.logTime(mapTime * 3600 * 1000, "_");
                    mba.trackMapInfo("<b>" + flag + "</b>" + "<br> at " + msgTime + "<br>" + routeids.length + " track(s) active");

                    return routeids;
                };

                // SYNC filter:
                function applySyncFilter(routeids) {
                    // Filter  mapFeatures "related"  to animating trackers or none or all 

                    var syncFilter = ["in", "routeid"];

                    if (typeof routeids == "string") { // select none  
                        syncFilter.push(routeids);
                    } else if (!routeids || !routeids.length) { // select all
                        syncFilter = null;
                    } else {
                        // syncFilter = syncFilter.concat(routeids);
                        routeids.forEach(function(id) {
                            syncFilter.push(id);
                        });
                    }
                    // console.log("Refreshed SYNC-Filter", syncFilter);

                    if (mba.map.getLayer("routes")) {

                        mba.map.setFilter('routes', syncFilter);
                        var routeFeatures = this.map.querySourceFeatures("routes", {
                            filter: syncFilter
                        });
                        // console.log("SYNCED Route-Layer", JSON.stringify(routeFeatures, null, 2), mba.map.getLayer("routes"), mba.map.getSource("routes"));

                        var bb = mba.featureBounds(routeFeatures);
                        if (bb) {
                            // console.log("Zoomed to Route-Layer synced with tracks", routeids, bb);
                            mba.map.fitBounds(bb, {
                                padding: 20
                            });
                        }
                    }

                    if (mba.map.getLayer("nodes")) {
                        mba.map.setFilter('nodes', syncFilter);
                        mba.map.setFilter('nodes-bg', syncFilter);
                    }

                    if (mba.map.getLayer("traces")) {
                        let traceFilter = syncFilter;
                        mba.map.setFilter('traces', traceFilter);
                        var traceFeatures = this.map.querySourceFeatures("traces", {
                            filter: traceFilter
                        });
                        // console.log("SYNCED Trace-Layer", JSON.stringify(traceFeatures, null, 2), mba.map.getLayer("traces"), mba.map.getSource("traces"));
                    }
                };

                // Always apply syncfilter "immediately"
                // BUT "stopfilter" after some "stopDelay"
                // to let user observe arrived tracker during this delay before removing the tracker and related features 

                // 1. Optional BREAK! 
                // Sync trackObjects(and it's routes) only as long as they are tracked 
                if (!mba.map.getLayer("tracks")) {
                    var syncTime = this.logTime(mapTime * 3600 * 1000);
                    mba.trackMapInfo("<b>No trackers on map to track</b>" + " at " + syncTime);
                    return;
                }

                // 2. STOP-action with HIDE-Filters
                if (syncflag.indexOf("STOP") >= 0) {
                    // A. Set HIDE-filters for last SELECT-Track
                    mba.map.setFilter("tracks-select", ["==", "id", ""]);
                    mba.map.setFilter("tracks-glow", ["==", "id", ""]);
                    mba.map.setFilter("tracks-glow-strong", ["==", "id", ""]);
                    // B. Apply Filters on 
                    setTimeout(function() {
                        trackids = applyTrackFilter(mapTime, syncflag);
                        applySyncFilter(trackids);
                    }, stopDelay);
                    return;
                }

                // 3. Apply filter for All other flags but STOP 
                trackids = applyTrackFilter(mapTime, syncflag);

                applySyncFilter(trackids);
                // **********************
            },

            // Zoom to bbox of all raw route-nodes (waypoints, trackpoints) 
            // 
            trackRoutesZoomTo: function(routeFeatures, routeid) {
                if (!routeFeatures) {
                    console.log("queryAll");
                    var bboxfilter = null; // ""; // null
                    routeFeatures = this.map.querySourceFeatures("routes", {
                        filter: bboxfilter
                    });
                    routeFeatures = map.queryRenderedFeatures({
                        layers: ['routes']
                    });
                } else {

                }
                console.log("Route-Layer-Zoom. features", routeFeatures.length, routeFeatures); // , mba.map.getSource("routes").getCoordinates());
                if (!routeFeatures || !routeFeatures.length) return;

                var bb = mba.featureBounds(routeFeatures);
                if (bb) {
                    console.log("Zooming to Route-Layer", bb);
                    mba.map.fitBounds(bb, {
                        padding: 20
                    });
                }
            },

            // Zoom to bbox of all nodes in raw routedata (waypoints, trackpoints) 
            trackNodesZoomTo: function(routedata, routeid) {
                if (!routedata) routedata = this.routedata;

                // Collect routenode-coordinates
                var coordinates = [],
                    coords_datum = [],
                    neast = 0,
                    nwest = 0,
                    lmin, lmax, dl, bounds, center,
                    startmode = false;

                // "NOT-Heuristic" zum Problem Datumsgrenze
                // a.  
                routedata.forEach(function(route, j) {
                    if (route.nodes) {
                        route.nodes.forEach(function(wp, i) {
                            var lng = wp.coords[0];
                            nwest = lng < 0 ? nwest + 1 : nwest;
                            neast = lng > 0 ? neast + 1 : neast;
                            if (!lmin) {
                                lmin = lng;
                                lmax = lng;
                            }
                            lmin = lng < lmin ? lng : lmin;
                            lmax = lng > lmax ? lng : lmax;
                        })
                    }
                });
                if (!lmax && !lmin) return;

                // b. 
                dl = lmax - lmin;
                // console.log("delta-lng=" + dl, "nwest=" + nwest, "neast=" + neast);
                routedata.forEach(function(route, j) {
                    route.nodes.forEach(function(wp, i) {
                        var lng = wp.coords[0];
                        if (dl < 180) coordinates.push(wp.coords);
                        else if ((lng < 0) && (nwest > neast)) coordinates.push(wp.coords);
                        else if ((lng > 0) && (neast > nwest)) coordinates.push(wp.coords);
                    })
                });

                // Specialcase !!
                if (startmode) { // workaround for coords around dateline
                    center = coordinates[0];
                } else { // create bounds around all wp-coordinates
                    // startvalue 
                    bounds = new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]);
                    // collect all 
                    bounds = coordinates.reduce(function(bounds, coord) {
                        return bounds.extend(coord);
                    }, bounds);

                    center = bounds.getCenter();
                }
                // console.log("center, wp-coordinates", center, coordinates);

                if (bounds) map.fitBounds(bounds, {
                    padding: 20
                });

            },

            // Check if more starts 
            getNextStart: function(mapTime) {
                var starts = mba.timer.starts,
                    nextStart;
                if (!starts) return;
                starts.some(function(start) {
                    if (mapTime < start) {
                        nextStart = start;
                        return false;
                    }
                }); //console.log(mapTime, "nextStart=" + nextStart, starts);
                return nextStart;
            },

            getMapInfo: function(trackinfo) {
                if (!trackinfo.value) return;

                trackinfo = trackinfo.value;
                this.trackMapInfo(trackinfo);
            },

            // Refresh the appInfo at map-center 
            trackMapInfo: function(trackinfo) {
                var lnglat;

                if (typeof trackinfo == "object") {
                    html = trackinfo.html;
                    lnglat = trackinfo.lnglat;
                } else {
                    html = trackinfo;
                }

                if (mba && mba.map) { //  console.log("check popup", mba.popup)
                    if (!lnglat) lnglat = mba.map.getCenter();
                    if (mba.popup) mba.popup.remove;
                    mba.popup
                        .setLngLat(lnglat)
                        .setHTML(html)
                        .addTo(mba.map);
                }
            },

            /**
             * Activate a trackObject,  on mouse-over ;selected by gui-event e (mode-over, click, ...) 
             */
            trackObjSelect: function(e) {
                // console.log("mousemove-event", e);
                var features = [];

                if (map.getLayer('tracks') || map.getLayer('tracks-select')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['tracks', 'tracks-select']
                    });
                }

                if (!features || !features.length) return;

                if (!features.length) {
                    // Check waypoints(trackpoints)    
                    if (map.getLayer('nodes')) {
                        features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes']
                        });
                    }
                    // popup-strategy 1: 
                    // Remove popup if pointer not on any feature
                    // this.popup.remove();
                    let wp = features[0];
                    if (this.wpid != wp.properties.id) {
                        this.wpid = wp.properties.id;
                        var msg = "WP/TP " + wp.properties.ab;
                        this.trackMapInfo(msg); // console.log(msg, wp);
                    }
                    return;
                }

                // NO action if INFO already visible
                if (mba.trackid == features[0].properties.id) {
                    return;
                }

                // 
                mba.trackobj = features[0];
                mba.trackid = mba.trackobj.properties.id;

                map.setFilter("tracks-select", ["==", "id", mba.trackid]);
                map.setFilter("tracks-glow", ["==", "id", mba.trackid]);
                map.setFilter("tracks-glow-strong", ["==", "id", mba.trackid]);

                // Change the cursor style as a UI indicator.
                // map.getCanvas().style.cursor = 'pointer';

                // popup-strategy 2: 
                // Update and reconnect the this.popup to the map at new object
                mba.popup.remove();

                // Trackdata with "Override dirty checking" 

                if (mba.trackobj) {
                    mba.trackdata = {
                        "lnglat": mba.trackobj.geometry.coordinates,
                        "trackobj": mba.trackobj,
                        "open": true
                    }
                }

            },

            /*
             *   get wp-(tp-) info on CLICK-query
             */
            routeNodeSelect: function(e) {
                // Check waypoints(trackpoints)    
                if (map.getLayer('nodes')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['nodes']
                    });
                }
                if (!features.length) return;
                // popup-strategy 1: 
                // Remove popup if pointer not on any feature
                // this.popup.remove();
                let wp = features[0];
                if (this.wpid != wp.properties.id) {
                    this.wpid = wp.properties.id;
                    var msg = "WP/TP " + wp.properties.ab;
                    this.trackMapInfo(msg); // console.log(msg, wp);
                }
                return;
            }

        });
    </script>
</dom-module>