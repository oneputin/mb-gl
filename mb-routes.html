<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="mb-api.html">

<link rel="import" href="mb-behavior-routes.html">
<link rel="import" href="mb-behavior-info-vendee.html">

<!--
`mb-routes`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="mb-routes">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        /**
         * A waypoint along a tracked route
         */
        class Waypoint {
            /**
             * Constructs the object.
             *
             * @param      {array}   coordinates  The wp's coordinates as [lng,lat]-array
             * @param      {string}  id           The wp's identifier on maps
             * @param      {string}  routeid      The wp's identifier
             * @param      {string}  icon         The mapbox-icon name 
             */
            constructor(coordinates, id, routeid, icon) {
                // if (!id) id = "wp";
                if (!icon) icon = "star";
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }
                this.id = id;

                this.properties = {
                    'routeid': routeid,
                    "title": id,
                    "icon": icon
                }
            };
        };

        /**
         * A route-segment between two waypoints
         */
        class Leg {
            /**
             * Constructs the object.
             *
             * @param      {array}  coordinates  The coordinates of the legs start/stop
             */

            constructor(coordinates) {
                this.type = "Feature";
                this.geometry = {
                    "type": "LineString",
                    "coordinates": coordinates
                }
                this.properties = {

                }
            }
        };

        /**
         * A mb-multi-object joining the animation points between multiple waypoints into a mb-geometry   
         */
        class Route {
            /**
             * Constructs the object.
             *
             * @param      {<type>}  coordinates  The coordinates
             * @param      {<type>}  data         The data
             * @param      {<type>}  wps          The wps
             */
            constructor(routeid, props, coordinates, legdata, wps) { // coordinates = array of coordinate-arrays (multiLine) 
                this.type = "Feature";
                this.geometry = {
                    "type": "MultiLineString",
                    "coordinates": coordinates
                };
                /**
                 * Metadata of route-componets 
                 */
                this.id = routeid;
                props.routeid = routeid;
                props.trackid = props.key;
                props.legs = legdata;
                props.wps = wps;
                this.properties = props;
            }
        };

        /**
         * A mapbox-point-feature ilustrationg the track on the map  
         */
        class Track {
            /**
             * Constructs the object.
             * @param      {array}  coordinates   The coordinates
             * @param      {string}  routeid      The identifier of route
             * @param      {string}  props        Some props
             * @return     {mb-feature}  { mapbox point feature }
             */
            constructor(coordinates, routeid, props) {
                this.id = routeid;
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                };

                // variable properties
                if (!props) props = {};
                props.id = routeid;
                props.bearing = 45;
                props.time = 0;
                props.speed = 0;
                this.properties = props;
            }
        };


        Polymer({
            is: 'mb-routes',
            properties: {
                /**
                 * Mapbox-js map to place routes on 
                 */
                map: {
                    type: Object
                },
                /**
                 * Basic Info-popup 
                 */
                popup: {
                    type: Object
                },
                /**
                 * Enhanced Info-popup 
                 */
                popupenhanced: {
                    type: Number
                },

                /**
                 * Url to source of trackable routes/waypoints
                 */
                url: {
                    type: String
                },

                /**
                 * AnimationCtrlFlag
                 */
                trackctrl: {
                    type: Boolean,
                    notify: true
                },

                /**
                 * Toggles TrackingMap/NorthMap 
                 */
                trackmode: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                /**
                 * FramePerSecond of animation
                 */
                fps: {
                    type: Number,
                    value: 60
                },
                /**
                 * timescale of animation 
                 */
                timescale: {
                    type: Number,
                    value: 1080
                },


                trackid: {
                    type: String,
                    value: ""
                },

                timer: {
                    type: Object,
                    notify: true,
                    observer: '_checkTracktimer'
                },

                trackobj: {
                    type: Object,
                    observer: '_checkTrackobj'
                },

                // for use in popups !!
                trackinfo: {
                    type: String,
                    observer: '_checkTrackinfo'
                },


                /**
                 * make status of trackobj avilable to external services 
                 * processing the data for presentation u.ä.  
                 */
                trackdata: {
                    type: Object,
                    notify: true,
                    observer: '_checkTrackdata'
                },

                // INTERNAL variables

                /**
                 * Animation counter
                 */
                counter: {
                    type: Number
                },

                //
                requestframeref: {
                    type: String,
                    value: '1'
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },

                // 
                routelayers: {
                    type: Object
                },

            },

            behaviors: [
                Polymer.BehaviorRoutes,
                Polymer.BehaviorVendee
            ],

            observers: [
                '_setupTracking(routedata, timescale)',
                'dataToMap(map, routelayers.*, routedata)',
                'ctrlTrackmove(trackctrl)',
                'ctrlTrackmode(trackmode, trackid, map)',
                'trackMapInfo(trackinfo)'
            ],

            /**
             * set 'quasiglobal' this-context for recursive calls during animation 
             * and setup track-features
             */
            attached: function() {
                mba = this;
                this.trackFeaturesInit();
            },

            // DEBUG-utilities
            _checkTracktimer: function(timer) {
                console.log("checking timer", timer.time);
            },
            _checkTrackdata: function(data) {
                //console.log("checking trackdata", data);
            },
            _checkTrackobj: function(trackobj) {
                // console.log("New TRACK obj", trackobj);
            },
            _checkTrackinfo: function(trackinfo) {
                console.log("New TRACKinfo", trackinfo);
            },

            // A. 

            _setupTracking: function(routedata, timescale) {
                // console.log("ORIGINAL routedata:", routedata, " with timescale=" + timescale);

                this.counter = 0;
                this.timer = this.setupTrackTimer(routedata, timescale);

                var routelayers = {};
                routelayers['waypoints'] = this.setupTrackWaypoints(routedata);
                routelayers['routes'] = this.setupTrackRoutes(routedata, this.timer);
                routelayers['tracks'] = this.setupTrackObjects(routedata, this.timer);
                // console.log("RouteAppData Ready", this.routelayers, this.routedata);

                // Double assignment to trigger multi-parameter observer 
                this.routelayers = {};
                this.routelayers = routelayers; // triggers "dataToMap""
            },

            /**
             * Insert (new) routing Data into map-features
             *
             * @param      {object}  routedata     The routetrack-data
             * @param      {object}  layerObjects  The layerObjects to 
             * @param      {object}  map           The map to show routetracker
             */
            dataToMap: function(map, layerObjects, routedata) {
                if (layerObjects.path == 'routelayers') layerObjects = layerObjects.value;
                // console.log("Set Routes To Map: layerObjects, routedata, ", layerObjects, routedata);

                var layerObject, layerData, layerSourec, layer;

                // 1. Create/Refresh json-based layers (sources and layers)
                //    (of tracking-layers)     
                var layernames = Object.keys(layerObjects);

                layernames.forEach(function(lname, j) {
                    layerObject = layerObjects[lname];
                    layerData = layerObject['data'];

                    // 1.A. (Re)Set datasources
                    layerSource = map.getSource(lname);
                    if (!layerSource) {
                        map.addSource(lname, {
                            "type": "geojson",
                            "data": layerData
                        });
                    } else {
                        layerSource.setData(layerData);
                    }

                    // 1.B. Create layers 
                    if (!map.getLayer(lname)) {
                        map.addLayer(layerObject['layer']);
                        // Optional: selectlayer of the same source
                        var sl = layerObject['selectlayer'];
                        if (sl) {
                            map.addLayer(sl);
                            map.setFilter(sl.id, ["==", "id", ""]);
                        }
                    }
                });


                // 2. Prepare a "" Info-Popup
                if (!this.popup) {
                    this.popup = new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: false
                    });
                }

                // 3. Start-Zoom 
                this.trackRoutesZoomTo(routedata);

                // trigger animation-start if no ctrls available 
                if (0) this.trackctrl = true;

                this.counter = 1;

                // 4. Query track-features in "mouseover" and show info-popup 
                map.on('mousemove', function(e) {
                    // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                    mba.trackObjSelect(e);
                });

                // Update visible tracking content at different times  
                mba.syncTrackFilter(mba.timer["start"], "FIRST START");

                // console.log("dataToMap OK!");
            },

            // B. TrackCtrls

            /**
             * { function_description }
             *
             * @param      {<type>}  trackctrl  The trackctrl
             */
            ctrlTrackmove: function(trackctrl) {
                // console.log("trackctrlCheck:", trackctrl)

                if (trackctrl) {

                    if (trackctrl == "reset") {

                        this.trackctrl = false; // triggers this function again 
                        this.trackmode = false;
                        this.counter = 0;
                        this.trackid = undefined; // z.B. popup.remove();
                        this.trackRoutesZoomTo();

                    } else if (typeof trackctrl == "number") {
                        //} else if (trackctrl instanceof Date) {
                        if (this.trackStepAction(null, trackctrl)) {
                            // console.log("Located for ctrltime[h]", trackctrl)
                        };
                        this.trackctrl = false; // triggers this function again 

                    } else {

                        this.requestframeref = requestAnimationFrame(this.trackStepContainer);
                        // this.trackctrl = false; // would trigger this function again 
                    }

                } else {

                    if (this.counter) {
                        var trackObjs = [];
                        if (this.map) trackObjs = this.map.querySourceFeatures({
                            // if (this.map) trackObjs = this.map.queryRenderedFeatures({
                            layers: ['tracks']
                        });
                        // console.log("STOPPED track at cnt=" + this.counter + " with objs", trackObjs);
                    }
                    if (this.requestframeref) cancelAnimationFrame(this.requestframeref);
                }

                // Reset 
                if (this.counter == 0) {
                    console.log("Reset tracking objects");
                    // Set the coordinates of the original point back to origin
                    this.setupTrackObjects(this.routedata, this.timer);
                    this.setupTrackRoutes(this.routedata, this.timer);

                    this.map.getSource('tracks').setData(this.tracks);
                    this.map.getSource('routes').setData(this.routes);
                }

            },

            /**
             * switch euler/lagrange
             */
            ctrlTrackmode: function(trackmode, trackid, map) {

                // No trackmode if no trackObj selected
                if (trackmode && !trackid) {
                    var msg = "<b>Object</b> must be activated to track!"
                    this.trackMapInfo(msg);

                    this.trackmode = false; // set to base 
                    return;
                }

                var zoom = map.getZoom();
                // zoom = Math.round(zoom); // may cause irritation

                if (trackmode) {
                    // this.trackctrl = false; // temporarily STOP ??
                    var trackobj = this.trackobj,
                        cc = trackobj.geometry.coordinates;

                    bearing = trackobj.properties.bearing;
                    console.log("Aligning map with bearing of", trackobj.properties.id);

                    if (zoom < 4) zoom = 4;
                    map.flyTo({
                        center: cc,
                        bearing: bearing,
                        zoom: zoom
                    });

                } else {

                    bearing = 0;
                    if (zoom > 4) zoom = 4;

                    map.easeTo({
                        bearing: bearing,
                        zoom: zoom
                            //speed: 0.2, // make the easeMove slower
                            //curve: 1,   // change the speed at which it changes zoom
                    });
                }

            },

            // C. TrackStep-Animation 

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {
                var timer = mba.timer;
                if (!timer) {
                    mba.trackMapInfo("OOPS. TrackTimer n.a.");
                    return;
                }
                // console.log("trackStepContainer", mba.tracks);

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.

                var mapTime = (timer["start"]) + (mba.counter * timer.frameTime / 3600);
                var located = mba.trackStepAction(mba.counter, mapTime);

                // B. Transfer to map 

                if (!located) {
                    var msg = mba.logTime(mapTime * 3600 * 1000),
                        s = mba.getNextStart(mapTime);
                    if (s) {
                        msg = "NextStart at:" + mba.logTime(s * 3600 * 1000) + "<hr>" + msg;
                    } else {
                        msg = "IDLE: " + msg;
                    }
                    mba.trackMapInfo(msg);
                } else {
                    // mba.map.getSource('tracks').setData(mba.tracks);
                }

                // C. Request the next frame of animation 

                mba.counter = mba.counter + 1;

                // D. Animation RECALL 

                if (mba.trackctrl) {
                    let timer = mba.timer;
                    if (timer.fps && (timer.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                        setTimeout(function() {
                            mba.requestframeref = requestAnimationFrame(mba.trackStepContainer);
                        }, 1000 / timer.fps);
                    } else { // system-based Recall-frequency 
                        mba.requestframeref = requestAnimationFrame(mba.trackStepContainer);
                    }
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function ctrls 
                // - the visibility (using syncTrackFilter)  and  
                // - location of trackObjects 
                // at mapTime related to counter      
                var timer = mba.timer,
                    map = mba.map,
                    located = 0;

                if (counter && !mapTime) {
                    mapTime = (timer["start"]) + (counter * timer.frameTime / 3600);
                }

                if (!counter && mapTime) {
                    mba.syncTrackFilter(mapTime, "mapTIME");
                    counter = Math.round((mapTime - (timer["start"])) / (timer.frameTime / 3600));
                    console.log("mapTime=" + mapTime + ":", "cnt=" + counter);
                    mba.counter = counter;
                }

                // mba.timer.time = mapTime;
                mba.set('timer.time', mapTime);
                // ****************************

                // Show and animate those trackObjects 
                // whose start and stop imbed actual mapTime  
                mba.tracks.features.forEach(function(trackObj, j) {

                    // routes and tracks(Objs) are structured "in-sync" 
                    // referenced through the same index j  
                    var route = mba.routes.features[j];

                    // 
                    var routeProps = route.properties,
                        routeid = routeProps.id,
                        legdata = routeProps.legs,
                        wpdata = routeProps.wps;
                    // console.log(routeid, mapTime, routeProps);

                    var routeStartAt = routeProps.startCounter;

                    if (mapTime > routeProps.stop) {

                        if (routeStartAt != null) { // must be valid for 0 too
                            routeProps.startCounter = null;
                            // console.log("STOP track on route:" + routeid, counter, mapTime, routeProps);
                            mba.syncTrackFilter(mapTime, "STOP:" + routeid);
                        }

                    } else if (mapTime >= routeProps.start) {

                        if (routeStartAt == undefined) { // 
                            // legStartAt = counter - 1;
                            routeStartAt = Math.round((routeProps.start - (timer["start"])) / (timer.frameTime / 3600));
                            routeProps.startCounter = routeStartAt;
                            // console.log("START track on route:" + routeid, routeStartAt, counter, mapTime, routeProps);
                            mba.syncTrackFilter(mapTime, "START:" + routeid);
                        }
                        var legStartAt = routeStartAt;

                        var typ = route.geometry.type,
                            legSet = route.geometry.coordinates;

                        if (typ == "MultiLineString") {
                            // legs = coords;
                        } else {
                            // one leg only 
                            legSet = [legSet];
                        }

                        // Iterate along the route-legs until the track-counter is located within one. 
                        // Get legInfo and cc of the leg selected.
                        var legInfo, cc; // , trackdata;

                        legSet.every(function(legPositions, i) {
                            // return true if xxx, false if xxx
                            if (counter < (legStartAt + legPositions.length)) {
                                cc = legPositions[counter - legStartAt];
                                // ******************************************
                                if (cc) {
                                    legInfo = legdata[i];
                                    return false;
                                }
                            }
                            legStartAt = legStartAt + legPositions.length;
                            return true; // wichtig !!
                        })

                        // Update the trackObj-properties according to its location on the route
                        if (cc) {
                            // console.log("route:"+routeid, legStartAt, counter,  mapTime, cc);

                            located += 1;

                            // A. 
                            trackObj.geometry.coordinates = cc;
                            //********************************

                            // B. Eval status between 2 animation-points 
                            if (trackObj.properties.lastPos) {
                                mba.trackStepStatus(trackObj, legInfo, mapTime);
                            }

                            // C. SYNC content (and location) of the trackObj's info-popup
                            if (mba.trackid == trackObj.properties.id) {

                                // set coordinates of trackobj (?already done?) 
                                // mba.trackobj.geometry.coordinates = cc;

                                // REFRESH trackdata to trigger INFO-element(-popup) 
                                mba.trackdata = {
                                    "id": mba.trackid,
                                    "lnglat": cc,
                                    "trackobj": trackObj
                                }

                                // in track-align map-orientation 
                                // the map is conituously centered at trackObj 
                                // and trackObj-symbol is aligned to bearing  
                                if (mba.trackmode) {
                                    let map = mba.map;
                                    map.easeTo({
                                        center: cc,
                                        bearing: trackObj.properties.bearing,
                                    });
                                }

                                // 
                                if (trackObj.properties.arrived) {
                                    mba.trackmode = false;
                                }
                            }

                            // D. 
                            trackObj.properties.lastPos = cc;
                        }
                    }
                });

                mba.map.getSource('tracks').setData(mba.tracks);

                return located;
            },

            // Calc status-parameters at mapTime and save as properties
            trackStepStatus: function(trackObj, legInfo, mapTime) {
                var objType = trackObj.properties.obj;
                // console.log("trackStepStatus of " + objType, legInfo, trackObj);
                trackObj.properties.time = this.logTime(mapTime * 3600 * 1000);

                var cc = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos,
                    legTarget = legInfo.to;

                // calc last steps bearing (between "actual" and 'last' Position of trackObj )
                var bearing = turf.bearing(new Track(lastPos), trackObj);
                if (bearing < 0) bearing = bearing + 360;

                var legToArrival = new Leg([cc, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers");

                var v = legInfo.speed;
                if (v && Math.round(dta / 10)) {
                    // Moving 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.tta = tta;
                    trackObj.properties.bearing = Math.round(bearing); // °
                    trackObj.properties.arrived = null;

                    if (objType == "ship") {
                        trackObj.properties.speed = Math.round(v / 1.856); // nds
                        trackObj.properties.dta = Math.round(dta / 1.856); // nm
                    } else {
                        trackObj.properties.speed = v; // km/h
                        trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    }

                } else {
                    // Resting
                    trackObj.properties.bearing = 0;
                    trackObj.properties.speed = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;
                    if (legTarget.ab) {
                        if (legTarget.ab != legTarget.an) {
                            let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                            let ttt = this.deltaT(legTarget.dep - mapTime, "TakeOff");
                            trackObj.properties.time = "Start - " + ttt;
                            trackObj.properties.arrived = "Stopover: " + stoptime;
                        }
                    } else {
                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },


            // D. SETUP elements ctrling and/or illustrating the tracking 

            /**
             * Compile a timer from animated routes
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timeScale  The timeScale of animation
             * @return     {Object}  Collection of timeCtrls
             */
            setupTrackTimer: function(routedata, timeScale) {

                // A. Setup basic animation-parameters                
                var timer = {};
                var fpsmax = 60; // Animationszeit 1s=6*60s=6min, 10s=1h Echtzeit 
                if (!timeScale) timeScale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                // B. Assemble all waypoint-times for every route 
                routedata.forEach(function(route, j) {
                    var starts = [],
                        stops = [];
                    route.waypoints.forEach(function(wp, p) {
                        if (wp.ab) starts.push(wp);
                        if (wp.an) stops.push(wp);
                    }.bind(this));

                    // Collect 
                    timer[route.id] = {
                        "starts": starts,
                        "stops": stops
                    }; // [starts, stops, passes];
                }.bind(this));
                // console.log("timer waypoints:", timer, routedata);
                // return;

                // C. Get start&stop times for every route and overall animation period  
                var start, stop;

                Object.keys(timer).forEach(function(id) {
                    var starts = timer[id]["starts"],
                        stops = timer[id]["stops"],
                        wpstart, wpstop, routestart, routestop;

                    if (starts.length) wpstart = starts[0];
                    if (stops.length) wpstop = stops[stops.length - 1];

                    routestart = this.utcTime(wpstart.ab, wpstart.coords, "h");
                    routestop = this.utcTime(wpstop.an, wpstop.coords, "h");

                    timer[id] = {
                        "start": routestart,
                        "stop": routestop
                    };

                    if (!start || (routestart < start)) start = routestart;
                    if (!stop || (routestop > stop)) stop = routestop;
                }.bind(this));

                timer["timeScale"] = timeScale;
                timer.frameTime = timeScale / fpsmax; // Bsp: frameTime: 6 s fuer scale = 360 und fps=60 !!
                timer["start"] = start;
                timer["time"] = start; // initialize 
                timer["stop"] = stop;
                // console.log("timer2", timer);

                // D. OPTION: Get a list of start-times  
                var routeStarts = {},
                    startTimes = [];
                for (let id in timer) {
                    let t = timer[id]["start"];
                    if (!startTimes.length || (startTimes[0] <= t)) startTimes.push(t);
                    else startTimes.splice(0, 0, t);
                }
                timer["startList"] = startTimes;

                // console.log("APPLIED timer:", timer);
                return timer;
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupTrackWaypoints: function(routedata) {
                // console.log("routedata at setupTrackWaypoints", routedata);
                this.waypoints.features = [];
                var allwaypoints = this.waypoints;

                routedata.forEach(function(route, j) {
                    // locate trackObj at 'origin'
                    // console.log("route-" + j, route.waypoints);

                    route.waypoints.forEach(function(wp, p) {
                        var key, icon;
                        if (wp.key) key = wp.key;
                        else key = wp.id;
                        if (wp.icon) icon = wp.icon;
                        allwaypoints.features.push(new Waypoint(wp.coords, key, route.id, icon));
                    });
                });
                // console.log("all waypoints collected", allwaypoints.features);

                // 
                var wpLayer = {};

                wpLayer['data'] = allwaypoints;

                wpLayer['layer'] = {
                    "id": "waypoints",
                    "type": "symbol",
                    "source": "waypoints",
                    "layout": {
                        "icon-image": "{icon}-15",
                        //"icon-image": "harbor-15",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-offset": [0, -0.6]
                    }
                };
                return wpLayer;
            },

            /**
             * create the app-obj for trackLayer
             *
             * @param      {object}  routedata     The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupTrackObjects: function(routedata, timer) {
                // console.log("routedata at setupTrackObjects", routedata);
                // the trackLayerObj contains the data, the styling of the baseLayer AND the styling for the selectLayer
                var trackLayerObj = {};

                // setup data 
                this.tracks.features = [];
                var allTracks = this.tracks,
                    startort, props = {};

                routedata.forEach(function(route, j) {
                    props = {
                        "routeid": route.id,
                        "title": route.key,
                        "obj": route.obj,
                        "start": timer[route.id]["start"],
                        "stop": timer[route.id]["stop"],
                        "master": route.master
                    }
                    startort = route.waypoints[0].coords;
                    var aTrack = new Track(startort, route.id, props);

                    allTracks.features.push(aTrack);
                });

                trackLayerObj['data'] = allTracks;

                // setup styling for baseLayer
                trackLayerObj['layer'] = {
                    "id": "tracks",
                    "source": "tracks",
                    "type": "symbol",

                    "layout": {
                        "icon-image": "airport-15",
                        "icon-size": 2,
                        "icon-rotate": 90,
                        //"icon-image": "{icon}-15",
                        //"icon-rotate": "{bearing}",  
                        "text-field": "{title}",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 12,
                        "text-offset": [0, 0.6],
                        "text-anchor": "top"
                    }
                };

                // setup styling for selectLayer
                trackLayerObj['selectlayer'] = {
                    "id": "tracks-select",
                    "source": "tracks",
                    "type": "symbol",

                    "layout": {
                        "icon-image": "airport-15",
                        "icon-size": 4,
                        "icon-rotate": 45,

                        //"icon-image": "{icon}-15",
                        //"icon-rotate": "{bearing}",  
                        "text-field": "{title}",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 12,
                        "text-offset": [0, 0.6],
                        "text-anchor": "top"
                    }
                };

                return trackLayerObj;
            },

            /**
             * Setup routes for animation with "requestAnimationFrame (60 fps)"
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupTrackRoutes: function(allroutedata, timer) {

                this.routes.features = [];

                // Interpolate the Routes between waypoints 
                // based on info about speed and/or arrival-/departure-times at waypoints

                allroutedata.forEach(function(data, j) {
                    r = this.trackRouteCreate(data, timer);
                    this.routes.features.push(r);
                }.bind(this));

                var routeLayer = {};

                routeLayer['data'] = this.routes;

                routeLayer['layer'] = {
                    "id": "routes",
                    "source": "routes",
                    "type": "line",
                    "paint": {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        "line-dasharray": [4, 4],
                        "line-color": "#007cbf"
                    }
                };
                return routeLayer;
            },

            //  
            trackRouteCreate: function(data, timer) {
                // Initialize 
                var demoSpeed = 900;
                var frameTime = timer.frameTime;

                var wpnext, legDistance, legStepCount;

                var routeid = data.id,
                    legdata = [], // mean props of every leg    
                    legs = [], // routepoints of every leg
                    legTimeSec, legStopSec,
                    legSpeed, routeSpeed = data.speed;

                if (!routeSpeed) routeSpeed = demoSpeed;

                var props = {
                    "id": routeid,
                    "start": timer[routeid]["start"],
                    "stop": timer[routeid]["stop"]
                }

                // Create route-legs between 2 waypoints at any one time 
                var waypoints = data.waypoints; // wps as given

                waypoints.forEach(function(wp, p) {

                    legStopSec = 0;
                    wpnext = waypoints[p + 1];
                    // Calculate leg-properties
                    if (wpnext) {
                        // console.log("waypoints:" + p, wp, wpnext);
                        // Calculate the distance in kilometers between waypoints
                        var leg = new Leg([wp.coords, wpnext.coords]),
                            legDistance = turf.lineDistance(leg, 'kilometers');
                        legDistance = Math.round(legDistance);

                        // Calculate a mean leg-speed between wp's with ab/an times
                        legSpeed = routeSpeed;
                        if (wpnext.an && wp.ab) {
                            let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                arv = mba.utcTime(wpnext.an, wpnext.coords, "h");
                            legSpeed = legDistance / (arv - dep);
                            wpnext.arv = arv;
                        } else if (wpnext.speed) {
                            legSpeed = wpnext.speed;
                        }
                        legSpeed = Math.round(legSpeed);
                        // console.log("leg-speed for dx=", legDistance, legSpeed);

                        // Calculate arv and dep at "stopover"
                        if (wpnext.an && wpnext.ab) {
                            let arv = mba.utcTime(wpnext.an, wpnext.coords, "h"),
                                dep = mba.utcTime(wpnext.ab, wpnext.coords, "h");
                            legStopSec = (dep - arv) * 3600;
                            wpnext.arv = arv;
                            wpnext.dep = dep;
                        } else if (wpnext.stopover) {
                            legStopSec = wpnext.stopover;
                        }

                        // 3. Calc leg-animation 

                        // Time and number of animation-steps to travel between waypoints in legTimeSec
                        legTimeSec = legDistance / legSpeed * 3600;
                        legStepCount = Math.round(legTimeSec / frameTime);

                        // Assign basic leg-properties
                        var legInfo = {};
                        legInfo.from = wp;
                        legInfo.to = wpnext;

                        legInfo.dist = legDistance;
                        legInfo.speed = legSpeed;

                        legInfo.time = legTimeSec;
                        legInfo.steps = legStepCount;

                        // Assign time-properties
                        var h = Math.floor(legTimeSec / 3600),
                            m = Math.round((legTimeSec - (h * 3600)) / 60);
                        legInfo.timetext = h + "h" + m + "min";

                        // Insert animation-positions along the leg
                        var startPosition = 0;
                        var legPositions = [];

                        for (let i = 0; i < legStepCount; i++) {
                            let dist = i * (legDistance / legStepCount);
                            let position = turf.along(leg, dist, 'kilometers');
                            // if (i == 10) console.log(i, dist, position);
                            legPositions.push(position.geometry.coordinates);
                        }

                        // 4. Calc stopover-animation 

                        if (legStopSec) {
                            // console.log("INSERT STOPover at ", wpnext, legStopSec);
                            // INSERT some "zero-steps" at stopover waypoint 
                            h = Math.floor(legStopSec / 3600);
                            m = Math.round((legStopSec - (h * 3600)) / 60);
                            legInfo.stopTime = h + "h" + m + "min";
                            var n = Math.round(legStopSec / frameTime);
                            legInfo.stopSteps = n;
                            // append the "stop-coordinates" to the leg 
                            for (let i = 0; i < n; i++) {
                                legPositions.push(legPositions[legPositions.length - 1]);
                            }
                        }

                        // 4. Compile leg-data in route-collections of legs  
                        legdata.push(legInfo);
                        legs.push(legPositions);
                    }

                });

                // Create route-object consisting of 1-n legs
                var r = new Route(routeid, props, legs, legdata, waypoints);

                return r;
            },

            // E. Additional Functions

            // Sync visibility at "mapTime"
            // of TrackObjects and map-layers 
            syncTrackFilter: function(mapTime, syncflag) {
                var stopDelay = 2000;
                // Always apply syncfilter "immediately"
                // BUT "stopfilter" after some "stopDelay"
                // to let user observe arrived tracker during this delay before removing the tracker and related features 

                // main action
                function applyFilters(mapTime, flag) {
                    // A. Apply PRIMARY FILTER for "ALL trackObjects on MAP" 
                    //    is applied on DATA
                    var startstopfilter = [
                        'all', ['<=', 'start', mapTime],
                        ['>=', 'stop', mapTime]
                    ];

                    mba.map.setFilter('tracks', startstopfilter);
                    var trackObjs = this.map.querySourceFeatures("tracks", {
                        filter: startstopfilter
                    });

                    // B. Check if trackObjs remained after filter 
                    //    and stop animation, if no further track-tart is expected 
                    if (!trackObjs.length) { // CHECK for STOP
                        if (!mba.getNextStart(mapTime)) {
                            mba.trackctrl = false;
                            mba.trackmode = false;
                            var msgTime = mba.logTime(mapTime * 3600 * 1000);
                            console.log("At", msgTime, "-no more data to Sync");
                            mba.map.setFilter('routes', null);
                            mba.map.setFilter('waypoints', null);
                            return;
                        }
                    } else if (flag.indexOf('TIME') >= 0) {
                        // console.log("trackObjs filtered at ", msgTime, trackObjs, startstopfilter);
                    }

                    // C. Apply SECONDARY FILTER 
                    //    to Sync the MAP-filters for "related" layers (routes waypoints)  

                    var trackids = [],
                        routeids = [],
                        routeid;

                    // collect ROUTES of all actually "active" trackObjs    
                    trackObjs.forEach(function(to) {
                        routeid = to.properties.routeid;
                        if (routeid) trackids.push(routeid);
                    });
                    // remove duplicates
                    routeids = trackids.filter(function(item, pos, self) {
                        return self.indexOf(item) == pos;
                    })

                    // Filter  related mapFeatures on MAP 
                    if (routeids.length) {
                        // BUILD secondary filter
                        var routeFilter = ["in", "routeid"]
                        routeids.forEach(function(id) {
                            routeFilter.push(id);
                        });
                        // console.log("Refreshed SecondaryFilter", routeFilter);
                        mba.map.setFilter('routes', routeFilter);
                        mba.map.setFilter('waypoints', routeFilter);
                    }
                    var msgTime = mba.logTime(mapTime * 3600 * 1000, "<br>");
                    mba.trackMapInfo("<b>" + flag + "</b>" + " at " + msgTime);
                };

                // Optional BREAK! Sync trackObjects(and it's routes) only as long as they are tracked 
                if (!map.getLayer("tracks")) {
                    var syncTime = this.logTime(mapTime * 3600 * 1000);
                    mba.trackMapInfo("<b>No trackers to track</b>" + " at " + syncTime);
                    return;
                }

                // STOP-check 
                if (syncflag.indexOf("STOP") >= 0) {
                    // if STOP flag 
                    console.log("Reset selected trackobject(s)");
                    mba.map.setFilter("tracks-select", ["==", "id", ""]);

                    setTimeout(function() {
                        applyFilters(mapTime, syncflag);
                    }, stopDelay);
                    return;
                }

                // Apply filter for All other flags but STOP 
                applyFilters(mapTime, syncflag);

            },

            // 
            trackFeaturesInit: function() {
                this.routes = {
                    "type": "FeatureCollection"
                };
                this.waypoints = {
                    "type": "FeatureCollection"
                };
                this.tracks = {
                    "type": "FeatureCollection"
                };
            },

            // Zoom to all bbox of all waypoints
            trackRoutesZoomTo: function(routedata, routeid) {
                if (!routedata) routedata = this.routedata;

                // Collect waypoint-coordinates
                var coordinates = [],
                    coords_datum = [],
                    neast = 0,
                    nwest = 0,
                    lmin, lmax, dl, bounds, center,
                    startmode = false; // routedata[0].waypoints[0].coords ];

                // NOT-Heuristic zum Problem Datumsgrenze
                // a.  
                routedata.forEach(function(route, j) {
                    route.waypoints.forEach(function(wp, i) {
                        var lng = wp.coords[0];
                        nwest = lng < 0 ? nwest + 1 : nwest;
                        neast = lng > 0 ? neast + 1 : neast;
                        if (!lmin) {
                            lmin = lng;
                            lmax = lng;
                        }
                        lmin = lng < lmin ? lng : lmin;
                        lmax = lng > lmax ? lng : lmax;
                    })
                });
                dl = lmax - lmin;
                // console.log("delta-lng=" + dl, "nwest=" + nwest, "neast=" + neast);

                // b. 
                routedata.forEach(function(route, j) {
                    route.waypoints.forEach(function(wp, i) {
                        var lng = wp.coords[0];
                        if (dl < 180) coordinates.push(wp.coords);
                        else if ((lng < 0) && (nwest > neast)) coordinates.push(wp.coords);
                        else if ((lng > 0) && (neast > nwest)) coordinates.push(wp.coords);
                    })
                });

                // Specialcase !!
                if (startmode) { // workaround for coords around dateline
                    center = coordinates[0];
                } else { // create bounds around all wp-coordinates
                    // startvalue 
                    bounds = new mapboxgl.LngLatBounds(coordinates[0], coordinates[0]);
                    // collect all 
                    bounds = coordinates.reduce(function(bounds, coord) {
                        return bounds.extend(coord);
                    }, bounds);

                    center = bounds.getCenter();
                }
                // console.log("center, wp-coordinates", center, coordinates);

                if (bounds) map.fitBounds(bounds, {
                    padding: 20
                });
            },

            // Check if more starts 
            getNextStart: function(mapTime) {
                var starts = mba.timer.startList,
                    nextStart;
                starts.some(function(start) {
                    if (mapTime < start) {
                        nextStart = start;
                        return false;
                    }
                }); //console.log(mapTime, "nextStart=" + nextStart, starts);
                return nextStart;
            },

            // Refresh the appInfo at map-center 
            trackMapInfo: function(trackinfo) {
                var lnglat;
                if (typeof trackinfo == "object") {
                    html = trackinfo.html;
                    lnglat = trackinfo.lnglat;
                } else html = trackinfo;

                if (mba && mba.popup) { //  console.log("check popup", mba.popup)
                    if (!lnglat) lnglat = mba.map.getCenter();
                    mba.popup.remove;
                    mba.popup
                        .setLngLat(lnglat)
                        .setHTML(html)
                        .addTo(mba.map);
                }
            },

            /**
             * Activate a trackObject selected by gui-event e (mode-over, click, ...) 
             *
             */
            trackObjSelect: function(e) {
                var features = [];
                if (map.getLayer('tracks') || map.getLayer('tracks-select')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['tracks', 'tracks-select']
                    });
                }
                if (!features.length) {
                    // mba.trackdata = {};
                    // popup-strategy 1: 
                    // Remove popup if pointer not on any feature
                    // this.popup.remove();
                    return;
                } // console.log("mousemove-event", e);

                if (mba.trackid == features[0].properties.id) {
                    return;
                }

                mba.trackobj = features[0];
                mba.trackid = mba.trackobj.properties.id;

                map.setFilter("tracks-select", ["==", "id", mba.trackid]);

                // Change the cursor style as a UI indicator.
                // map.getCanvas().style.cursor = 'pointer';


                // popup-strategy 2: 
                // Update and reconnect the this.popup to the map at new object
                mba.popup.remove();

                // Trackdata with "Override dirty checking" 

                if (mba.trackobj) {
                    mba.trackdata = {
                        "lnglat": mba.trackobj.geometry.coordinates,
                        "trackobj": mba.trackobj,
                        "open": true
                    }
                }

            }

        });
    </script>
</dom-module>