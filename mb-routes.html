<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="mb-api.html">
<link rel="import" href="mb-routes-behavior.html">

<!--
`mb-routes`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="mb-routes">

    <template>
    
        <iron-ajax
            auto
            url="[[url]]"
            handle-as="json"
            on-response="routesConfig">
        </iron-ajax>
    
    </template>

    <script>
        var mba;

        /**
         * A waypoint bordering a routes leg
         */
        class Waypoint {
            /**
             * Constructs the object.
             *
             * @param      {array}   coordinates  The wp's coordinates as [lng,lat]-array
             * @param      {string}  id           The wp's identifier
             * @param      {string}  icon         The mapbox-icon name 
             */
            constructor(coordinates, id, icon) {
                if (!id) id = "wp";
                if (!icon) icon = "star";
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }
                this.id = id;
                this.properties = {
                    "title": id,
                    "icon": icon
                }
            };
        };

        /**
         * A mapbox-feature describing a route-segment
         */
        class Leg {
            /**
             * Constructs the object.
             *
             * @param      {array}  coordinates  The coordinates of the legs start/stop
             */

            constructor(coordinates) {
                this.type = "Feature";
                this.geometry = {
                    "type": "LineString",
                    "coordinates": coordinates
                }
                this.properties = {

                }
            }
        };

        /**
         * A mb-multi-object joining the animation points between multiple waypoints into a mb-geometry   
         */
        class Route {
            /**
             * Constructs the object.
             *
             * @param      {<type>}  coordinates  The coordinates
             * @param      {<type>}  data         The data
             * @param      {<type>}  wps          The wps
             */
            constructor(routeid, props, coordinates, legdata, wps) { // coordinates = array of coordinate-arrays (multiLine) 
                this.type = "Feature";
                this.geometry = {
                    "type": "MultiLineString",
                    "coordinates": coordinates
                };
                /**
                 * Metadata of route-componets 
                 */
                this.id = routeid;
                props.id = routeid;
                props.legs = legdata;
                props.wps = wps;
                this.properties = props;
            }
        };

        /**
         * A mapbox-point-feature tracked along a route  
         */
        class Track {
            /**
             * Constructs the object.
             * @param      {array}  coordinates   The coordinates
             * @param      {string}  routeid      The identifier of route
             * @param      {string}  plane        The id(name) of the obj (fi plane-code)
             * @return     {mb-feature}  { mapbox point feature }
             */
            constructor(coordinates, routeid, props) {
                if (!props) props = {};
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                };
                this.id = routeid;
                props.id = routeid;
                props.bearing = 45;
                props.time = 0;
                props.speed = 0;
                this.properties = props;
            }
        };


        Polymer({

            is: 'mb-routes',

            properties: {

                map: {
                    type: Object
                },
                popup: {
                    type: Object
                },

                /**
                 * Url to source of routed waypoints
                 */
                url: {
                    type: String
                },

                trackctrl: {
                    type: Boolean,
                    notify: true
                },

                trackview: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                trackid: {
                    type: String,
                    value: ""
                },

                trackobj: {
                    type: Object,
                    notify: true
                },

                trackinfo: {
                    type: String
                },

                // internal variables

                /**
                 * Animation counter
                 */
                counter: {
                    type: Number
                },

                requestframeref: {
                    type: String,
                    value: '1'
                },
                /**
                 * FramePerSecond of animation
                 */
                fps: {
                    type: Number,
                    value: 60
                },
                /**
                 * { item_description }
                 */
                timescale: {
                    type: Number,
                    value: 720
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },

                routelayers: {
                    type: Object
                },

            },

            behaviors: [
                Polymer.RoutesBehavior
            ],

            observers: [
                'applyToMap(map, routelayers, routedata)',
                'animateCtrl(trackctrl)',
                'viewCtrl(trackview, trackid)'
            ],

            attached: function() {

                /**
                 * quasiglobal context for animation 
                 */
                mba = this;

                this.routes = {
                    "type": "FeatureCollection"
                };
                this.waypoints = {
                    "type": "FeatureCollection"
                };
                this.tracks = {
                    "type": "FeatureCollection"
                };
            },

            /**
             * { function_description }
             *
             * @param      {number}  counter    The counter
             * @param      {<type>}  trackctrl  The trackctrl
             */
            animateCtrl: function(trackctrl) {
                // console.log("trackctrl", trackctrl)

                if (trackctrl) {
                    if (trackctrl == "reset") {
                        this.trackctrl = false; // triggers this function again 
                        this.trackview = false;
                        this.counter = 0;
                        this.trackid = undefined; // z.B. popup.remove();
                        this.zoomToRoutes();
                    } else {
                        this.requestframeref = requestAnimationFrame(this.animateStep);
                    }
                } else {

                    var trackObjs = [];
                    if (this.map) trackObjs = this.map.queryRenderedFeatures({
                        layers: ['tracks']
                    });
                    console.log("PAUSED animation at counter=" + this.counter + " with ", trackObjs);
                    cancelAnimationFrame(this.requestframeref);
                }

                // 
                if (this.counter == 0) {
                    console.log("Reset tracking objects");
                    // Set the coordinates of the original point back to origin
                    this.initTracks(this.routedata, this.trackTimer);
                    this.setupRoutes(this.routedata, this.trackTimer, this.timescale);

                    this.map.getSource('tracks').setData(this.tracks);
                    this.map.getSource('routes').setData(this.routes);
                }

            },

            /**
             */
            viewCtrl: function(trackview, trackid) {

                // 
                if (!trackid) {
                    if (this.popup) this.popup.remove;
                    this.trackview = false;
                    return;
                }

                var map = this.map,
                    zoom = Math.round(map.getZoom());

                var trackobj = this.trackobj,
                    cc = trackobj.geometry.coordinates;

                if (trackview) {

                    this.trackctrl = false;

                    console.log("aligning map-bearing with ", trackobj.properties.id);
                    bearing = trackobj.properties.bearing;
                    if (zoom < 4) zoom = 4;
                    map.flyTo({
                        center: cc,
                        bearing: bearing,
                        zoom: zoom
                    });

                } else {

                    bearing = 0;
                    if (zoom > 4) zoom = 4;

                    map.easeTo({
                        bearing: bearing,
                        zoom: zoom
                            //speed: 0.2, // make the flying slow
                            //curve: 1, // change the speed at which it zooms out
                    });
                }

            },

            /**
             * { function_description }
             */
            animateStep: function() {
                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.
                var located = mba.calcTrackStep(mba.counter);
                // console.log("DEBUG", mba.counter, mba.tracks);
                // if (mba.counter > 10)  return;

                // Update the animated map-objects 
                // updating their sources with new data.
                mba.map.getSource('tracks').setData(mba.tracks);
                mba.map.getSource('routes').setData(mba.routes);

                // B. Animation CTRL 
                if (located) {
                    // Request the next frame of animation so long 
                    // as not all trackObjs have reached their destination (located != null) 
                    mba.counter = mba.counter + 1;
                    // return;
                } else if (mba.idle) {
                    // let animation run idle
                } else {
                    console.log("Finished predefined tracks after counter=", mba.counter);
                    // cancelAnimationFrame(mba.requestframeref);
                    mba.trackctrl = false;
                    mba.viewctrl = false;
                    mba.idle = true;
                }

                // C. Animation RECALL 
                if (mba.trackctrl) {
                    if (mba.fps && (mba.fps < 60)) {
                        setTimeout(function() {
                            mba.requestframeref = requestAnimationFrame(mba.animateStep);
                        }, 1000 / mba.fps);
                    } else {
                        mba.requestframeref = requestAnimationFrame(mba.animateStep);
                    }
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {Boolean}  Flag = truem when an object could be located
             */
            calcTrackStep: function(counter) {
                // "located" returns the number of trackObjects animated at step counter
                // some finish earlier than others 
                // if all are finished the animation must be stopped !!

                // var located = 0,
                // var tracksFinished = [];

                // console.log("calcTrackStep-1", counter, mba.trackTimer, mba.frameTime);
                var map = mba.map,
                    mapTime = (mba.trackTimer["start"]) + (counter * mba.frameTime / 3600);

                // Show only     
                // mba.filterBy(mapTime);

                // try to animate all actually loaded trackObjects
                mba.tracks.features.forEach(function(trackObj, j) {

                    // routes and tracks(Objs) are structured "in-sync" referenced through the same index j  
                    var route = mba.routes.features[j];

                    var routeInfo = route.properties,
                        routeid = routeInfo.id,
                        legStartCounter = routeInfo.startCounter; // 0; // 
                    // trackStart = routeInfo.start; // mba.trackTimer[routeid]["start"];

                    if (mapTime > routeInfo.stop) {
                        if (legStartCounter != null) { // must be valid for 0 too
                            routeInfo.startCounter = null;
                            // console.log("STOP track on route:" + routeid, counter, mapTime, routeInfo);
                            mba.filterBy(mapTime, "STOP:" + routeid);
                        }

                    } else if (mapTime >= routeInfo.start) {

                        if (legStartCounter == undefined) {
                            legStartCounter = counter - 1;
                            routeInfo.startCounter = legStartCounter;
                            // console.log("START track on route:" + routeid, legStartCounter, counter, mapTime, routeInfo);
                            mba.filterBy(mapTime, "START:" + routeid);
                        }

                        var typ = route.geometry.type,
                            legSet = route.geometry.coordinates,
                            legdata = routeInfo.legs,
                            wpdata = routeInfo.wps;

                        if (typ == "MultiLineString") {
                            // legs = coords;
                        } else {
                            // one leg only 
                            legSet = [legSet];
                        }

                        // Checkout the routes leg the trackObj is located  
                        // at animation-step "counter", get legInfo and cc 
                        var legInfo, cc;

                        legSet.every(function(legPositions, i) {
                            // return true if xxx, false if xxx
                            if (counter < (legStartCounter + legPositions.length)) {
                                cc = legPositions[counter - legStartCounter];
                                if (cc) {
                                    legInfo = legdata[i];
                                    return false;
                                }
                            }
                            legStartCounter = legStartCounter + legPositions.length;
                            return true; // wichtig !!
                        })

                        // Update the trackObj-properties according to its location on the route
                        if (cc) {
                            // console.log("route:"+routeid, legStartCounter, counter,  mapTime, cc);
                            // A. 
                            trackObj.geometry.coordinates = cc;
                            //********************************

                            // B. Eval status between 2 animation-points 
                            if (trackObj.properties.lastPos) {
                                mba.calcTrackStatus(trackObj, legInfo, mapTime);
                            }

                            // C. update content and location of the trackObj's info-popup
                            if (mba.trackid == trackObj.properties.id) {

                                mba.trackinfo = mba.calcTrackInfo(trackObj);

                                mba.popup.setHTML(mba.trackinfo); //console.log("popup", mba.popup, trackinfo, cc);
                                mba.popup.setLngLat(cc);

                                if (mba.trackview) { // lagrange mode
                                    let map = mba.map;
                                    map.easeTo({
                                        center: cc,
                                        bearing: trackObj.properties.bearing,
                                    });
                                }
                            }

                            // D. 
                            trackObj.properties.lastPos = cc;

                        } else {

                            // waitcounter counts the number of animation steps after landing
                            // to remove landed track(and route) after critical number
                            if (!trackObj.waitcounter) {
                                console.log("Track along route[" + routeid + "] finished!", trackObj);
                                trackObj.waitcounter = 1;
                            } else if (trackObj.waitcounter == 100) {
                                // tracksFinished.push(routeid);
                                if (trackObj.properties.id == mba.trackid) mba.popup.remove();

                            } else if (trackObj.waitcounter < 100) {
                                trackObj.waitcounter = trackObj.waitcounter + 1;
                            }

                        }
                    } else {

                    }

                });

                /*if (tracksFinished.length) {

                    console.log("REMOVE some tracker(s) and its route-feature(s)", tracksFinished);

                    // var routesRemain = [], tracksRemain = [];

                    mba.tracks.features.forEach(function(f) {
                        var routeid = f.id; // ***  
                        if (tracksFinished.indexOf(routeid) < 0) {
                            // tracksRemain.push(f);
                        }
                    });
                    mba.routes.features.forEach(function(f) {
                        var routeid = f.properties.id; // ***
                        if (tracksFinished.indexOf(routeid) < 0) {
                            // routesRemain.push(f);
                        }
                    });

                    // mba.tracks.features = tracksRemain;
                    // mba.routes.features = routesRemain;
                }*/
                located = 1; // mba.tracks.features.length;
                return located;
            },

            // 
            calcTrackStatus: function(trackObj, legInfo, mapTime) {
                // console.log(legInfo, trackObj);
                trackObj.properties.time = this.logTime(mapTime * 3600 * 1000);

                var cc = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos,
                    legTarget = legInfo.to;

                // calc last steps bearing (between plane and its 'lastPosition')
                var bearing = turf.bearing(new Track(lastPos), trackObj);
                if (bearing < 0) bearing = bearing + 360;

                var legToArrival = new Leg([cc, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers");

                var v = legInfo.speed;


                if (v && Math.round(dta / 10)) {
                    // Moving 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.bearing = Math.round(bearing); // Â°
                    trackObj.properties.speed = v; // km/h
                    trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    trackObj.properties.tta = tta;
                    trackObj.properties.arrived = null;

                } else {
                    // Resting
                    trackObj.properties.bearing = 0;
                    trackObj.properties.speed = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;
                    if (legTarget.ab) {
                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        let ttt = this.deltaT(legTarget.dep - mapTime, "TakeOff");
                        trackObj.properties.time = "Start - " + ttt;
                        trackObj.properties.arrived = "Stopover: " + stoptime;
                    } else {
                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },

            /**
             * Setup of animation framework from new wp-dataset
             *
             * @param      {<type>}  routedata  Routedata as wp-dataset
             */
            routesConfig: function(ajaxresponse) {

                var routedata = ajaxresponse.detail.response;

                this.counter = 0;

                this.routedata = routedata;
                this.trackTimer = this.setupTrackTimer(routedata);
                // return;

                if (!this.routelayers) this.routelayers = {};
                this.routelayers['waypoints'] = this.setupWaypoints(routedata);
                this.routelayers['routes'] = this.setupRoutes(routedata, this.trackTimer, this.timescale);
                this.routelayers['tracks'] = this.initTracks(routedata, this.trackTimer);
                console.log("RouteAppData Ready", this.routelayers, this.routedata);
                // this.setupAnimationCtrls(routedata);
            },

            /**
             * Insert routedata into map-features
             *
             * @param      {<type>}  routedata     The routedata
             * @param      {<type>}  layerObjects  The layerObjects to 
             */
            applyToMap: function(map, layerObjects, routedata) {
                console.log("SetRoutesToMap: layerObjects, routedata, ", layerObjects, routedata);

                // 1. add json-based layers (sources and layers)     
                var layerObject, layerData, layerSourec, layer,
                    layernames = Object.keys(layerObjects);

                layernames.forEach(function(lname, j) {
                    layerObject = layerObjects[lname];
                    layerData = layerObject['data'];
                    // A. 
                    layerSource = map.getSource(lname);
                    if (!layerSource) {
                        map.addSource(lname, {
                            "type": "geojson",
                            "data": layerData
                        });
                    } else {
                        layerSource.setData(layerData);
                    }

                    // B. 
                    if (!map.getLayer(lname)) {
                        map.addLayer(layerObject['layer']);
                    }
                });


                // 2. Prepare Info-Popup
                this.popup = new mapboxgl.Popup({
                    closeButton: true,
                    closeOnClick: false
                });

                // 3. Start-Zoom & trigger animation-start if no ctrls available 
                this.zoomToRoutes(routedata);
                if (0) this.trackctrl = true;

                this.counter = 1;

                // 4. 
                map.on('mousemove', function(e) {
                    // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);

                    var features = map.queryRenderedFeatures(e.point, {
                        layers: ['tracks']
                    });

                    if (!features || !features.length) {
                        // strategy 1: 
                        // Remove popup if pointer not on any feature
                        // this.popup.remove();
                        return;
                    }
                    // console.log("mousemove-event", e);

                    // Change the cursor style as a UI indicator.
                    map.getCanvas().style.cursor = 'pointer';

                    // strategy 2: 
                    // A. remove popup, if object selected (changes)
                    mba.popup.remove();

                    // B. Update and reconnect the this.popup to the map at new objectnew 
                    mba.trackobj = features[0];
                    mba.trackid = mba.trackobj.properties.id;

                    mba.trackinfo = mba.calcTrackInfo(mba.trackobj);

                    mba.popup
                        .setLngLat(mba.trackobj.geometry.coordinates)
                        .setHTML(mba.trackinfo)
                        .addTo(map);
                });

                // Show only     
                mba.filterBy(mba.trackTimer["start"], "STARTUP");

                console.log("applyToMap OK!");

            },


            /**
             * Compile the some timeflags of animated tracks
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timeScale  The timeScale of animation
             * @return     {Object}  Descriptor of timeCtrls
             */
            setupTrackTimer: function(routedata, timeScale) {
                if (!timeScale) timeScale = this.timescale;
                if (!timeScale) timeScale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                var fpsmax = 60; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                this.frameTime = timeScale / fpsmax; // Bsp: frameTime: 6 s fuer scale = 360 und fps=60 !!
                console.log("timeScale,frameTime", timeScale, this.frameTime);

                var start, trackTimer = {};

                routedata.forEach(function(route, j) {
                    var starts = [],
                        stops = [];
                    route.waypoints.forEach(function(wp, p) {
                        if (wp.ab) starts.push(wp);
                        if (wp.an) stops.push(wp);
                    }.bind(this));
                    trackTimer[route.id] = [starts, stops];
                }.bind(this));
                // console.log("trackTimerRaw", trackTimer);

                Object.keys(trackTimer).forEach(function(id) {
                    var starts = trackTimer[id][0],
                        stops = trackTimer[id][1],
                        wpstart = starts[0],
                        wpstop = stops[stops.length - 1],
                        routestart = this.utcTime(wpstart.ab, wpstart.coords, "h"),
                        routestop = this.utcTime(wpstop.an, wpstop.coords, "h");
                    trackTimer[id] = {
                        "start": routestart,
                        "stop": routestop
                    };
                    if (!start || (routestart < start)) start = routestart;
                }.bind(this));

                var routeStarts = [];
                for (var id in trackTimer)
                    routeStarts.push([id, trackTimer[id]["start"]]);

                routeStarts.sort(function(a, b) {
                    return a[1] - b[1]
                })

                trackTimer["start"] = start;
                trackTimer["sorted"] = routeStarts;

                console.log("trackTimer collected", start, trackTimer);

                return trackTimer;
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupWaypoints: function(routedata) {

                this.waypoints.features = [];
                var allwaypoints = this.waypoints;

                routedata.forEach(function(route, j) {
                    // locate plane at 'origin'
                    // console.log("route-" + j, route.waypoints);
                    route.waypoints.forEach(function(wp, p) {
                        allwaypoints.features.push(new Waypoint(wp.coords, wp.id));
                    });
                });
                console.log("all waypoints collected", allwaypoints.features);

                // 
                var wpLayer = {};

                wpLayer['data'] = allwaypoints;

                wpLayer['layer'] = {
                    "id": "waypoints",
                    "type": "symbol",
                    "source": "waypoints",
                    "layout": {
                        "icon-image": "{icon}-15",
                        //"icon-image": "harbor-15",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-offset": [0, -0.6]
                    }
                };
                return wpLayer;
            },

            // A. Setup (animated) trackobjects for all sets of routedata

            /**
             * { function_description }
             *
             * @param      {number}  startcounter  The startcounter
             * @param      {<type>}  routedata     The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            initTracks: function(routedata, trackTimer, startcounter) {
                if (!startcounter) startcounter = 0;

                var trackLayer = {};

                // setup data 
                this.tracks.features = [];
                var allTracks = this.tracks,
                    props = {};

                routedata.forEach(function(route, j) {
                    // locate plane at 'origin'
                    props = {
                        "title": route.plane,
                        "start": trackTimer[route.id]["start"],
                        "stop": trackTimer[route.id]["stop"]
                    }
                    var aTrack = new Track(route.waypoints[startcounter].coords, route.id, props);

                    allTracks.features.push(aTrack);
                });

                trackLayer['data'] = allTracks;

                // setup styling
                trackLayer['layer'] = {
                    "id": "tracks",
                    "source": "tracks",
                    "type": "symbol",

                    "layout": {
                        "icon-image": "airport-15",
                        "icon-size": 2,
                        "icon-rotate": 90,
                        //"icon-image": "{icon}-15",
                        //"icon-rotate": "{bearing}",  
                        "text-field": "{title}",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 12,
                        "text-offset": [0, 0.6],
                        "text-anchor": "top"
                    }
                };

                return trackLayer;
            },

            /**
             * Setup routes for animation with "requestAnimationFrame (60 fps)"
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {number}  timeScale  The time scale
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupRoutes: function(allroutedata, trackTimer) {

                this.routes.features = [];

                // Interpolate the Routes between waypoints 
                // based on info about speed and/or arrival-/departure-times at waypoints

                allroutedata.forEach(function(data, j) {
                    r = this.createRoute(data, trackTimer);
                    this.routes.features.push(r);
                }.bind(this));

                var routeLayer = {};

                routeLayer['data'] = this.routes;

                routeLayer['layer'] = {
                    "id": "routes",
                    "source": "routes",
                    "type": "line",
                    "paint": {
                        "line-width": 2,
                        "line-color": "#007cbf"
                    }
                };
                return routeLayer;
            },

            createRoute: function(data, trackTimer, frameTime) {
                // Initialize 
                var demoSpeed = 900;
                if (!frameTime) frameTime = this.frameTime;

                var wpnext, legDistance, legStepCount;

                var routeid = data.id,
                    legdata = [], // mean props of every leg    
                    legs = [], // routepoints of every leg
                    legTimeSec, legStopSec,
                    legSpeed, routeSpeed = data.speed;

                if (!routeSpeed) routeSpeed = demoSpeed;

                var props = {
                    "id": routeid,
                    "start": trackTimer[routeid]["start"],
                    "stop": trackTimer[routeid]["stop"]
                }

                // Create route-legs between 2 waypoints at any one time 
                var waypoints = data.waypoints; // wps as given

                waypoints.forEach(function(wp, p) {

                    wpnext = waypoints[p + 1];
                    legStopSec = 0;

                    // Calculate leg-properties
                    if (wpnext) {
                        // console.log("waypoints:" + p, wp, wpnext);
                        // Calculate the distance in kilometers between waypoints
                        var leg = new Leg([wp.coords, wpnext.coords]),
                            legDistance = turf.lineDistance(leg, 'kilometers');
                        legDistance = Math.round(legDistance);
                        // console.log("Route-" + j + ", leg to", wpnext, legDistance); 

                        // options to calculate a mean leg-speed (between wp's)
                        legSpeed = routeSpeed;
                        if (wpnext.an && wp.ab) {
                            let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                arv = mba.utcTime(wpnext.an, wpnext.coords, "h");
                            legSpeed = legDistance / (arv - dep);
                            wpnext.arv = arv;
                        } else if (wpnext.speed) {
                            legSpeed = wpnext.speed;
                        }
                        legSpeed = Math.round(legSpeed);
                        console.log("speed for ", legDistance, legSpeed);

                        if (wpnext.an && wpnext.ab) {
                            let arv = mba.utcTime(wpnext.an, wpnext.coords, "h"),
                                dep = mba.utcTime(wpnext.ab, wpnext.coords, "h");
                            legStopSec = (dep - arv) * 3600;
                            wpnext.arv = arv;
                            wpnext.dep = dep;
                        } else if (wpnext.stopover) {
                            legStopSec = wpnext.stopover;
                        }

                        // Calc number of animation-steps to travel between waypoints in legTimeSec
                        // console.log("legspeed=", legSpeed);
                        legTimeSec = legDistance / legSpeed * 3600;
                        legStepCount = Math.round(legTimeSec / frameTime);

                        // Assign basic leg-properties
                        var legInfo = {};
                        legInfo.from = wp;
                        legInfo.to = wpnext;

                        legInfo.dist = legDistance;
                        legInfo.speed = legSpeed;

                        legInfo.time = legTimeSec;
                        legInfo.steps = legStepCount;

                        // Assign time-properties
                        var h = Math.floor(legTimeSec / 3600),
                            m = Math.round((legTimeSec - (h * 3600)) / 60);
                        legInfo.timetext = h + "h" + m + "min";

                        // Insert animation-positions along the leg
                        var startPosition = 0;
                        var legPositions = [];

                        for (let i = 0; i < legStepCount; i++) {
                            let dist = i * (legDistance / legStepCount);
                            let position = turf.along(leg, dist, 'kilometers');
                            // if (i == 10) console.log(i, dist, position);
                            legPositions.push(position.geometry.coordinates);
                        }

                        if (legStopSec) {
                            console.log("INSERT STOPover at ", wpnext, legStopSec);

                            // INSERT some "zero-steps" at stopover waypoint 
                            h = Math.floor(legStopSec / 3600);
                            m = Math.round((legStopSec - (h * 3600)) / 60);
                            legInfo.stopTime = h + "h" + m + "min";

                            var n = Math.round(legStopSec / frameTime);
                            legInfo.stopSteps = n;

                            // append "stop-coordinates" to the leg 
                            for (let i = 0; i < n; i++) {
                                legPositions.push(legPositions[legPositions.length - 1]);
                            }

                        }

                        legdata.push(legInfo);
                        legs.push(legPositions);
                    }
                });

                // Add next route-object consisting of some legs
                var r = new Route(routeid, props, legs, legdata, waypoints);

                return r;
            }, // console.log("routes", routes);

            zoomToRoutes: function(routedata, routeid) {
                if (!routedata) routedata = this.routedata;

                // Collect waypoint-coordinates
                var coordinates = [],
                    bounds, center,
                    startmode = false; // routedata[0].waypoints[0].coords ];

                routedata.forEach(function(route, j) {
                    route.waypoints.forEach(function(wp, i) {
                        coordinates.push(wp.coords);
                        startmode = startmode || (wp.coords[0] > 150);
                    })
                });

                // Specialcase !!
                if (startmode) { // workaround for coords around dateline
                    center = coordinates[0];
                } else { // create bounds around all wp-coordinates
                    bounds = coordinates.reduce(function(bounds, coord) {
                            return bounds.extend(coord);
                        },
                        new mapboxgl.LngLatBounds(coordinates[0], coordinates[0])
                    );
                    center = bounds.getCenter();
                }
                // console.log("center, wp-coordinates", center, coordinates);

                if (bounds) map.fitBounds(bounds, {
                    padding: 20
                });
            },

            filterBy: function(mapTime, flag) {
                // show trackObjects(and it's routes) only as long as they are tracked 
                var filters = [
                    'all', ['<=', 'start', mapTime],
                    ['>=', 'stop', mapTime]
                ]

                function applyFilters() {

                    this.map.setFilter('routes', filters);
                    this.map.setFilter('tracks', filters);

                    // let filter act before check !!
                    setTimeout(function() {

                        var trackObjs = this.map.queryRenderedFeatures({
                            layers: ['tracks']
                        });

                        if (!trackObjs.length) {
                            this.trackctrl = false;
                            this.trackview = false;
                            if (this.popup) {
                                // this.popup.remove;
                                this.popup
                                    .setLngLat(this.map.getCenter())
                                    .setHTML("Stopped!")
                                    .addTo(this.map);
                            }
                        } else {
                            console.log(flag, mapTime, "trackObjects:" + trackObjs.length, trackObjs);
                        }
                    }, 200);

                };

                if (flag.indexOf("STOP") < 0) {
                    applyFilters(filters);
                } else {
                    // let user observe arrived object for 2 seconds
                    setTimeout(function() {
                        applyFilters(filters);
                    }, 2000);
                }

            }

        });
    </script>
</dom-module>