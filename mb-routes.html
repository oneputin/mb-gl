<link rel="import" href="../polymer/polymer.html">
<link rel="import" href="../iron-ajax/iron-ajax.html">

<link rel="import" href="mb-api.html">

<link rel="import" href="mb-tools-behavior.html">
<!--<link rel="import" href="mb-behavior-info-vendee.html">-->

<!--
`mb-routes`
creates anf follow animated routes 
along waypoint file loaded from url

@demo demo/routemap.html 
-->
<dom-module id="mb-routes">

    <template>

    </template>

    <script>
        // Global referencing thi element in animation and geschachtelten functions
        var mba;

        // Templates for mapbox-layer-data
        // nodes,routes,traces,tracks,legs
        //if (1) {
            /**
            * A waypoint along a tracked route
            */
            class NodeSource {
                /**
                * Constructs the object.
                *
                * @param      {array}   coordinates  The wp's coordinates as [lng,lat]-array
                * @param      {string}  id           The wp's identifier on maps
                * @param      {string}  routeid      The wp's identifier
                * @param      {string}  props        Descriptive wp-properties
                */
                constructor(coordinates, id, routeid, props) {
                    // if (!id) id = "wp";
                    this.id = id;
                    this.type = "Feature";
                    this.geometry = {
                        "type": "Point",
                        "coordinates": coordinates
                    }

                    if (!props) props = {};
                    props.id = id;
                    props.routeid = routeid;
                    // props.title = id;
                    if (!props.icon) props.icon = "dot-10";
                    this.properties = props;
                };
            };

            /**
            * A route-segment between two nodes (way- or track-points)
            */
            class LegSource {
                /**
                * Constructs the object.
                *
                * @param      {array}  coordinates  The coordinates of the legs start/stop
                */
                constructor(coordinates) {
                    this.type = "Feature";
                    this.geometry = {
                        "type": "LineString",
                        "coordinates": coordinates
                    }
                    this.properties = {

                    }
                }
            };

            /**
            * A mb-multi-object joining the animation points between multiple waypoints into a mb-geometry   
            */
            class RouteSource {
                /**
                * Constructs the object.
                *
                * @param      {<type>}  legsCoords   CoordinateSet
                * @param      {<type>}  legsData     The data
                * @param      {<type>}  nodes        Nodes or trackpoints
                */
                constructor(routeid, props, legsCoords, legsData, routeNodes) { // coordinates = array of coordinate-arrays (multiLine) 
                    this.id = routeid;
                    this.type = "Feature";
                    this.geometry = {
                        "type": "MultiLineString",
                        "coordinates": legsCoords
                    };

                    /**
                    * Metadata of route-components 
                    */
                    props.routeid = routeid;
                    props.trackid = props.key;
                    props.legs = legsData;
                    props.nodes = routeNodes;

                    // Compile all route-pnts into one list of coordinates, 
                    // usable for trace-extraction
                    /*var trace = [];
                    legsCoords.forEach(function(coords) {
                        trace = trace.concat(coords);
                    });
                    props.trace = trace;*/

                    this.properties = props;
                    // console.log("ROUTE" + routeid, this.properties);
                }
            };

            /**
            * A mapbox-point-feature ilustrationg the track on the map  
            */
            class TrackSource {
                /**
                * Constructs the object.
                * @param      {array}  coordinates   The coordinates
                * @param      {string}  routeid      The identifier of route
                * @param      {string}  props        Some props
                * @return     {mb-feature}  { mapbox point feature }
                */
                constructor(coordinates, routeid, props) {
                    this.id = routeid;
                    this.type = "Feature";

                    this.geometry = {
                        "type": "Point",
                        "coordinates": coordinates
                    };

                    // add variable properties
                    if (!props) props = {};
                    props.id = routeid;
                    if (!props.unitsystem) props.unitsystem = "metric";
                    if (!props.icon) props.icon = "circle-15";
                    props.bearing = 0;
                    props.time = 0;
                    props.speed = 0;

                    this.properties = props;
                }
            };

            /**
            * A route-trace 'behind' the animation-tracker
            */
            class TraceSource {
                /**
                * Constructs a line from the coordinatesets of all legs of a route
                * = list of points the tracker has passed 
                * alternatively "all" or "some only" (sich auflösender kondensstreifen)  
                *
                * @param      {array}  coordinates  The coordinates of the legs start/stop
                */

                constructor(coordinates, routeid, props) {
                    this.id = routeid;
                    this.type = "Feature";

                    // coordinates = [coordinates]; // only  IF geometry.type=="MultiLineString"

                    this.geometry = {
                        "type": "LineString",
                        "coordinates": coordinates
                    }

                    // add variable properties
                    if (!props) props = {};
                    props.id = routeid;
                    props.routeid = routeid;

                    this.properties = props;
                }
            };
        //}

        Polymer({
            is: 'mb-routes',

            properties: {
                /**
                 * Mapbox-js map to place routes on 
                 */
                map: {
                    type: Object
                },
                /**
                 * Basic Info-popup 
                 */
                popup: {
                    type: Object
                },
                /**
                 * Enhanced Info-popup 
                 */
                popupenhanced: {
                    type: Number
                },

                /**
                 * Url to source of trackable routes/waypoints
                 */
                url: {
                    type: String
                },

                /**
                 * AnimationCtrlFlag
                 */
                trackctrl: {
                    type: String,
                    notify: true
                },
                trackctrlsave: {
                    type: Boolean
                },

                /**
                 * Toggles TrackingMap/NorthMap 
                 */
                trackmode: {
                    type: Boolean,
                    value: false,
                    notify: true
                },

                /**
                 * FramePerSecond of animation
                 */
                fps: {
                    type: Number,
                    value: 60
                },
                /**
                 * timescale of animation 
                 */
                timescale: {
                    type: Number,
                    value: 1080
                },


                trackid: {
                    type: String,
                    value: ""
                },

                timer: {
                    type: Object,
                    notify: true,
                },

                trackobj: {
                    type: Object,
                    observer: '_checkTrackobj'
                },

                tracksymbol: {
                    type: String,
                    value: "airport-15"
                },


                // for use in popups !!
                trackinfo: {
                    type: Object,
                    observer: '_checkTrackinfo'
                },


                /**
                 * make status of trackobj avilable to external services 
                 * processing the data for presentation u.ä.  
                 */
                trackdata: {
                    type: Object,
                    notify: true,
                    observer: '_checkTrackdata'
                },

                // INTERNAL variables

                /**
                 * Animation counter
                 */
                counter: {
                    type: Number
                },

                //
                requestframeref: {
                    type: Array,
                    value: []
                },
                /**
                 * { item_description }
                 */
                routedata: {
                    type: Object
                },
                /**
                 * { item_description }
                 */
                routeid: {
                    type: String,
                    observer: 'zoomToRoute'
                },

                // 
                animationSourceData: {
                    type: Object
                },

                /**
                 * default Icon used for wayPoint-mapping
                 */
                wpicon: {
                    value: "lighthouse"
                },
                /**
                 * default Symbol used for trackPoint-mapping
                 */
                trackicon: {
                    value: "harbor"
                },

            },

            behaviors: [
                Polymer.ToolsBehavior,
            ],

            observers: [
                '_animationTimerRefresh(timer.*)',
                '_animationDataSetup(routedata, timer.timescale)',
                '_animationLayersRefresh(map, animationSourceData.*)',
                'trackCtrlAction(trackctrl)',
                'trackOrientationAction(trackmode, trackid, map)',
                'trackInfoOnMap(trackinfo.*)'
            ],

            /**
             * set 'quasiglobal' this-context for recursive calls during animation 
             * and setup track-features
             */
            attached: function() {
                // 1. setup global namespace 
                mba = this;

                // 2. Prepare a "" Info-Popup
                //    to be closed on x-mark
                if (!this.popup) {
                    this.popup = new mapboxgl.Popup({
                        closeButton: true,
                        closeOnClick: false
                    });
                }
            },

            zoomToRoute : function(routeid){
                console.log("zooming to route", routeid);
                this.trackRoutesZoomTo(null, routeid, "ZoomTo")
            },

            // DEBUG-utilities
            _animationTimerRefresh: function(timer) {
                // console.log("checking timer", timer.value, timer);
            },
            _checkTrackdata: function(data) {
                //console.log("checking trackdata", data);
            },
            _checkTrackobj: function(trackobj) {
                // console.log("New TRACK obj", trackobj);
            },
            _checkTrackinfo: function(trackinfo) {
                // console.log("New TRACKinfo", trackinfo);
            },


            // A. 
            // prepare all map- and animationdata required to view tracks on the map 
            //  - for altered routedata
            //  - if basic(=max) timescale of animation changed
            _animationDataSetup: function(routedata, timescale) {
                if (!routedata || !routedata[0] || !routedata[0].nodes) return;
                console.log("ORIGINAL routedata:", routedata);

                this.counter = 0;

                this.trackFeaturesReset();

                this.trackTimerSetup(routedata, timescale);

                console.log("ORIGINAL timer=", this.timer);

                // Order(REIHENFOLGE) important, as wp-reduction in routedata possible during route-setup  

                // OLD 
                // var sourceData = {};
                // sourceData['routes'] = this.setupAnimationRoutes(routedata, this.timer); // console.log("checked route-data", routedata);
                // sourceData['traces'] = this.setupAnimationTraces(routedata, this.timer);
                // NEW                 
                sourceData = this.setupAnimationRoutes(routedata, this.timer); // console.log("checked route-data", routedata);

                sourceData['nodes'] = this.setupAnimationNodes(routedata); // wayPoints or trackPoints

                sourceData['tracks'] = this.setupAnimationTracker(routedata, this.timer);

                // console.log("AnimationData Ready", sourceData, routedata);

                // Doubled assignment of sourceData to trigger multi-parameter observer 
                this.animationSourceData = {};
                this.animationSourceData = sourceData; // triggers "refresh-action
            },

            /**
             * Refresh map-features for changed content (routed Data)
             *
             * @param      {object}  layerObjects  The layerObjects to 
             * @param      {object}  map           The map to show routetracker
             */
            _animationLayersRefresh: function(map, layerObjects) {
                var debounceTime = 200;

                this.debounce('tomap', function() {
                   
                    if (layerObjects.path == 'animationSourceData') layerObjects = layerObjects.value;
                    if (!layerObjects || !Object.keys(layerObjects).length) return;

                    // console.log("SETTING RouteLayers inTo Map: ", layerObjects);
                    var layerObject, layerData, layerSource, layer;

                    // 1. Create/Refresh json-based layers (sources and layers)
                    //    (of tracking-layers)     

                    var layernames = Object.keys(layerObjects);
                    layernames.forEach(function(layername, j) {

                        layerObject = layerObjects[layername];

                        if (layerObject && layerObject['data']) {
                            // console.log("addToMap:" + layername, layerObject);

                            layerData = layerObject['data'];

                            // 1.A. (Re)Set datasources
                            layerSource = map.getSource(layername);

                            if (!layerSource) {
                                map.addSource(layername, {
                                    "type": "geojson",
                                    "data": layerData
                                });
                                layerSource = map.getSource(layername);
                            } else {
                                layerSource.setData(layerData);
                            }

                            // 1.B. Create layers 
                            if (!map.getLayer(layername)) {
                                // console.log("Adding layer", layername, layerObject['layer'], map.getSource(layername));

                                var bl = layerObject['layer'];
                                var bgl = layerObject['bglayer'];
                                var sls = layerObject['selectlayer'];
                                // console.log("ADD layers of [" + layername + "]: src,bl,bgl,sls", layerSource, bl, bgl, sls);

                                // OPTIONAL: bglayer(s) of the same source
                                if (bgl) {
                                    // console.log("adding bg-layer of "+layername, bgl);
                                    // sls.forEach(function(sl) { // console.log("sl",sl);
                                    map.addLayer(bgl);
                                    // }
                                }

                                // BASIC layer
                                map.addLayer(bl);

                                // OPTIONAL: selectlayer of the same source
                                if (sls && sls.length) {
                                    sls.forEach(function(sl) { // console.log("sl",sl);
                                        map.addLayer(sl);
                                        map.setFilter(sl.id, ["==", "id", ""]);
                                    })
                                }
                            }

                            if (layername == "routes") { // primary zoom
                                mba.trackRoutesZoomTo(layerData.features);
                            }
                        }

                    });

                    // 3. Start-action(s) 

                    this.counter = 1;

                    // 4. Setup Events to query track-features on "mouseover" and show info-popup 

                    map.on('mousemove', function(e) {
                        // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                        mba.trackObjSelect(e);
                    });

                    map.on('click', function(e) {
                        // document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);
                        mba.routeNodeSelect(e);
                    });

                    map.on('movestart', function(e) {
                        //console.log("e-start",e);
                        this.debounce('movestart', function() {
                            mba.trackctrlsave = false;
                            if (mba.trackctrl) {
                                mba.trackctrlsave = true;
                                mba.trackctrl = false;
                                console.log("track-animation STOPPED at map move start");
                            }
                        }, 200);
                    }.bind(this));

                    map.on('moveend', function(e) {
                        this.debounce('moveend', function() {
                            if (mba.trackctrlsave) {
                                mba.trackctrlsave = false;
                                mba.trackctrl = true;                                
                                console.log("track-animation RESTARTED at map move end");
                            }
                        }, 300);
                    }.bind(this));

                    // Update visible tracking content at start-time  
                    mba.animationMapRefresh(mba.timer["start"], "FIRST START");

                }, debounceTime);
            },

            // B. TrackCtrls

            /**
             *  event-action after ...
             *
             * @param      {<type>}  trackctrl  The trackctrl
             */
            trackCtrlAction: function(trackctrl) {
                var ctrlflag = "STOP";

                if (trackctrl) {
                    console.log("trackCtrlActn:", typeof trackctrl, trackctrl);

                    if (trackctrl == "reset") {
                        // 
                        this.trackctrl = false; // triggers this function (trackCtrlAction) again 
                        this.trackmode = false; // 
                        this.counter = 0;
                        this.trackid = undefined; // z.B. popup.remove();

                        this.trackRoutesZoomTo();

                    } else if (typeof trackctrl == "number") {

                        var mapTime = trackctrl;
                        if (this.trackStepAction(null, mapTime)) {
                            // console.log("manually set ctrltime[h]=", trackctrl)
                        };

                    } else {
                        ctrlflag = "START";
                    }

                } else {

                    if (this.counter) {
                        var trackObjs = [];
                        if (this.map) trackObjs = this.map.querySourceFeatures({
                            layers: ['tracks']
                        });
                        // console.log("STOPPED track at cnt=" + this.counter + " with objs", trackObjs);
                    }
                }

                if (this.counter == 0) {
                    // Reset to START
                    console.log("Reset tracking objects");

                    this.setupAnimationRoutes(this.routedata, this.timer);
                    // Set the coordinates of the tracker and traces back to origin
                    this.setupAnimationTracker(this.routedata, this.timer);
                    //this.setupAnimationTraces(this.routedata, this.timer);

                    this.map.getSource('routes').setData(this.routes);
                    this.map.getSource('tracks').setData(this.tracks);
                    this.map.getSource('traces').setData(this.traces);
                }

                this.trackStepAnimation(ctrlflag);
                // *******************************
            },

            /**
             *   switch euler/lagrange
             */
            trackOrientationAction: function(trackmode, trackid, map) {

                // No trackmode if no trackObj selected
                if (trackmode && !trackid) {
                    var msg = "<b>Object</b> must be activated to track!"
                    this.onMapPopup(msg);

                    this.trackmode = false; // set to base 
                    return;
                }

                var zoom = map.getZoom();
                // zoom = Math.round(zoom); // may cause irritation

                if (trackmode) {

                    var trackobj = this.trackobj,
                        cc = trackobj.geometry.coordinates;

                    bearing = trackobj.properties.bearing;
                    console.log("Aligning map with bearing of", trackobj.properties.id);

                    if (zoom < 4) zoom = 4;
                    map.flyTo({
                        center: cc,
                        bearing: bearing,
                        zoom: zoom
                    });

                } else {

                    bearing = 0;
                    if (zoom > 4) zoom = 4;

                    map.easeTo({
                        bearing: bearing,
                        zoom: zoom
                            //speed: 0.2, // make the easeMove slower
                            //curve: 1,   // change the speed at which it changes zoom
                    });
                }

            },

            // C. TrackStep-Animation 

            /**
             * 
             */
            trackStepAnimation: function(flag) {
                if (!mba) return;
                var rfr = mba.requestframeref;
                // console.log("CTRL " + flag, rfr, "timer=", mba.timer);
                if ( rfr && rfr.length) {
                    rfr.forEach(function(r){
                        cancelAnimationFrame(r);
                    })
                }
                if (flag == "STOP") {
                    return;
                }
                // console.log("CTRL "+flag, mba.requestframeref);
                mba.requestframeref = [];
                let timer = mba.timer;
                if (timer.fps && (timer.fps < 60)) { // Recall with DELAY-Option (SLOMO)
                    setTimeout(function() {
                        mba.requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                    }, 1000 / timer.fps);
                } else { // system-based Recall-frequency 
                    mba.requestframeref.push(requestAnimationFrame(mba.trackStepContainer));
                }
            },

            /**
             * Container to be called by requestAnimationFrame 
             */
            trackStepContainer: function() {

                var timer = mba.timer;
                
                if (!timer) {
                    mba.onMapPopup("OOPS. TrackTimer n.a.");
                    mba.trackctrl = false;
                    return;
                }
                var tracks = mba.tracks;
                if (!tracks || !tracks.features) {
                    mba.onMapPopup("OOPS. TrackData n.a.");
                    mba.trackctrl = false;
                    return;
                }

                // A. Animation ACTION 
                // Calculate track geometries at new positions 
                // based on counter denoting the index to access the route-position.

                var mapTime = (timer["start"]) + (mba.counter * timer.frametime / 3600);

                // ******************************
                var located = mba.trackStepAction(mba.counter, mapTime);
                // ******************************

                // B. Transfer to map 

                if (!located) {

                    var t_msg = mba.logTime(mapTime * 3600 * 1000),
                        s = mba.getNextStart(mapTime);

                    if (s) { 
                        ds = s - mapTime,
                        ds_msg = mba.deltaT(ds, "");
                        msg = "NextStart at: " + mba.logTime(s * 3600 * 1000) + "<hr>CntDwn: " + ds_msg;
                    } else {
                        msg = "IDLE: " + t_msg;
                    }

                    mba.onMapPopup(msg);

                } else {
                    // mba.map.getSource('tracks').setData(mba.tracks);
                }

                // C. Request the next frame of animation 
                mba.counter = mba.counter + 1;

                // D. Animation RECALL 
                if (mba.trackctrl) {
                    mba.trackStepAnimation("CONT");
                }
            },

            /**
             * Actions connected with every Animationstep 
             *
             * @param      {number}  counter  The animation-counter
             * @return     {number}  number of trackObjects visible after counter
             */
            trackStepAction: function(counter, mapTime) {
                // Function ctrls 
                // - the location of trackObjects 
                // - the visibility (via Refresh of animationMap)  and  
                // at the mapTime (related to "counter")     
                var timer = mba.timer,
                    map = mba.map,
                    located = 0,
                    mapMsg = "",
                    tracetemplates = {};
                // Optional trace-templates 
                if (timer.traces) tracetemplates = timer.traces;

                // A.0 Sync alternative timing sources 
                // 
                if (counter && !mapTime) {
                    mapTime = (timer["start"]) + (counter * timer.frametime / 3600);
                }

                if (!counter && mapTime) {
                    // counter = (mapTime - timer["start"]) / (timer.frametime / 3600);
                    counter = (mapTime - timer["start"]) * 3600 / timer.frametime;
                    counter = Math.round(counter);
                    // console.log("mapTime=" + mapTime + ":", "cnt=" + counter);
                    mba.counter = counter;
                    mapMsg += "mapTIME"
                }

                // A.1 Timesignal for other elements 
                mba.set('timer.time', mapTime);
                // ****************************

                // A.2 Integrated RESET-function 
                //     after setting the animation-starttime
                if (counter == 0) {
                    mba.trackRoutesZoomTo();
                }

                // B. RECALCULATE the srces of those trackObjects/trackTraces 
                //    whose start and stop imbed actual mapTime  
                mba.tracks.features.forEach(function(trackObj, j) {

                    // !!! routes and tracks(Objs) are linearely structured 
                    //     "in-sync" referenced through the same index j  
                    var route = mba.routes.features[j],
                        trackTrace = mba.traces.features[j];
                    //  ************************************
                    
                    var routeProps = route.properties,
                        routeid = routeProps.id,
                        legdata = routeProps.legs,
                        routeStartCounter = routeProps.startCounter;
                        
                    var tracetemplate = tracetemplates[routeid];

                    if (mapTime > routeProps.stop) { // A. BREAK "" after end of this route 

                        if (routeStartCounter != null) { // must be valid for 0 too
                            routeProps.startCounter = null;

                            // NOPE : kill visible route-trace 
                            // trackTrace.geometry.coordinates = [];
                            mapMsg += ",STOP:" + routeid;
                        }

                    } else if (mapTime >= routeProps.start) { // B.     

                        if (routeStartCounter == undefined) { // 
                            // FIRST access to this route during animation
                            // legStartAt = counter - 1;
                            // mba.trackRoutesZoomTo();

                            routeStartCounter = Math.round((routeProps.start - (timer["start"])) / (timer.frametime / 3600));

                            routeProps.startCounter = routeStartCounter;
                            mapMsg += ",START:" + routeid;
                        }

                        var legStartAt = routeStartCounter;

                        var typ = route.geometry.type,
                            legCoordSet = route.geometry.coordinates;

                        if (typ == "MultiLineString") { // multiple legs
                        } else { // one leg only 
                            legCoordSet = [legCoordSet];
                        }

                        // Iterate along the route-legs until the track-counter is located within one. 
                        // Get legInfo and cc of the leg selected.

                        var legInfo, cc;

                        legCoordSet.every(function(legPositions, i) {
                            // return true if xxx, false if xxx

                            if (counter < (legStartAt + legPositions.length)) {
                                cc = legPositions[counter - legStartAt];
                                // *************************************
                                if (cc) {
                                    legInfo = legdata[i];
                                    return false;
                                }
                            }

                            legStartAt = legStartAt + legPositions.length;
                            return true; // wichtig !!
                        })

                        // Update the trackObj-properties according to its location on the route
                        if (cc) {
                            // console.log("route:"+routeid, legStartAt, counter,  mapTime, cc);
                            located += 1;

                            // A.1 MOVE the trackObject 
                            trackObj.geometry.coordinates = cc;

                            // A.2 EXTEND/MOVE the trackTrace 
                            if (tracetemplate) {
                                var startTime = timer.routes[routeid].start,
                                    traceCounter = Math.round((mapTime - startTime) / (timer.frametime / 3600)),
                                    first = traceCounter < 100 ? 0 : traceCounter - 100,
                                    last = traceCounter;
                                // console.log(routeid, counter, traceCounter, first, last);

                                var traceCoords = tracetemplate.slice(first, last);

                                trackTrace.geometry.coordinates = traceCoords;
                            }

                            // B. Eval STATUS between 2 animation-points 

                            if (trackObj.properties.lastPos) {
                                mba.trackStepStatus(trackObj, legInfo, mapTime);
                            }

                            // C. SYNC content (and location) of the info-popup 
                            //    if trackObj is selected as "tracked Object" 

                            if (mba.trackid == trackObj.properties.id) {

                                // REFRESH trackdata to trigger INFO-element(-popup) 
                                mba.trackdata = {
                                    "id": mba.trackid,
                                    "lnglat": cc,
                                    "trackobj": trackObj
                                }

                                // in track-align map-orientation 
                                // the map is continuously centered at trackObj 
                                // and the trackObj-symbol is aligned to bearing

                                if (mba.trackmode) {
                                    let map = mba.map;
                                    map.easeTo({
                                        center: cc,
                                        bearing: trackObj.properties.bearing,
                                    });
                                    map.setLayoutProperty('tracks-select', 'icon-rotate', 0);

                                } else {
                                    // align selected tracksymbol along bearing
                                    map.setLayoutProperty('tracks-select', 'icon-rotate', trackObj.properties.bearing);
                                }
                                // 
                                if (trackObj.properties.arrived) {
                                    mba.trackmode = false;
                                }

                            } else {
                                // align all tracksymbols along its bearing
                                // requires filtering of the tracklayer-feature related to trackObj   
                                // map.setLayoutProperty('tracks', 'icon-rotate', trackObj.properties.bearing);
                            }

                            // D. 
                            trackObj.properties.lastPos = cc;
                        }
                    }
                });

                // C. APPLY the updated sources of the animation-layers
                mba.map.getSource('tracks').setData(mba.tracks);
                mba.map.getSource('traces').setData(mba.traces);
                // ************************
                
                // D. 
                if (mapMsg) { // console.log(mapMsg);
                    mba.animationMapRefresh(mapTime, mapMsg);
                    // ********************
                }

                return located;
            },

            // Calc status-parameters at mapTime and save as trackObj-properties
            trackStepStatus: function(trackObj, legInfo, mapTime) {

                var routeunitsystem = trackObj.properties.unitsystem;
                // console.log("trackStepStatus with " + routeunitsystem + " unitsystem from ", legInfo, trackObj);

                trackObj.properties.time = this.logTime(mapTime * 3600 * 1000);

                var cc = trackObj.geometry.coordinates,
                    lastPos = trackObj.properties.lastPos,
                    legTarget = legInfo.to;

                // calc the bearing between "actual" and 'last' Position of trackObj 
                var bearing = turf.bearing(new TrackSource(lastPos), trackObj);
                if (bearing < 0) bearing = bearing + 360;
                if (bearing > 360) bearing = bearing - 360;

                // temporary Leg to calculate DTA
                var legToArrival = new LegSource([cc, legTarget.coords]),
                    dta = turf.lineDistance(legToArrival, "kilometers");

                var v = legInfo.speed,
                    dist = legInfo.dist;

                if (v && Math.round(dta / 10)) {  // TrackObj is "Moving" 
                    // trackObj.properties.stop = 0;
                    var t = dta / parseFloat(v),
                        tta = this.deltaT(t, "Arrived");

                    trackObj.properties.tta = tta;
                    trackObj.properties.bearing = Math.round(bearing); // °
                    trackObj.properties.arrived = null;
                    trackObj.properties.cntdwn = null;

                    if (routeunitsystem == "nautic") {

                        trackObj.properties.speed = Math.round(v / 1.856); // nds
                        trackObj.properties.dist = Math.round(dist / 1.856); // nm
                        trackObj.properties.dta = Math.round(dta / 1.856); // nm

                    } else if (routeunitsystem == "angloamerican") {

                        trackObj.properties.speed = Math.round(v / 1.609); // mph
                        trackObj.properties.dist = Math.round(dist / 1.609); // miles
                        trackObj.properties.dta = Math.round(dta / 1.609); // miles

                    } else {

                        trackObj.properties.speed = Math.round(v); // km/h
                        trackObj.properties.dist = Math.round(dist); // km
                        trackObj.properties.dta = Math.round(dta / 10) * 10; // km
                    }

                } else {      // Resting(pausing) objects 
                    
                    if (!v) trackObj.properties.bearing = 0; // störend on track-animation
                    trackObj.properties.speed = 0;
                    trackObj.properties.dist = 0;
                    trackObj.properties.dta = 0;
                    trackObj.properties.tta = 0;

                    if (legTarget.ab && (legTarget.ab != legTarget.an)) {
                        
                        let stoptime = this.deltaT(legTarget.dep - legTarget.arv, "");
                        let cntdwn = this.deltaT(legTarget.dep - mapTime, ":");
                        
                        trackObj.properties.arrived = "Stopover: " + stoptime;
                        trackObj.properties.cntdwn = cntdwn; 

                    } else {

                        trackObj.properties.arrived = "Arrived !";
                    }
                }
            },


            // D. SETUP elements ctrling and/or illustrating the tracking 

            // Initialisierung der animation-feature(collections)
            trackFeaturesReset: function() {
                var lnames = ["routes", "traces", "tracks", "nodes"];
                // console.log("trackFeaturesReset for objects:", lnames);
                lnames.forEach(function(lname) {
                    if (mba.map.getLayer(lname)) mba.map.removeLayer(lname);
                    if (mba.map.getLayer(lname + "-select")) mba.map.removeLayer(lname + "-select");
                    if (mba.map.getLayer(lname + "-glow")) mba.map.removeLayer(lname + "-glow");
                    if (mba.map.getLayer(lname + "-glow-strong")) mba.map.removeLayer(lname + "-glow-strong");
                    if (mba.map.getLayer(lname + "-bg")) mba.map.removeLayer(lname + "-bg");
                    if (mba.map.getSource(lname)) mba.map.removeSource(lname);

                    this[lname] = {
                        "type": "FeatureCollection"
                    };
                }.bind(this));

            },

            /**
             * Compile a timer from animated routes
             *
             * @param      {Object}  routedata  The routedata
             * @param      {Number}  timescale  The timescale of animation
             * @return     {Object}  Collection of timeCtrls
             */
            trackTimerSetup: function(routedata, timescale) {

                if (!this.timer) this.timer = {};
                this.timer.routes = {};
                this.timer.traces = {};
                // var timer = this.timer ? this.timer : {};

                // A. Setup basic animation-parameters                
                var fpsmax = this.timer.fpsmax ? this.timer.fpsmax : 60; // Animationszeit 1s=6*60s=6min, 10s=1h Echtzeit 
                if (!timescale) timescale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

                // B. Assemble all waypoint-times for every route 
                var wptimer = {};

                routedata.forEach(function(route, j) {
                    // console.log("route-" + j, route);
                    var starts = [],
                        stops = [];

                    route.nodes.forEach(function(wp, p) {
                        if (wp.ab) starts.push(wp);
                        if (wp.an) stops.push(wp);
                    }.bind(this));

                    // Collect 
                    wptimer[route.id] = {
                        "starts": starts,
                        "stops": stops
                    }; // [starts, stops, passes];

                }.bind(this));
                // console.log("trackTimerSetup. timer=", wptimer, routedata); // return;

                // C. Get start&stop times for every route and overall animation period  
                var start, stop;

                Object.keys(wptimer).forEach(function(id) {

                    var starts = wptimer[id]["starts"],
                        stops = wptimer[id]["stops"],
                        wpstart, wpstop, routestart, routestop;

                    if (starts.length) wpstart = starts[0];
                    if (stops.length) wpstop = stops[stops.length - 1];
                    else wpstop = starts[starts.length - 1];

                    routestart = this.utcTime(wpstart.ab, wpstart.coords, "h");
                    routestop = wpstop.an ? wpstop.an : wpstop.ab;
                    routestop = this.utcTime(routestop, wpstop.coords, "h");

                    this.timer.routes[id] = {
                        "id": id,
                        "start": routestart,
                        "stop": routestop,
                        "date": this.logTime(routestart*3600*1000 , "/")
                    };

                    if (!start || (routestart < start)) start = routestart;
                    if (!stop || (routestop > stop)) stop = routestop;

                }.bind(this));
                // console.log("timer for waypoints:", wptimer, timer);

                this.timer["timescale"] = timescale;
                this.timer.frametime = timescale / fpsmax; // Bsp: frametime: 6 s fuer scale = 360 und fps=60 !!

                // ** SET explicitely to notify changes for data-binding 
                this.set("timer.start", start);
                this.set("timer.stop", stop);
                this.set("timer.time", start);

                // D. OPTION: Get a sorted sequence of start-times  
                var routeStarts = {},
                    startTimes = [],
                    routes = this.timer.routes;
                for (let key in routes) {
                    let t = routes[key]["start"];
                    if (t) {
                        if (!startTimes.length || (startTimes[0] <= t)) startTimes.push(t);
                        else startTimes.splice(0, 0, t);
                    }
                }
                this.timer["starts"] = startTimes;
                // console.log("Timer after trackTimerSetup:", this.timer);
            },

            /**
             * { function_description }
             *
             * @param      {<type>}  routedata  The routedata
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupAnimationNodes: function(routedata) {
                // console.log("setupAnimationNodes. srcdata:", routedata);
                this.nodes.features = [];
                var allnodes = this.nodes,
                    nodemetas = {},
                    id;

                routedata.forEach(function(route, j) {
                    // locate trackObj at 'origin'
                    // console.log("route-" + j, route.nodes);
                    route.nodes.forEach(function(wp, p) {
                        var key,
                            coords,
                            newNode,
                            props = {},
                            meta = wp.meta;

                        if (wp.id) key = wp.id;
                        else if (meta && meta.id) key = meta.id;
                        else key = p;

                        allnodes.features.forEach(function(nod) {
                            // do NOT add nodes multiple times (fi airports of different flights)
                            if ((key != p) && (nod.id == key)) {
                                // console.log("doubling routenode", key, route.id);
                                newNode = nod;
                            }
                        });

                        if (!newNode) {
                            if (wp.coords) coords = wp.coords;
                            else if (meta.coords) coords = meta.coords;
                            else key = p;

                            Object.keys(wp).forEach(function(k) {
                                if (k != "coords") props[k] = wp[k];
                            });

                            // console.log("wp-" + p, key, wp, props);
                            newNode = new NodeSource(coords, key, route.id, props);
                            if (wp.meta) {
                                newNode.properties = Object.assign({}, newNode.properties, wp.meta);
                                nodemetas[key] = wp.meta;
                            }

                            allnodes.features.push(newNode);
                        }
                    });

                });
                // console.log("all waypoints collected", allwaypoints.features);

                // Prepare ddr-styling (circle-size of symbol-bg)
                var nodesize = 2,
                    size, smin, smax;
                Object.keys(nodemetas).forEach(function(id) {
                    size = nodemetas[id].size;
                    if (size) {
                        if (!smin || (size < smin)) smin = size;
                        if (!smax || (size > smax)) smax = size;
                    }
                })

                if (smin && smax && (smin < smax)) {
                    nodesize = {
                        property: 'size',
                        stops: [
                            [smin, 4],
                            [smax, 12]
                        ]
                    }
                }

                // 
                var nodeLayer = {};

                nodeLayer['meta'] = nodemetas;

                nodeLayer['data'] = allnodes;

                nodeLayer['layer'] = {
                    "id": "nodes",
                    "type": "symbol",
                    "source": "nodes",
                    "layout": {
                        // "icon-image": "{icon}",
                        "text-field": "{title}",
                        "text-anchor": "bottom",
                        "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                        "text-size": 10,
                        "text-offset": [0, 0.3]
                    },
                };
                // 
                nodeLayer['bglayer'] = {
                    "id": "nodes-bg",
                    "type": "circle",
                    "source": "nodes",
                    "paint": {
                        "circle-radius": nodesize,
                        "circle-opacity": 0.5,
                        "circle-color": "red",

                    }
                };
                //console.log("nodeLayer", nodeLayer);
                return nodeLayer;
            },

            /**
             * create the app-obj for trackLayer
             *
             * @param      {object}  routedata     The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupAnimationTracker: function(routedata, timer) {
                // console.log("routedata at setupAnimationTracker", routedata);
                // the trackLayerObj contains the data, the styling of the baseLayer AND the styling for the selectLayer
                var trackLayerObj = {};
                var tracksymbol = this.tracksymbol;
                if (!tracksymbol) tracksymbol = "airport-15";

                // setup data 
                this.tracks.features = [];
                var allTracks = this.tracks,
                    startort, trackmeta, 
                    props = {},
                    routemetas = {};

                routedata.forEach(function(route, j) {
                    // console.log(route);
                    // Basic properties 
                    trackmeta = route.item;
                    if (!trackmeta) trackmeta = route.meta;
                    if (!trackmeta) trackmeta = route.master;
                    if (!trackmeta) trackmeta = {};
                    trackmeta["id"] = route.id;

                    routemetas[route.id] = trackmeta;
                    // console.log(route,trackmeta);

                    props = {
                        "routeid": route.id,
                        "id": trackmeta.id,
                        "title": trackmeta.id,
                        "unitsystem": route.unitsystem,
                        "bearing": 0,
                        "start": timer.routes[route.id]["start"],
                        "stop": timer.routes[route.id]["stop"]
                    };
                    // Optional: masterdata-properties
                    props["master"] = trackmeta;

                    // Required : icon; 
                    if (trackmeta.icon) props.icon = trackmeta.icon;

                    // Optional: 
                    if (trackmeta.iconsize) props.iconsize = trackmeta.iconsize;

                    // Create Tracker and locate at start 
                    startort = route.nodes[0].coords;

                    var aTrack = new TrackSource(startort, route.id, props);

                    allTracks.features.push(aTrack);

                });

                trackLayerObj['data'] = allTracks;

                // A. Setup ONE Layer for multiple features,
                // = trackers should use "ddr styling" 
                // A. Quick-Mode for Icon and text 
                // B. LUT-Mode for symbol-rotation 
                console.log(routemetas, routedata[0]);

                if (routedata[0].item.icon) {
                    //var symbolrotation = 0;
                    var symbolrotation = {
                            property: 'bearing',
                            stops: [
                                [0, 0],
                                [360, 360]
                            ]
                        };
                    
                    trackLayerObj['layer'] = {
                        "id": "tracks",
                        "source": "tracks",
                        "type": "symbol",

                        "layout": {
                            "icon-image": "{icon}",
                            "icon-rotate": symbolrotation,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        }
                    };

                } else {
                    var symbolcolor = "black";
                    var ddrSymbolcolor = {
                        property: 'id',
                        type: 'categorical',
                        stops: []
                    };

                    Object.keys(routemetas).forEach(function(id) {
                        var col = routemetas[id].color;
                        // if (!col) col = symbolcolor;
                        if (!col) col = this.getRandomColor();
                        ddrSymbolcolor.stops.push([id, col]);
                    }.bind(this))
                    if (ddrSymbolcolor.stops.length) {
                        symbolcolor = ddrSymbolcolor;
                    }

                    trackLayerObj['layer'] = {
                        "id": "tracks",
                        "source": "tracks",
                        "type": "circle",
                        'paint': {
                            'circle-radius': 6,
                            'circle-color': symbolcolor
                        }
                    };
                }

                // B. Setup MULTIPLE Layers to style the InfoTrackObj (app-specific)
                trackLayerObj['selectlayer'] =
                    // A meaningful Symbol built from 3 Layers 
                    [{
                        "id": "tracks-glow-strong",
                        "type": "circle",
                        "source": "tracks",
                        "paint": {
                            "circle-radius": 18,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.6
                        }
                    }, {
                        "id": "tracks-glow",
                        "type": "circle",
                        "source": "tracks",
                        "paint": {
                            "circle-radius": 40,
                            "circle-color": "#ff0",
                            "circle-opacity": 0.2
                        }
                    }, {
                        "id": "tracks-select",
                        "type": "symbol",
                        "source": "tracks",
                        "layout": {
                            "icon-image": tracksymbol,
                            "icon-rotate": 0,
                            "text-field": "{title}",
                            "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                            "text-size": 12,
                            "text-offset": [0, 0.6],
                            "text-anchor": "top"
                        }
                    }];
                // console.log("trackLayerObj", trackLayerObj);
                return trackLayerObj;
            },

            /**
             * Setup routes optimized for animation with "requestAnimationFrame (60 fps)"
             *
             * @param      {<type>}  routedata  The routedata
             * @param      {object}  timer  The animation timer
             * @return     {<type>}  { description_of_the_return_value }
             */
            setupAnimationRoutes: function(routeconfigdata, timer) {
                // console.log("setupAnimationRoutes, configdata:", routeconfigdata);

                this.routes.features = [];
                this.traces.features = [];
                var routemetas = {},
                    rr, r, t, m;

                // A. Interpolate the Routes between waypoints(trackpoints) 
                //    based on info about speed and/or arrival-/departure-times at waypoints
                routeconfigdata.forEach(function(routedata, j) {
                    // console.log("setupAnimationRoute:" + j, routedata);
                    // track-based routes should be preprocessed to minimie gps-noise 
                    if (routedata.trackmode) {
                        routedata = this.trackedDataCheck(routedata, timer);
                    }
                    // **************************
                    rr = this.animationRouteCreate(routedata, timer);
                    // **************************

                    if (rr) {
                        // console.log("route: " + r.id, r);
                        r = rr.routeSrc;
                        t = rr.traceSrc;
                        if (!routedata.meta) routedata.meta = {};
                        if (!routedata.meta.color) routedata.meta.color = this.getRandomColor();
                    
                        m = Object.assign({}, r.properties, routedata.meta);
                        r.properties = m;
                        t.properties = m;
                        routemetas[r.id] = routedata.meta;
                        // console.log("meta,r,t", routedata.meta, r, t);

                        this.routes.features.push(r);
                        this.traces.features.push(t);
                    }

                }.bind(this));
                // console.log("Srces:", this.routes.features, this.traces.features);
                // return;

                // B. STYLING: line-color 
                var linecolor = "#007cbf";
                // optional: ddr-styling based on routestyling
                var ddrLinecolors = {
                    property: 'id',
                    type: 'categorical',
                    stops: []
                };

                if (Object.keys(routemetas).length) {
                    Object.keys(routemetas).forEach(function(id) {
                        var col = routemetas[id].color;
                        if (!col) col = linecolor;
                        if (!col) col = this.getRandomColor();
                        ddrLinecolors.stops.push([id, col]);
                    }.bind(this))
                    linecolor = ddrLinecolors;
                }

                // C. FINALE Objekte
                // C.1 ROUTE
                var routeLayer = {};
                routeLayer['meta'] = routemetas;
                routeLayer['data'] = this.routes;
                routeLayer['layer'] = {
                    "id": "routes",
                    "source": "routes",
                    "type": "line",
                    "paint": {
                        "line-width": 1,
                        "line-opacity": 0.5,
                        "line-dasharray": [4, 4],
                        "line-color": linecolor
                    }
                };

                // C.2 TRACE
                var traceLayer = {};
                traceLayer['meta'] = routemetas;
                traceLayer['data'] = this.traces;
                traceLayer['layer'] = {
                    "id": "traces",
                    "source": "traces",
                    "type": "line",
                    "paint": {
                        "line-width": 2,
                        "line-opacity": 0.5,
                        "line-color": linecolor
                    }
                };
                // RETURN: 
                // console.log("ThemeObjs:", routeLayer, traceLayer);
                return {
                    "routes": routeLayer,
                    "traces": traceLayer
                };
            },

            // Conditional routecreate-action (If a route is based on "trackPoints")  
            trackedDataCheck: function(data, timer) {

                var trackpoints = [],
                    routeNodes = data.nodes, // waypoints/trackpoints 
                    frametime = timer.frametime,
                    deltaX = 10, // stdDev of device
                    legspeed, legTimeSec, wp, nextNode;
                // console.log("original trackpoints", routeNodes);
               
                var p = 0;
                while (p < routeNodes.length) {
                    wp = routeNodes[p];
                    i = 1;
                    while (i > 0) {

                        nextNode = routeNodes[p + i];
                        // Calculate leg-properties
                        if (nextNode) {
                            // console.log("routeNodes:" + p, wp, nextNode);
                            // A. Check 
                            if (nextNode.an && wp.ab) {
                                let dep = mba.utcTime(wp.ab, wp.coords, "s"),
                                    arv = mba.utcTime(nextNode.an, nextNode.coords, "s");
                                legTimeSec = (arv - dep);
                            } else {
                                legTimeSec = wp.stopover;
                            }

                            // CHECK time-diff between wps
                            // ABANDON wp, if smaller then timeframe 
                            if (legTimeSec > frametime / 2) {
                                // B. Check DIST between routeNodes
                                //    ABANDON wp, if smaller then deltaX
                                var leg = new LegSource([wp.coords, nextNode.coords]),
                                    legDistance = turf.lineDistance(leg, 'kilometers'),
                                    legDistMeters = Math.round(legDistance * 1000);

                                if (legDistMeters > deltaX) {

                                    // Time and number of animation-steps to travel between routeNodes in legTimeSec
                                    // legTimeSec = legDistance / legSpeed * 3600;
                                    legStepCount = Math.round(legTimeSec / frametime);

                                    // console.log("leg-data ", "dx=" + legDistance, "dt=" + legTimeSec, "steps=" + legStepCount); // , frametime);
                                    // return;
                                    p = p + i;
                                    trackpoints.push(wp)
                                    i = 0;

                                } else {
                                    i = i + 1;
                                }

                            } else {
                                i = i + 1;
                            }

                        } else {
                            p = routeNodes.length;
                            i = 0;
                        }
                    }
                }

                if (nextNode) trackpoints.push(nextNode);
                // console.log("checked trackpoints", trackpoints);
                data.nodes = trackpoints;
                return data;
            },

            /** Basic routeCreate-action   
             * 
             * compile coords of all route-legs into one coordinatecollection 
             */
            animationRouteCreate: function(data, timer) {
                // console.log("Initialize route from", data, timer);

                var demoSpeed = 900;
                var frametime = timer.frametime;

                var nextNode, legDistance, legStepCount;

                var routeid = data.id,
                    legsData = [], // mean props of every leg    
                    legsCoords = [], // coords of every leg
                    legTimeSec, legStopSec,
                    legSpeed, routeSpeed = data.speed;

                if (!routeSpeed) routeSpeed = demoSpeed;

                var props = {
                    "id": routeid,
                    "speed": routeSpeed,
                    "start": timer.routes[routeid]["start"],
                    "stop": timer.routes[routeid]["stop"]
                };
                // console.log("Initialize route from", data, timer, props);

                // Create route-legs between 2 waypoints at any one time 
                var routeNodes = data.nodes; // wps as given

                routeNodes.forEach(function(wp, p) {

                    legStopSec = 0;
                    nextNode = routeNodes[p + 1];
                    // Calculate leg-properties
                    if (nextNode) {
                        // console.log("waypoints:" + p, wp, nextNode);
                        // Calculate the distance in kilometers between waypoints
                        var leg = new LegSource([wp.coords, nextNode.coords]),
                            legDistance = turf.lineDistance(leg, 'kilometers');

                        // legDistance = Math.round(legDistance);

                        // Calculate a mean leg-speed between wp's with ab/an times
                        legSpeed = routeSpeed;
                        if (nextNode.an && wp.ab) {
                            let dep = mba.utcTime(wp.ab, wp.coords, "h"),
                                arv = mba.utcTime(nextNode.an, nextNode.coords, "h");
                            legSpeed = legDistance / (arv - dep);
                            nextNode.arv = arv;
                        } else if (nextNode.speed) {
                            legSpeed = nextNode.speed;
                        }
                        // legSpeed = Math.round(legSpeed);
                        //console.log("leg-speed-calc", legDistance, legSpeed, nextNode, wp);

                        // Calculate arv and dep at "stopover"
                        if (nextNode.an && nextNode.ab) {
                            let arv = mba.utcTime(nextNode.an, nextNode.coords, "h"),
                                dep = mba.utcTime(nextNode.ab, nextNode.coords, "h");
                            legStopSec = (dep - arv) * 3600;
                            nextNode.arv = arv;
                            nextNode.dep = dep;
                        } else if (nextNode.stopover) {
                            legStopSec = nextNode.stopover;
                        }
                        // 3. Calc leg-animation 

                        // Time and number of animation-steps to travel between waypoints in legTimeSec
                        legTimeSec = legDistance / legSpeed * 3600;
                        legStepCount = Math.round(legTimeSec / frametime);

                        // console.log(p + ". leg-data for dx=" + legDistance, "n=" + legStepCount);

                        // Assign basic leg-properties
                        var legInfo = {};
                        legInfo.from = wp;
                        legInfo.to = nextNode;

                        legInfo.dist = legDistance;
                        legInfo.speed = legSpeed;

                        legInfo.time = legTimeSec;
                        legInfo.steps = legStepCount;

                        // Assign time-properties
                        var h = Math.floor(legTimeSec / 3600),
                            m = Math.round((legTimeSec - (h * 3600)) / 60);
                        legInfo.timetext = h + "h" + m + "min";

                        // Insert animation-positions along the leg
                        var startPosition = 0;
                        var legPositions = [];

                        for (let i = 0; i < legStepCount; i++) {
                            let dist = i * (legDistance / legStepCount);
                            let position = turf.along(leg, dist, 'kilometers');
                            legPositions.push(position.geometry.coordinates);
                        }

                        // 4. Append "STOPOVER-animation" 
                        //    into 
                        if (legStopSec) { // INSERT some "zero-steps" at stopover waypoint 
                            // console.log("INSERT STOPover at ", nextNode, legStopSec);
                            h = Math.floor(legStopSec / 3600);
                            m = Math.round((legStopSec - (h * 3600)) / 60);
                            legInfo.stopTime = h + "h" + m + "min";
                            var n = Math.round(legStopSec / frametime);
                            legInfo.stopSteps = n;
                            // append the "stop-coordinates" to the leg 
                            for (let i = 0; i < n; i++) {
                                legPositions.push(legPositions[legPositions.length - 1]);
                            }
                        }

                        // 4. Compile leg-data in route-collections of legs  
                        // console.log("leg-data ", legInfo, legPositions);
                        legsData.push(legInfo);
                        legsCoords.push(legPositions);
                    }
                });

                // A. Create route-object consisting of 1-n legs
                var rSrc = new RouteSource(routeid, props, legsCoords, legsData, routeNodes);

                // B. Save the complete trace of a route as template for dynamic traces 
                var coordinates = [];
                legsCoords.forEach(function(legcoords) {
                    coordinates = coordinates.concat(legcoords);
                });
                timer.traces[routeid] = coordinates;

                // Create "complete" trace-object with startpoint only
                // var tSrc = new TraceSource(coordinates, routeid);
                // Create "initial" trace-object with startpoint only
                var tSrc = new TraceSource(coordinates.slice(0, 1), routeid);

                // console.log("New routeSrces: " + routeid, rSrc, tSrc);
                return {
                    "routeSrc": rSrc,
                    "traceSrc": tSrc
                };
            },

            // E. Additional Functions

            // SYNC visibility at "mapTime"
            // of TrackObjects and related map-layers 
            animationMapRefresh: function(mapTime, syncflag) {

                var stopDelay = 2000; // time to let last situation "visible" before reset 

                // TIME filter: applied, on every maptime ??
                function applyTrackFilter(mapTime, flag) {
                    if (!flag) flag="noflag";

                    var routeids = [], routeid;

                    // A. Apply TIME-FILTER on "ALL" trackObjects 
                    //    with start- and stop-properties  
                    //    (is applied on sourcedata)

                    var startstopfilter = [
                        'all', ['<=', 'start', mapTime],
                        ['>=', 'stop', mapTime]
                    ];

                    // A.1. Filter the visibility of tracks-theme-elements on map
                    mba.map.setFilter('tracks', startstopfilter);
                    
                    // A.2 Query the Features 
                    var trackObjs = this.map.querySourceFeatures("tracks", {
                        filter: startstopfilter
                    });

                    if (!trackObjs.length) {

                        var msgTime = mba.logTime(mapTime * 3600 * 1000),
                            nextTime = mba.getNextStart(mapTime);

                        if (!nextTime) {  // CHECK for STOP
                            // B.1 No trackfeature defined for filtertime
                            //  STOP animation, if no further track-Start is pendig 
                            
                            mba.trackctrl = false;
                            mba.trackmode = false;
                            let msg = "STOPPED. No more data after: " + msgTime; 
                            
                            // console.log(msg);
                            mba.onMapPopup(msg);
                            
                            // Triggers view of all routes after Animation-STOP
                            trackObjs = this.map.querySourceFeatures("tracks", {
                                filter: null
                            });
                            
                        } else {
                            // B.2 
                            let msg = msgTime +". WAITING for next track at: " + mba.logTime(nextTime * 3600 * 1000); 
                            // console.log(msg);
                        }

                    } 
                    
                    // B.2 Some trackObjs animated at filter-time  
                    if (flag.indexOf('TIME') >= 0) {
                        // console.log("trackObjs filtered at ", msgTime, trackObjs, startstopfilter);
                    }

                    // C. Get route-ids of active trackers
                    //    to prepare SECONDARY FILTER 
                    //    to Sync the filters for "related" layers (traces, routes, waypoints)  

                    // collect ROUTES of all actually "active" trackObjs    
                    trackObjs.forEach(function(to) {
                        routeid = to.properties.routeid;
                        if (routeid) routeids.push(routeid);
                    });

                    // remove possible "DUPLICATES" ? 
                    routeids = routeids.filter(function(item, pos, self) {
                        return self.indexOf(item) == pos;
                    })

                    // CTRL-Msg
                    var msgTime = mba.logTime(mapTime * 3600 * 1000, "_"),
                        info = flag.substring(0,15) + "...",
                        msg = "<b>" + info + "</b>" 
                            + "<br> at " + msgTime 
                            + "<br>" + routeids.length + " track(s) active";
                    mba.onMapPopup(msg);

                    return routeids;
                };

                // Always apply syncfilter "immediately"
                // BUT "stopfilter" after some "stopDelay"
                // to let user observe arrived tracker during this delay before removing the tracker and related features 

                // 1. Optional BREAK! 
                // Sync trackObjects(and it's routes) only as long as they are tracked 
                if (!mba.map.getLayer("tracks")) {
                    var syncTime = this.logTime(mapTime * 3600 * 1000),
                        msg = "<b>No trackers on map to track</b>" + " at " + syncTime;
                    mba.onMapPopup(msg);
                    return;
                }

                // 2. Additional HIDE-Filters after STOP-action
                if (syncflag && syncflag.indexOf("STOP") >= 0) {
                    // B. Apply "empty mapTime-Filter" on trackLayers after stopDelay  
                    setTimeout(function() {
                        // A. HIDE the SELECT-Track-symbols
                        mba.map.setFilter("tracks-select", ["==", "id", ""]);
                        mba.map.setFilter("tracks-glow", ["==", "id", ""]);
                        mba.map.setFilter("tracks-glow-strong", ["==", "id", ""]);
                    }, stopDelay);
                    // return;
                }

                // 3. Apply filter for All other flags but STOP 
                
                var trackids = applyTrackFilter(mapTime, syncflag);

                this.animationThemesRefresh(trackids);
                // **********************
            },

            // SYNC "related" animationLayers
            animationThemesRefresh: function (routeids) {
                // Filter  mapFeatures "related"  to animating trackers 
                // or none 
                // or all 
                var syncFilter = ["in", "routeid"],
                    msg = 0,
                    mapTime = mba.timer.time;

                if (typeof routeids == "string") { // select one or none ("") 
                    msg = routeids;
                    if (routeids=="none") {
                        syncFilter.push(""); 
                    } else if (routeids=="all") {
                        syncFilter=null; 
                    }   else {
                        syncFilter.push(routeids);
                        if (routeids) msg = 1;
                    }
                } else if (!routeids || !routeids.length) { // select all
                    //syncFilter = null; //n = "all";
                    syncFilter.push("");
                    msg = "none";                        
                } else {
                    // syncFilter = syncFilter.concat(routeids);
                    routeids.forEach(function(id) {
                        syncFilter.push(id);
                    });
                    msg = routeids.length;
                }
                // console.log("Refreshed SYNC-Filter at "+mapTime, "for ["+msg+"] track(s)") ; // syncFilter);

                if (mba.map.getLayer("nodes")) {
                    mba.map.setFilter('nodes', syncFilter);
                    mba.map.setFilter('nodes-bg', syncFilter);
                }

                if (mba.map.getLayer("traces")) {
                    let traceFilter = syncFilter;
                    mba.map.setFilter('traces', traceFilter);
                    var traceFeatures = this.map.querySourceFeatures("traces", {
                        filter: traceFilter
                    });
                    // console.log("SYNCED Trace-Layer", JSON.stringify(traceFeatures, null, 2), mba.map.getLayer("traces"), mba.map.getSource("traces"));
                }

                if (mba.map.getLayer("routes")) {

                    mba.map.setFilter('routes', syncFilter);
                    var routeFeatures = this.map.querySourceFeatures("routes", {
                        filter: syncFilter
                    });
                    // console.log("SYNCED Route-Layer", routeFeatures);

                    // ADDITIONAL/OPTIONAL Zoom after active routeset has changed 
                    if (0) {
                        mba.trackRoutesZoomTo(routeFeatures,null,syncFilter);
                    }
                }
            },

            // Zoom to bbox of all raw route-nodes (waypoints, trackpoints) 
            // 
            trackRoutesZoomTo: function(routeFeatures, routeid, msg) {
                if (!msg) msg = "Route-Feature-Zoom.";
                if (!routeFeatures) {
                    var bboxfilter = null; // ""; 
                    if (routeid){
                        bboxFilter = ["in", "routeid", routeid];
                    } else {
                        console.log("queryAll");
                    }
                    console.log("trackRoutesZoomDTo", routeid, bboxFilter);
                    routeFeatures = this.map.querySourceFeatures("routes", {
                        filter: bboxFilter
                    });
                }
                if (!routeFeatures || !routeFeatures.length) {
                    console.log("BREAK. Route-Layer-Zoom. No features selected"); 
                    return;
                }
                console.log(msg, routeFeatures.length, routeFeatures); // , mba.map.getSource("routes").getCoordinates());

                var bb = mba.featureBounds(routeFeatures);
                if (bb) {
                    console.log("Zoom to bbox:", bb);
                    mba.map.fitBounds(bb, {
                        padding: 20
                    });
                }
            },

            // Check if more starts 
            getNextStart: function(mapTime) {
                var starts = mba.timer.starts,
                    nextStart;
                if (!starts) return; 
                starts.some(function(start) {
                    if (mapTime < start) {
                        nextStart = start;
                        return true;
                    }
                }); 
                if (nextStart) // console.log("t=", mapTime, "nextStart=" + nextStart, starts);
                return nextStart;
            },

            // updates "onMapPopup" if a trackinfo-property changes
            trackInfoOnMap: function(trackinfo) {
                if (!trackinfo.value) return;

                trackinfo = trackinfo.value;
                this.onMapPopup(trackinfo);
            },

            // Refresh the conteht&location of an app-specific mapbox-popup 
            // default: html at map-center  
            onMapPopup: function(popupcontent) {
                var html, lnglat;

                if (typeof popupcontent == "object") {
                    html = popupcontent.html;
                    lnglat = popupcontent.lnglat;
                } else if (popupcontent) {
                    html = popupcontent;
                } 
                if (!popupcontent || !html) {
                    if (mba && mba.popup) mba.popup.remove;
                    return;
                }

                if (mba && mba.map) { //  console.log("check popup", mba.popup)
                    
                    if (!lnglat) lnglat = mba.map.getCenter();

                    if (!mba.popup.isOpen()) mba.popup.addTo(mba.map);

                    mba.popup
                        .setLngLat(lnglat)
                        .setHTML(html);
                }
            },

            /**
             * Activate a trackObject,  on mouse-over ;selected by gui-event e (mode-over, click, ...) 
             */
            trackObjSelect: function(e) {
                // console.log("mousemove-event", e);
                var features = [];

                if (map.getLayer('tracks') || map.getLayer('tracks-select')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['tracks', 'tracks-select']
                    });
                }

                if (!features || !features.length) return;

                // Alternative for nodes
                if (!features.length) {

                    // Check waypoints/trackpoints    
                    if (map.getLayer('nodes')) {
                        features = map.queryRenderedFeatures(e.point, {
                            layers: ['nodes']
                        });
                    }
                    // popup-strategy 1: 
                    // Remove popup if pointer not on any feature
                    // this.popup.remove();
                    let wp = features[0];
                    if (this.wpid != wp.properties.id) {
                        this.wpid = wp.properties.id;
                        var msg = "WP/TP " + wp.properties.ab;
                        this.onMapPopup(msg); // console.log(msg, wp);
                    }
                    return;
                }

                // NO action if INFO already visible
                if (mba.trackid == features[0].properties.id) {
                    return;
                }

                // Update GLOBAL objects
                mba.trackobj = features[0];
                mba.trackid = mba.trackobj.properties.id;

                map.setFilter("tracks-select",      ["==", "id", mba.trackid]);
                map.setFilter("tracks-glow",        ["==", "id", mba.trackid]);
                map.setFilter("tracks-glow-strong", ["==", "id", mba.trackid]);

                // Change the cursor style as a UI indicator.
                // map.getCanvas().style.cursor = 'pointer';

                // popup-strategy 2: 
                // Update and reconnect the this.popup to the map at new object
                mba.popup.remove();

                // Trackdata with "Override dirty checking" 
                if (mba.trackobj) {
                    mba.trackdata = {
                        "lnglat": mba.trackobj.geometry.coordinates,
                        "trackobj": mba.trackobj,
                        "open": true
                    }
                }
            },

            /*
             *   get wp-(tp-) info on CLICK-query
             */
            routeNodeSelect: function(e) {
                // Check waypoints(trackpoints)    
                if (map.getLayer('nodes')) {
                    features = map.queryRenderedFeatures(e.point, {
                        layers: ['nodes']
                    });
                }
                if (!features.length) return;
                // popup-strategy 1: 
                // Remove popup if pointer not on any feature
                // this.popup.remove();
                let wp = features[0];
                if (this.wpid != wp.properties.id) {
                    this.wpid = wp.properties.id;
                    var msg = "WP/TP " + wp.properties.ab;
                    this.onMapPopup(msg); // console.log(msg, wp);
                }
                return;
            }
        });
    </script>

</dom-module>