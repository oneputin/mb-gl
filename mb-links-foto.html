<link rel="import" href="../polymer/polymer.html">

<link rel="import" href = "../iron-flex-layout/iron-flex-layout.html">

<link rel="import" href = "../paper-icon-button/paper-icon-button.html">
<link rel="import" href = "../iron-collapse/iron-collapse.html">
<link rel="import" href = "../paper-item/paper-item.html">
<link rel="import" href = "../paper-listbox/paper-listbox.html">
<link rel="import" href = "../iron-icons/iron-icons.html">

<!--GIA-->
<link rel="import" href = "../files-input/files-input.html">
<link rel="import" href = "../image-meta/exif-locations.html">
<!--LOCAL-->
<link rel="import" href = "mb-links-behavior.html">
<link rel="import" href = "gui-area.html">

<!--
`mb-links-foto`
container for 
- generation/management of map-links to fotoss/images (to be) gelocated/presented on a map 
    - uploaded "internally" by fileDialog or dropZone 
    - supplied from outside
- a ToolSet for      

@demo demo/imagelinks.html 
-->

<dom-module id="mb-links-foto">

    <template>

        <style>

            :host {
                display: block;
                position: relative;
            }
            paper-item {
                cursor: pointer;	
                padding: 3px;
                border: 1;
            }

            .placeholder {
                padding: 3px;
                margin: 2px;
                border: solid 1px red;
            }

            .content {
                @apply(--layout-horizontal);
                @apply(--layout-justified);
            }
        </style>

        <!-- gui-area = part of the map area (or whole map) may be the dropbox -->
        <gui-area 
            id = "imgctrl"
            ctrllabel = "[[ctrllabel]]"
            ctrldisable = "[[ctrldisable]]"
            open = "{{toolstatus}}">

            <!-- SLOT-1 -->
            <div class="ctrl">
                <!-- Liste der primÃ¤r nicht referenzierten images -->
                <paper-listbox>
                    <template is="dom-repeat" items="{{_sessionunset}}">
                        <paper-item value="[[item]]" on-tap="_checkoutDocFromList">[[item]]</paper-item>
                    </template>    
                </paper-listbox>
            </div>        

            <!-- SLOT-2 -->
            <div class="content">    
                
                <div class="placeholder">
                    Placeholder DB QUERY & STORE
                </div>
                
                <!-- try to extend to 100% of parent container -->
                <div class="placeholder">
                    Placeholder DRAGnDROP
                    <files-box
                        type="image"
                        multiple=true
                        loadedfiles="{{imageset}}">
                    </files-box>    
                </div>
                
                <files-input
                    type="image"
                    multiple=true
                    loadedfiles="{{imageset}}">
                </files-input>    

            </div>
        </gui-area>

        <!--<files-box  
            filetype="image" 
            loadedfiles="{{imageset}}" 
            boxsize="300"> 
        </files-box> -->

        <!-- always invisible background-function-element  -->
        <exif-locations
            imageset = "[[imageset]]"
            locationmode = "geojson"
            locations  = "{{featureset}}"
            nonlocated = "{{nonlocated}}">
        </exif-locations>

    </template>

    <script>
        var wpscope; 

        Polymer({
            is: 'mb-links-foto',

            properties: {

                // checkIn: doc(img)Data collection
                imageset : {
                    type: Array ,
                    observer: '_sessionDocsRefresh'
                },

                // checkIn: linkPoints
                featureset : {
                    type: Object,
                    observer: '_refreshMap' 
                },

                // checkIn: names of NOT located docs(imgs) 
                nonlocated : {
                    type: Array,
                    observer: '_checkInUnset'
                },

                // 
                location : {
                    type: String,
                    observer : 'testlocation'
                },

                /**
                 * Container of docs "in use" during this session
                 */
                _sessionDocs : {
                    type: Object,
                    value: {},
                    observer : '_sessionlog'
                },

                // set of locations 
                featuresetRefresh : {
                    type: Object
                },

                /**
                 * Container of docs(imgs) NOT geolocated in actual session
                 */
                _sessionMarkers : {
                    type: Array,
                    value: []
                    // observer: 'docLinkUnsetLog'
                },
                /**
                 * Container of docs(imgs) NOT geolocated in actual session
                 */
                _sessionunset : {
                    type: Array,
                    value: []
                    // observer: 'docLinkUnsetLog'
                },

                // visibility of pointlayer
                visible : {
                    type : Boolean,
                    value : true
                },

                layerid : {
                    type : String,
                    value : "imglinks"
                },

                ctrllabel : {
                    type : String,
                    value : 'ToBeLocated'
                },

                ctrldisable : {
                    type : Boolean,
                    value : true
                },

                toolstatus : {
                    type: Boolean,
                    value: true,
                    notify : true,
                    observer: 'logToolStatus'
                }

            },

            behaviors: [
                Mbb.LinksBehavior
            ],           

            observers:[
                'imgObjReload(docselected.*)',
            ],

            _sessionlog : function(set) {
                console.log("_sessionDocs", set);
            },

            ready: function() {
                wpscope = this;
                //map.showTileBoundaries();
            },

            // Reload an img (fi AFTER some exif changed) 
            imgObjReload: function(docObjObserver) {   
                if (!docObjObserver) return;   
                if (!docObjObserver.base) return; 
                
                var docObj = docObjObserver.base;  

                if (docObj.exif) { 
                    var index = this._sessionunset.indexOf(docObj.name);
                    if (index > -1) {  //  remove entry from "unset" docs 
                        this.splice('_sessionunset', index, 1);  console.log("_sessionUnSet reduced", this._sessionunset);
                    } console.log("RELOAD imgObj with new exif !", docObj.name, docObj);
                    // Trigger RELOAD  
                    this.imageset = [docObj];
                }    
            },


            logToolStatus : function(toolstatus) {
                // other "peripheral" gui-elements should be "hidden"(closed) during "tooling" 
                // console.log("toolstatus", toolstatus);
            },

            hoverAction : function (feature) {
                console.log("hovered ", feature); 
            },

            // 
            _checkInUnset : function (nonlocated) { console.log("NONLOCATED NEW:", nonlocated.names); 
                if (nonlocated && nonlocated.names.length) { 
                   this._sessionunset = this._sessionunset.concat(nonlocated.names); 
                   console.log("NONLOCATED All:", this._sessionunset);
                }   
            },

            // 
            trackDocsUnlinked: function(count) { // console.log("UnSet",count);
                if (count) {    
                   this.ctrldisable = false; 
                } else {
                   this.ctrldisable = true; 
                }
            },

            // Simple fitbounds for point-features
            _fitBounds : function(features, padding) {
                if (padding== null) padding = 20; // pixels ?

                if (features.features) features = features.features; // if a feature-set was passed

                var coord0 = features[0].geometry.coordinates;
                var bounds = features.reduce(function(bounds, feature) {
                    var coord = feature.geometry.coordinates;
                    return bounds.extend(coord);
                }, new mapboxgl.LngLatBounds(coord0, coord0));

                map.fitBounds(bounds, {
                    padding: 30
                }); 
            },     


            // Show markers only for features of a layer 
            // that are actually rendered (visible mapextent)  
            _checkMarkers : function(layername, idname, ms_debounce) {
                if (!layername) layername = 'unclustered-point';
                if (!ms_debounce) ms_debounce = 500; 
                
                this.debounce("markers", function() {
                    
                    var zoom = map.getZoom();

                    var features = map.queryRenderedFeatures({
                        layers: [layername]
                    });  // console.log("_checkMarkers. At zoom=" + zoom + " for", features.length + " feature(s)");

                    features = this.mbFeaturesUnique(features, idname);

                    // ? Heuristics of marker.management ?  
                    // Comparing "new" features and "previous" markers  

                    // Heu-1:  
                    var n1 = features.length,
                        n2 = this._sessionMarkers.length; // console.log(n1,n2, features, this._sessionMarkers); 
                    if (n1 == n2) {
                        // Heu-2: 
                        // ...                        
                        return; 
                    }

                    // Refresh required !!
                    this._sessionMarkers.forEach(function(marker){
                        marker.remove(); 
                    })
                    this._sessionMarkers = [];

                    if (features.length)  {
                        
                        this._createMarkers(features);
                    }

                }, ms_debounce); 
            },

            // Create Markers used for display of points at "suitable" scales
            // showing a thumbNail of geocoded images
            _createMarkers: function(features) {
                
                if (!features || !features.length) {  // console.log("ALERT. NO features to refresh markers from"); 
                    return;
                }  // console.log("Features to create Markers from:", features);

                // Function activated after marker-click
                var linkFunction = this._checkoutDoc;

                // Sample function of dom4popup creation 
                function dom4pop(properties) {
                    var domContent = window.document.createElement('div');
                        domContent.style.backgroundColor = "yellow";
                        domContent.style.padding = "5px";
                        
                    var title = window.document.createElement('h3');
                        title.innerText = properties.name;    
                    var popimg = window.document.createElement('img');
                        popimg.style.width = "400px";
                        popimg.src = properties.img;
                    domContent.append(title);    
                    domContent.append(popimg);    
                    return domContent; 
                };

                function makeMarker(imgUrl, iconSize) {
                    var el = document.createElement('div');
                    el.className = 'marker';
                    el.style.cursor = "pointer";
                    el.style.border = '1px solid #777';
                    el.style.borderRadius = '4px';
                    el.style.width  = iconSize[0] + 'px';
                    el.style.height = iconSize[1] + 'px';
                    el.style.backgroundImage = "url('"+imgUrl+"')";
                    el.style.backgroundSize = "cover";
                    return el;
                };

                function makePopup(properties) {
                    var popup = new mapboxgl.Popup({offset: 25});
                
                    var text; // = properties.name; 
                    var html; // ="<h3> Image name</h3>" + properties.name;
                    var domContent = dom4pop(properties); 

                    if (text)   popup.setText(text);
                    if (html)   popup.setHTML(html);
                    if (domContent) popup.setDOMContent(domContent);

                    return popup;    
                };    

                features.forEach(function(markerpnt) {
                   
                    // create a DOM element for the marker
                    var markerid = markerpnt.properties.name,
                        bgimg    = markerpnt.properties.img,
                        iconSize = markerpnt.properties.iconsize;

                    if (!iconSize) iconSize = [50,50];

                    if (bgimg) {    

                        var marker = makeMarker(bgimg, iconSize, markerpnt.properties);

                        // add marker to map
                        var mbMarker = new mapboxgl.Marker(marker, {offset: [-iconSize[0] / 2, -iconSize[1] / 2]})
                            .setLngLat(markerpnt.geometry.coordinates)
                            .addTo(map);

                        this._sessionMarkers.push(mbMarker); 

                        // setup link functions    
                        if (linkFunction)  {
                            marker.addEventListener('tap', function() {
                                // console.log("LINK on marker of:", markerid); 
                                linkFunction(markerid);
                            }); 
                        } else if (dom4pop)  {
                            var popup  = makePopup(markerpnt.properties);  
                            mbMarker.setPopup(popup);
                        }    
                    }
                }.bind(this));  console.log(features.length + " Marker(s) created "); // , features); 
            }

        });
    </script>
</dom-module>