<link rel="import" href="../polymer/polymer.html">

<link rel="import" href = "../iron-flex-layout/iron-flex-layout.html">

<link rel="import" href = "../paper-button/paper-button.html">
<!--<link rel="import" href = "../paper-icon-button/paper-icon-button.html">-->
<!--<link rel="import" href = "../iron-collapse/iron-collapse.html">-->

<link rel="import" href = "../paper-item/paper-item.html">
<link rel="import" href = "../paper-listbox/paper-listbox.html">
<!--<link rel="import" href = "../iron-icons/iron-icons.html">-->

<!--GIA-->
<link rel="import" href = "../files-input/files-input.html">
<link rel="import" href = "../image-meta/exif-locations.html">
<!--LOCAL-->
<link rel="import" href = "mb-links-behavior.html">
<link rel="import" href = "mb-drop-files.html">
<link rel="import" href = "gui-area.html">

<!--
`mb-links-foto`
container for 
- generation/management of map-links to fotoss/images (to be) gelocated/presented on a map 
    - uploaded "internally" by fileDialog or dropZone 
    - supplied from outside
- a ToolSet for      

@demo demo/imagelinks.html 
-->

<dom-module id="mb-links-foto">

    <template>

        <style>

            :host {
                display: block;
                position: relative;
            }
            paper-item {
                cursor: pointer;	
                padding: 3px;
                border: 1;
            }

            .placeholder {
                padding: 3px;
                margin: 2px;
                border: solid 1px red;
            }

            .content {
                @apply(--layout-vertical);
                /*@apply(--layout-justified);*/
            }
            .content * {
                margin-top: 10px;
            }
        </style>

        <!-- gui-area = part of the map area (or whole map) may be the dropbox -->
        <gui-area 
            id = "imgctrl"
            ctrllabel = "[[ctrllabel]]"
            ctrldisable = "[[ctrldisable]]"
            open = "{{toolstatus}}">

            <!-- SLOT-1 -->
            <div class="ctrl">
                <!-- Liste der primÃ¤r nicht referenzierten images -->
                <paper-listbox>
                    <template is="dom-repeat" items="{{_sessionUnSet}}">
                        <paper-item value="[[item]]" on-tap="_checkoutDocFromList">[[item]]</paper-item>
                    </template>    
                </paper-listbox>
            </div>        

            <!-- SLOT-2 -->
            <div class="content">    
                <!--<div class="placeholder">
                    Placeholder DB QUERY & STORE
                </div>-->
                
                <paper-button 
                    id="clear"
                    raised
                    on-tap="_sessionClear">
                    ClearSession
                </paper-button> 
                <!-- supply a set of imagefiles from dropped files -->
                <files-input
                    type="image"
                    multiple=true
                    loadedfiles="{{imageset}}">
                </files-input>    

            </div>
        </gui-area>

         <!-- INVISIBLE service-components -->

         <!-- supply a set of imagefiles from dropped files -->
        <mb-drop-files 
            map = [[map]]
            type = "image"
            loadedfiles = "{{imageset}}">
        </mb-drop-files>    

        <!-- Extract img-locations as geojson-features -->
        <exif-locations
            imageset = "[[imageset]]"
            locationformat = "geojson"
            locations  = "{{featureset}}"
            nonlocated = "{{nonlocated}}">
        </exif-locations>

    </template>

    <script>
        var wpscope; 

        Polymer({
            is: 'mb-links-foto',

            properties: {
                // 
                map: {
                    type: Object
                },

                // checkIn: doc(img)Data collection
                imageset : {
                    type: Array ,
                    observer: '_sessionDocsRefresh'
                },

                // checkIn: linkPoints
                featureset : {
                    type: Object
                    // observer: '_refreshMap.geojson' 
                },

                // checkIn: names of NOT located docs(imgs) 
                nonlocated : {
                    type: Array,
                    observer: '_checkInUnset'
                },

                // 
                location : {
                    type: String,
                    observer : 'testlocation'
                },

                /**
                 * Container of docs "in use" during this session
                 */
                _sessionDocs : {
                    type: Object,
                    value: {},
                    observer : '_sessionlog'
                },

                // set of locations 
                featuresetRefresh : {
                    type: Object
                },

                /**
                 * Container of docs(imgs) NOT geolocated in actual session
                 */
                _sessionMarkers : {
                    type: Array,
                    value: []
                    // observer: 'docLinkUnsetLog'
                },
                /**
                 * Container of docs(imgs) NOT geolocated in actual session
                 */
                _sessionUnSet : {
                    type: Array,
                    value: []
                    // observer: 'docLinkUnsetLog'
                },

                // visibility of pointlayer
                visible : {
                    type : Boolean,
                    value : true
                },

                layerid : {
                    type : String,
                    value : "imglinks"
                },

                ctrllabel : {
                    type : String,
                    value : 'ToBeLocated'
                },

                ctrldisable : {
                    type : Boolean,
                    value : true
                },

                toolstatus : {
                    type: Boolean,
                    value: true,
                    notify : true,
                    observer: 'logToolStatus'
                }

            },

            behaviors: [
                Mbb.LinksBehavior
            ],           

            observers:[
                'imgObjReload(docselected.*)',
                '_refreshMap(featureset.geojson)'   
            ],

            _sessionClear : function(){
                var status = this._linkLayerStatus(),
                    fset = this._sessionSet,
                    unset = this._sessionUnSet;

                console.log("featureset", this.featureset); 
                console.log(status);
                console.log("Set",fset);
                console.log("UnSet", unset);
                fset.features = [];
                status.src.setData(fset);
                this._sessionUnSet=[];
                this.featureset = {}; 
                console.log(this._sessionSet);
                console.log("featureset", this.featureset); 
                
            },

            _sessionlog : function(set) {
                console.log("_sessionDocs", set);
            },

            ready: function() {
                wpscope = this;
            },
            // Reload an img (fi AFTER some exif changed (especially coords)) 
            imgObjReload: function(docObjObserver) {   
                if (!docObjObserver) return;   
                if (!docObjObserver.base) return; 
                
                var docObj = docObjObserver.base;  

                if (docObj.exif) { // flag that exif had changed
                    var index = this._sessionUnSet.indexOf(docObj.name);
                    if (index > -1) {  //  remove entry from "unset" docs 
                        this.splice('_sessionUnSet', index, 1);  
                    } // console.log("RELOAD imgObj with new exif !", docObj.name, docObj);
                    
                    // Trigger RELOAD  
                    this.imageset = [docObj];
                }    
            },


            logToolStatus : function(toolstatus) {
                // other "peripheral" gui-elements should be "hidden"(closed) during "tooling" 
                // console.log("toolstatus", toolstatus);
            },

            hoverAction : function (feature) {
                console.log("hovered ", feature); 
            },

            // merge additional nonlocated documents into session
            _checkInUnset : function (nonlocated) { // console.log("NONLOCATED NEW:", nonlocated.names); 
                if (nonlocated && nonlocated.names.length) { 
                   this._sessionUnSet = this._sessionUnSet.concat(nonlocated.names);
                   this._sessionUnSet = this._sessionUnSet.filter(function(item, pos, self) {
                        return self.indexOf(item) == pos;
                   }); // removed duplicates  
                   // console.log("NONLOCATED All:", this._sessionUnSet);
                }   
            },

            // 
            trackDocsUnlinked: function(count) { // console.log("UnSet",count);
                if (count) {    
                   this.ctrldisable = false; 
                } else {
                   this.ctrldisable = true; 
                }
            },

            // Show markers only for features of a layer 
            // that are actually rendered (visible mapextent)  
            _checkMarkers : function(layername, idname, ms_debounce) {
                if (!layername) layername = 'unclustered-point';
                if (!ms_debounce) ms_debounce = 500; 
                
                var getUnique = this._mbUniqueFeatures;

                this.debounce("markers", function() {
                    
                    var zoom = map.getZoom();

                    var features = map.queryRenderedFeatures({
                        layers: [layername]
                    });  // console.log("_checkMarkers. At zoom=" + zoom + " for", features.length + " feature(s)");

                    features = getUnique(features, idname);

                    // ? Heuristics of marker.management ?  
                    // Comparing "new" features and "previous" markers  

                    // Heu-1:  
                    var n1 = features.length,
                        n2 = this._sessionMarkers.length; // console.log(n1,n2, features, this._sessionMarkers); 
                    if (n1 == n2) {
                        // Heu-2: 
                        // ...                        
                        return; 
                    }

                    this._sessionMarkers.forEach(function(marker){ // console.log("removing marker",marker); 
                        marker.remove(); 
                    })
                    this._sessionMarkers = [];

                    // "Refresh" required !!
                    if (features.length)  {
                        this._createMarkers(features);
                    }

                }, ms_debounce); 

            },

            /**
             *  Create Markers used for "enhanced" display of points at "suitable" scales
             *  f.i. showing a thumbNail of a geocoded image
             */
            _createMarkers: function(features) {
                
                if (!features || !features.length) {  // console.log("ALERT. NO features to refresh markers from"); 
                    return;
                }  // console.log("Features to create Markers from:", features);

                // Function activated after marker-click
                var linkFunction = this._checkoutDoc;

                function createMarkerDom(markerSize, imgUrl) {
                    var mDom = document.createElement('div');
                    mDom.className = 'marker';
                    mDom.style.cursor = "pointer";
                    mDom.style.border = '1px solid #777';
                    mDom.style.borderRadius = '4px';
                    mDom.style.width  = markerSize[0] + 'px';
                    mDom.style.height = markerSize[1] + 'px';
                    mDom.style.backgroundSize = "cover"; // 
                    if (imgUrl) mDom.style.backgroundImage = "url('"+imgUrl+"')";
                    else mDom.style.backgroundColor = "green";
                    return mDom;
                };

                function createMarker(markerPnt) {

                    // create a DOM element for the marker
                    var markerId = markerPnt.properties.name,
                        markerSize = markerPnt.properties.iconSize;
                    if (!markerSize) markerSize = [50,50];

                    // var markerImg  = markerPnt.properties.img;
                    // if (!markerImg) markerImg = "thumb.jpg";

                    var markerDom = createMarkerDom(markerSize); // , markerImg);

                    // add marker to map
                    var mbMarker = new mapboxgl.Marker(markerDom, {offset: [-markerSize[0] / 2, -markerSize[1] / 2]})
                        .setLngLat(markerPnt.geometry.coordinates)
                        .addTo(map);

                    // this._sessionMarkers.push(mbMarker); 

                    // setup link functions    
                    if (linkFunction)  {
                        markerDom.addEventListener('tap', function() {
                            // console.log("LINK on marker of:", markerId); 
                            linkFunction(markerId);
                        }); 
                    } else if (createPopupDom)  {
                        var popup  = createPopup(markerPnt.properties);  
                        mbMarker.setPopup(popup);
                    }    
                    return mbMarker; 

                }; // .bind(this));  

                // Sample function of createPopupDomup creation 
                function createPopupDom(properties) {
                    var domContent = window.document.createElement('div');
                        domContent.style.backgroundColor = "yellow";
                        domContent.style.padding = "5px";
                        
                    var title = window.document.createElement('h3');
                        title.innerText = properties.name;    
                    var popimg = window.document.createElement('img');
                        popimg.style.width = "400px";
                        popimg.src = properties.img;
                    domContent.append(title);    
                    domContent.append(popimg);    
                    return domContent; 
                };

                function createPopup(properties) {
                    var popup = new mapboxgl.Popup({offset: 25});
                
                    var text; // = properties.name; 
                    var html; // ="<h3> Image name</h3>" + properties.name;
                    var domContent = createPopupDom(properties); 

                    if (text)   popup.setText(text);
                    if (html)   popup.setHTML(html);
                    if (domContent) popup.setDOMContent(domContent);

                    return popup;    
                };    

                var mbMarker = null;
                features.forEach(function(markerPnt) {
                    mbMarker = createMarker(markerPnt);  
                    this._sessionMarkers.push(mbMarker); 
                }.bind(this)); console.log(features.length + " Marker(s) created "); // , features); 

            }

        });
    </script>
</dom-module>