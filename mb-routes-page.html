<!DOCTYPE html>
<html>

<head>
    <meta charset='utf-8' />
    <title></title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />
    <script src='https://api.tiles.mapbox.com/mapbox-gl-js/v0.28.0/mapbox-gl.js'></script>
    <link href='https://api.tiles.mapbox.com/mapbox-gl-js/v0.28.0/mapbox-gl.css' rel='stylesheet' />
    <style>
        body {
            margin: 0;
            padding: 0;
        }
        
        #map {
            position: absolute;
            top: 0;
            bottom: 0;
            width: 100%;
        }
        
        #info {
            display: block;
            position: relative;
            margin: 0px auto;
            width: 50%;
            padding: 10px;
            border: none;
            border-radius: 3px;
            font-size: 12px;
            text-align: center;
            color: #222;
            background: #fff;
        }
    </style>
</head>

<body>

    <style>
        .overlay {
            position: absolute;
            top: 10px;
            left: 10px;
        }
        
        .overlay button {
            font: 600 12px/20px 'Helvetica Neue', Arial, Helvetica, sans-serif;
            background-color: #3386c0;
            color: #fff;
            display: inline-block;
            margin: 0;
            padding: 10px 20px;
            border: none;
            cursor: pointer;
            border-radius: 3px;
        }
        
        .overlay button:hover {
            background-color: #4ea0da;
        }
        
        .overlay button img {
            width: 32px;
            height: 32px;
        }
    </style>

    <script src='//api.tiles.mapbox.com/mapbox.js/plugins/turf/v2.0.0/turf.min.js' charset='utf-8'></script>

    <div id='map'></div>
    <pre id='info'></pre>

    <div class='overlay'>
        <button id='replay'>
            <img src="assets/media-step-backward.svg" alt="restart">
        </button>
        <button id='toggle'>
            <img src="assets/media-play.svg" alt="media-play">
        </button>
        <input id='fps' type='range' min='1' max='60' step='0' value='60' />
        <label><span id='slider-value'>60</span>Hz</label>
    </div>

    <script>
        // 
        // default waypoint-file
        var url = "wp-data/wps-viewing.json";
        // map-globals
        var map,
            popup,
            popuphtml,
            popupid;

        // animation-globals    
        var fpsmax = 60,
            fps = fpsmax,
            counter = 0,
            flystatus,
            requestframeref,
            time = 0,
            timeScale = 360; // (10s = 1h, for Planes) 
        //timeScale = 8640; //  (10s = 24h, for Boats) 

        // MBGL-Features AS JSON-DATA 
        // Lines from origin to destination.
        var routes = {
            "type": "FeatureCollection"
        };
        // Points that are static.
        var waypoints = {
            "type": "FeatureCollection"
        };
        // Points that animates along the plane-routes.
        var planes = {
            "type": "FeatureCollection"
        };

        // static object
        class Waypoint {
            constructor(coordinates, id, icon) {
                if (!id) id = "wp";
                if (!icon) icon = "star";
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }
                this.id = id;
                this.properties = {
                    "title": id,
                    "icon": icon
                }
            };
        };

        // animated object
        class Plane {
            constructor(coordinates, id, plane) {
                if (!plane) plane = id;
                this.type = "Feature";
                this.geometry = {
                    "type": "Point",
                    "coordinates": coordinates
                }
                this.id = id;
                this.properties = {
                    "id": id,
                    "title": plane,
                    "bearing": 90,
                    "time": 0,
                    "speed": 0,
                    "getbearing": function() {

                        return 180;
                    }
                }
            };
        };

        class Leg {
            constructor(coordinates) {
                this.type = "Feature";
                this.geometry = {
                    "type": "LineString",
                    "coordinates": coordinates
                }
                this.properties = {

                }
            }
        };

        class Route {
            constructor(coordinates, data, wps) { // coordinates = array of coordinate-arrays (multiLine) 
                this.type = "Feature";
                this.geometry = {
                    "type": "MultiLineString",
                    "coordinates": coordinates
                }
                this.properties = {
                    "legs": data,
                    "wps": wps
                }
            }
        };

        // A. Setup waypoints
        function setupWaypoints(routedata) {
            var wapoints = {};
            waypoints.features = [];

            var wp;
            routedata.forEach(function(route, j) {
                // locate plane at 'origin'
                // console.log("route-" + j, route.waypoints);
                route.waypoints.forEach(function(wp, p) {
                    waypoints.features.push(new Waypoint(wp.coords, wp.id));
                });
            });
            // console.log("all waypoints collected", waypoints.features);

            var jsonlayer = {};
            jsonlayer['data'] = waypoints;
            jsonlayer['layer'] = {
                "id": "waypoints",
                "type": "symbol",
                "source": "waypoints",
                "layout": {
                    "icon-image": "{icon}-15",
                    //"icon-image": "harbor-15",
                    "text-field": "{title}",
                    "text-anchor": "bottom",
                    "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                    "text-offset": [0, -0.6]
                }
            };
            return jsonlayer;

        }

        // A. Setup animated objects for all sets of routedata
        function initPlanes(startcounter, routedata) {
            if (!startcounter) startcounter = 0;

            var jsonlayer = {};

            // setup data 
            planes.features = [];

            routedata.forEach(function(route, j) {
                // locate plane at 'origin'
                var aplane = new Plane(route.waypoints[startcounter].coords, route.id, route.plane);
                planes.features.push(aplane);
            });

            jsonlayer['data'] = planes;

            // planes = planes; // local to global !!??

            // setup styling
            jsonlayer['layer'] = {
                "id": "planes",
                "source": "planes",
                "type": "symbol",
                "layout": {
                    "icon-image": "airport-15",
                    "icon-size": 2,
                    "icon-rotate": 90,
                    //"icon-image": "{icon}-15",
                    //"icon-rotate": "{getbearing}", // 
                    "text-field": "{title}",
                    "text-font": ["Open Sans Semibold", "Arial Unicode MS Bold"],
                    "text-size": 12,
                    "text-offset": [0, 0.6],
                    "text-anchor": "top"
                }
            };
            return jsonlayer;
        }

        // B. Setup routes for animation with "requestAnimationFrame (60 fps)"
        function setupRoutes(routedata, timeScale) {
            if (!timeScale) timeScale = 360; // Animationszeit 1s=360s=6min, 10s=1h Echtzeit 

            var demoSpeed = 900;
            var frameTime = timeScale / fpsmax; // Bsp: frame: 6 s fuer scale = 360 und fps=60 !!

            routes.features = [];

            // Interpolate the Routes between waypoints 
            // based on info about speed and/or arrival-/departure-times at waypoints

            var wpnext, legDistance, legSteps;

            routedata.forEach(function(data, j) {

                var waypoints = data.waypoints, // wps as given
                    legdata = [], // mean props of every leg    
                    legs = [], // routepoints of every leg
                    routeSpeed = data.speed,
                    legSpeed,
                    legTimeSec, legStopSec;

                if (!routeSpeed) routeSpeed = demoSpeed;

                // route-legs between waypoints 
                waypoints.forEach(function(wp, p) {

                    wpnext = waypoints[p + 1];

                    // Calculate leg-properties
                    if (wpnext) {
                        // console.log("waypoints:" + p, wp, wpnext);
                        // Calculate the distance in kilometers between waypoints
                        legSpeed = routeSpeed;
                        var leg = new Leg([wp.coords, wpnext.coords]),
                            leginfo = {},
                            legDistance = turf.lineDistance(leg, 'kilometers');

                        // console.log("Route-" + j + ", leg to", wpnext, leg); // , legPositions);

                        // options to calculate a leg-specific speed between wp's
                        if (wpnext.speed) {
                            legSpeed = wpnext.speed;
                        }
                        if (wpnext.stopover) {
                            legStopSec = wpnext.stopover;
                        }

                        // Calc number of animation-steps to travel between waypoints in legTimeSec
                        // console.log("legspeed=", legSpeed);
                        legTimeSec = legDistance / legSpeed * 3600;
                        legSteps = Math.round(legTimeSec / frameTime);

                        // Assign basic leg-properties
                        leginfo.from = wp;
                        leginfo.to = wpnext;
                        leginfo.dist = legDistance;
                        leginfo.speed = legSpeed;
                        leginfo.time = legTimeSec;

                        leginfo.steps = legSteps;

                        // Assign time-properties
                        var h = Math.floor(legTimeSec / 3600),
                            m = Math.round((legTimeSec - (h * 3600)) / 60);
                        leginfo.flighttime = h + "h" + m + "min";

                        // Calc animation-positions
                        var legPositions = [];

                        for (let i = 0; i < legSteps; i++) {
                            let dist = i * (legDistance / legSteps);
                            let position = turf.along(leg, dist, 'kilometers');
                            // if (i == 10) console.log(i, dist, position);
                            legPositions.push(position.geometry.coordinates);
                        }

                        if (legStopSec) {
                            // INSERT some "zero-steps" at stopover waypoint 
                            h = Math.floor(legStopSec / 3600);
                            m = Math.round((legStopSec - (h * 3600)) / 60);
                            leginfo.stopTime = h + "h" + m + "min";

                            var n = Math.round(legStopSec / frameTime);
                            leginfo.stopSteps = n;

                            // append "stop-coordinates" to the leg 
                            for (let i = 0; i < n; i++) {
                                legPositions.push(legPositions[legPositions.length - 1]);
                            }

                        }

                        legdata.push(leginfo);

                        legs.push(legPositions);

                    }
                });

                // add next route consisting of some legs
                var r = new Route(legs, legdata, waypoints);
                console.log("SETUP route-" + j, r);

                routes.features.push(r);

            }); // console.log("routes", routes);

            var jsonlayer = {};

            jsonlayer['data'] = routes;

            jsonlayer['layer'] = {
                "id": "routes",
                "source": "routes",
                "type": "line",
                "paint": {
                    "line-width": 2,
                    "line-color": "#007cbf"
                }
            };
            return jsonlayer;
        }


        // Run at every Animationstep 
        function calcLocations(counter) {

            var located;

            planes.features.forEach(function(plane, j) {

                var cc, cclast, leginfo = {},
                    cntPositionsBeforeLeg = 0,

                    route = routes.features[j],
                    typ = route.geometry.type,
                    legs = route.geometry.coordinates,

                    routeinfo = route.properties,
                    legdata = routeinfo.legs;

                if (typ == "MultiLineString") {
                    // legs = coords;
                } else {
                    // one leg only 
                    legs = [legs];
                }

                legs.every(function(legPositions, i) {
                    // B????
                    if (counter < (cntPositionsBeforeLeg + legPositions.length)) {
                        cc = legPositions[counter - cntPositionsBeforeLeg];
                        if (cc) {
                            leginfo = legdata[i];
                            return false;
                        }
                    }
                    cntPositionsBeforeLeg = cntPositionsBeforeLeg + legPositions.length;
                    return true; // wichtig !!
                })

                if (cc) {
                    located = 1;
                    plane.geometry.coordinates = cc;

                    var lastPos = plane.properties.lastPos;
                    if (lastPos) {
                        // calc last steps bearing (between plane and its 'lastPosition')
                        var bearing = turf.bearing(new Plane(lastPos), plane);
                        if (bearing < 0) bearing = bearing + 360;

                        var legToArrival = new Leg([cc, leginfo.to.coords]),
                            dta = turf.lineDistance(legToArrival, "kilometers");

                        var v = leginfo.speed;
                        if (v && Math.round(dta / 10)) { // 
                            var t = dta / parseFloat(v),
                                h = Math.floor(t),
                                m = Math.round((t - h) * 60);
                            h = h ? h + "h " : "";
                            m = m ? m + "min" : "";
                            var tta = h || m ? h + m : "arrived";
                            // console.log(v, t, h, m);
                            plane.properties.bearing = Math.round(bearing) + "°";
                            plane.properties.speed = v + " km/h";
                            plane.properties.dta = Math.round(dta / 10) * 10 + "km";
                            plane.properties.tta = tta;
                        } else {
                            plane.properties.bearing = 0;
                            plane.properties.speed = 0;
                            plane.properties.dta = 0;
                            plane.properties.tta = "arrived";
                        }
                    }
                    plane.properties.lastPos = cc;

                    // update the popup-location
                    if (popup && (popupid == plane.properties.id)) {
                        popuphtml = calcPlaneInfo(plane);
                        popup.setHTML(popuphtml); //console.log("popup", popup, popuphtml, cc);
                        popup.setLngLat(cc);
                    }

                }

            });

            return located;
        }

        // 
        function animateAll() {
            // Update point geometries to new positions 
            // based on counter denoting the index to access the route-position.

            var located = calcLocations(counter);

            counter = counter + 1;

            // Request the next frame of animation so long 
            // as not all planes have reached their destination (located != null) 
            if (located) {

                // Update the source of animated objects with this new data.
                map.getSource('planes').setData(planes);

                if (fps && (fps < 60)) {
                    setTimeout(function() {
                        requestframeref = requestAnimationFrame(animateAll);
                    }, 1000 / fps);
                } else {
                    requestframeref = requestAnimationFrame(animateAll);
                }


            } else {
                console.log("STOP of animation");
            }

        }

        // 
        function setupAnimationCtrls(routedata) {

            var ctrl1 = document.getElementById('replay'),
                ctrl2 = document.getElementById('toggle');

            //     
            var slider = document.getElementById('fps');
            var sliderValue = document.getElementById('slider-value');

            // ReStart-Button-event
            ctrl1.addEventListener('click', function() {

                cancelAnimationFrame(requestframeref);
                flystatus = false;

                // Update the source layer
                // Set the coordinates of the original point back to origin
                initPlanes(0, routedata);
                map.getSource('planes').setData(planes);

                // Reset the timestep-counter
                counter = 0;

                ctrl2.childNodes[1].src = "assets/media-play.svg";

                // Restart the animation. with "toggle"
                // animateAll(counter);
                // requestAnimationFrame(animateAll)
            });

            // Start/Stop-Button-event
            ctrl2.addEventListener('click', function() {
                // console.log(this, ctrl2.childNodes);
                if (flystatus) {
                    cancelAnimationFrame(requestframeref);
                    flystatus = false;
                    ctrl2.childNodes[1].src = "assets/media-play.svg";
                    // console.log("stopped", ctrl2.childNodes);
                } else {
                    requestAnimationFrame(animateAll);
                    flystatus = true;
                    ctrl2.childNodes[1].src = "assets/media-pause.svg";
                    // console.log("started", ctrl2.childNodes);
                }
            });

            slider.addEventListener('input', function(e) {
                // Adjust the global value fps (animation-frequency) 
                fps = parseInt(e.target.value);
                // Value indicator
                sliderValue.textContent = fps; //  + '%';
            });

        }

        // C. Setup the map
        function setupMap(routedata, jsonlayers) {

            mapboxgl.accessToken = 'pk.eyJ1Ijoib25lcHV0aW4iLCJhIjoiY2ltbHBidWxhMDAwa3ZubHdpNHMwdmNwMiJ9.XnPbDF8YdaDgfMFAVi9Vyw';

            // Collect waypoint-coordinates
            var coordinates = [],
                bounds, center,
                startmode = false; // routedata[0].waypoints[0].coords ];

            routedata.forEach(function(route, j) {
                route.waypoints.forEach(function(wp, i) {
                    coordinates.push(wp.coords);
                    startmode = startmode || (wp.coords[0] > 150);
                })
            });

            // 
            if (startmode) { // workaround for coords around dateline
                center = coordinates[0];
            } else { // create bounds around all wp-coordinates
                bounds = coordinates.reduce(function(bounds, coord) {
                        return bounds.extend(coord);
                    },
                    new mapboxgl.LngLatBounds(coordinates[0], coordinates[0])
                );
                center = bounds.getCenter();
            }
            // console.log("center, wp-coordinates", center, coordinates);

            map = new mapboxgl.Map({
                container: 'map',
                style: 'mapbox://styles/mapbox/streets-v9',
                center: center,
                zoom: 3
            });

            map.on('load', function() {

                if (bounds) map.fitBounds(bounds, {
                    padding: 20
                });
                /* bbox an der dateline
                [
                    [160, -60],
                    [-60, -50]
                ]);*/
                var layernames = Object.keys(jsonlayers),
                    jsonlayer;

                layernames.forEach(function(lname, j) {

                    jsonlayer = jsonlayers[lname];
                    map.addSource(lname, {
                        "type": "geojson",
                        "data": jsonlayer['data']
                    });
                    map.addLayer(jsonlayer['layer']);
                })

                // Prepare(Start) the animation.
                setupAnimationCtrls(routedata);
                // animateAll();

            });

            popup = new mapboxgl.Popup({
                closeButton: false,
                closeOnClick: false
            });

            map.on('mousemove', function(e) {

                document.getElementById('info').innerHTML = JSON.stringify(e.lngLat);

                var features = map.queryRenderedFeatures(e.point, {
                    layers: ['planes']
                });

                if (!features || !features.length) {
                    // strategy 1:
                    // popup.remove();
                    return;
                }

                // Change the cursor style as a UI indicator.
                // var cursor = "";
                // if (features.length)  
                map.getCanvas().style.cursor = 'pointer';

                // strategy 2: 
                // remove popup, if content changes to another obj
                popup.remove();

                var plane = features[0]; // console.log("selecting plane:", plane);
                popupid = plane.properties.id;
                popuphtml = calcPlaneInfo(plane);

                // Populate the popup and set its coordinates
                // based on the feature found.
                popup.setLngLat(plane.geometry.coordinates)
                    .setHTML(popuphtml)
                    .addTo(map);
            });
        }

        // Create html-dom to view with animated object
        function calcPlaneInfo(feature, counter) {
            // console.log(feature.properties);
            var iplane = "<b>" + feature.properties.id + "</b>" + "<br>";
            if (feature.properties.bearing) iplane += "Bearing: " + feature.properties.bearing + "<br>";
            if (feature.properties.speed) iplane += "Sog: " + feature.properties.speed + "<hr>";
            if (feature.properties.dta) iplane += "DTA: " + feature.properties.dta + "<br>";
            if (feature.properties.tta) iplane += "TTL: " + feature.properties.tta + "<br>";

            // if (counter) iplane += "Counter: " + counter + "<br>";
            // ;
            return iplane;
        }

        // START after data-loaded 
        function appStarter() {

            var timescale = 1000;

            if (request.status >= 200 && request.status < 400) {

                var routedata = JSON.parse(request.responseText);

                var jsonlayers = {};

                jsonlayers['waypoints'] = setupWaypoints(routedata);

                jsonlayers['planes'] = initPlanes(time, routedata);

                jsonlayers['routes'] = setupRoutes(routedata, timescale);

                // console.log("jsonlayers created", jsonlayers);

                setupMap(routedata, jsonlayers);

            } else {
                console.log("RouteDataServer returned an error");
            }
        }

        // ---------------------------------------------------------------------------

        var request = new XMLHttpRequest();

        request.open('GET', url, true);

        request.onload = appStarter;

        request.onerror = function() {
            console.log("There was a connection error of some sort");
        };

        request.send();

    </script>

</body>

</html>