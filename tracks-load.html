<link rel="import" href="../polymer/polymer.html">

<link rel="import" href="geotags-from-gpx.html">
<link rel="import" href="tracks-from-pnts.html">


<!--
`tracks-load`

component loads tracking data 
- from location sets of different formats
    - raw handheld (gps as gpx)
    - tabular handheld export (gps as csv)
    - tabular database export (vendee-tables)
- into different app-formats, = F(routemode)
    - 'log-formats' (map-lines, z-diagram, listing) 
    - 'trackdata-templates' (as required by routing-api)

@demo demo/routingtracks.html 
-->

<dom-module id="tracks-load">

    <template>

    <style is="custom-style">
        :host {
            display: none; /*inline-block;*/
            position: absolute;
            opacity: 1; 
            top: 50%;
            margin-bottom: -50%;
            transform: translate(0, -50%);
        }
    </style>

    <!-- IF's to alternatively formatted srces -->
    <tracks-from-pnts 
        srcmeta="[[srcmetad]]"        
        routemode="[[routemode]]"
        trackdata="{{_trackdata}}">
    </tracks-from-pnts>    

    <!--tagname="Track"-->
    <geotags-from-gpx 
        srcmeta="[[srcmetax]]"
        tagdata="{{_trackdata}}">
    </geotags-from-gpx>    

    <content>
    </content>    

</template>

    <script>
        Polymer({
            is: 'tracks-load',

            properties: {

                // OUT: TRACKS as static log conternt
                trackdata: {
                    type: Object,
                    notify: true
                },

                routemode: {
                    type: Boolean
                },

                srcmetad : {
                    type: String
                },

                /** metadata describing trackdata to load
                 *  
                 */
                tracksetmeta: {
                    type: Object
                },

                // raw data imported from different  
                _trackdata: {
                    type: Object
                },

            },

            behaviors: [
            ],

            observers: [
                '_requestManager(tracksetmeta.*)',
                '_responseManager(_trackdata, routemode, srcmetad)'
            ],

            attached: function() {
                // this._uxManager();
            },


            /** Prepares import of trackdata
             *  - from alternative low-level import-components (evaluates metadata)  
             *  - with structures dependent on routemode
             */
            _requestManager: function(srcmeta) {

                this.debounce("request", function() {  //console.log(srcmeta, routemode);
                    if (srcmeta.path == 'tracksetmeta') srcmeta = srcmeta.value;

                    var srcurl = srcmeta.url,      // 
                        srctype = srcmeta.type,    // 
                        srctitle = srcmeta.title;  // 

                    // Check some url - conditions ???
                    if (!srcurl) {
                        return;
                    } 

                    if (this.tracksetmeta && (srcurl != this.tracksetmeta.url)) {
                        //this.routecontent = [];
                        //this.trackdata = [];
                        srctitle = this.tracksetmeta.title;
                    } 

                    // Extend metadata with Query/Format - parameters
                    if ((srctype == "kml") || (srctype == "gpx")) {

                        srctype = "xml"; 
                        srcmeta.xmlquery = {};
                    
                        if (srctype == "gpx") {
                            // ALWAYS extract only tracks (neither waypoints or routes)
                            srcmeta.xmlquery = {
                                "tags": "Track",
                                "structure": "doc"
                            };                    
                        } 

                        // OPTIONAL: JOIN with user-defined query-expressions  
                        if (srcmeta.query) {  
                            srcmeta.xmlquery = Object.assign(srcmeta.xmlquery, srcmeta.query);
                        } 
                    }

                    // console.log("tracksetmeta. AFTER", srcmeta);
                    // this.tracksetmeta = srcmeta;
                    // trigger one of alternative import-elements
                    if (srctype == "xml")  {
                        this.srcmetax = srcmeta;
                        this.srcmetad = null;
                    } else {
                        this.srcmetad = srcmeta;
                        this.srcmetax = null;
                    }   

                }, 100);     
            },

            /** 
             * Postprocess raw tracks into alternative Formats 
             */    
            _responseManager : function(trackdata, routemode, srcmetad) {
                if (!trackdata) return; 

                if (srcmetad) {
                    console.log("Pass TrackData unchanged", trackdata); 

                } else if (routemode) {  // derive structures for mb-based animation of 'suitable' tracks
                    var minlength = this.srcemetax.minlength;
                    var trackSet = this.createRouteSet(trackdata, minlength); // .features);
                    if (trackSet.length) {  // console.log("RAW route-data (gpx)",  trackSet);
                        trackdata = trackSet;
                    } else {
                        trackdata = null;
                    }   

                } else {  // derive features for mb-visualization of rawTracks
                    // console.log("prepare quickmap of ", rawTracks);  
                    var trackLogs = this.createTrackSet(trackdata);
                    if (trackLogs) {  // console.log("RAW track-data (gpx)", trackLogs);
                        trackdata = trackLogs;
                    } else {
                        trackdata = null;
                    }    
                }  

                if (!trackdata) return;  // console.log("CHECKOUT TrackData:", trackdata); 
                this.trackdata = trackdata;
                // this._trackdata = null;
            },

            // Combine rawdata and metadata into contentObj 
            // (with mb-preview-properties) 
            createTrackSet: function(rawdata) {
                // Create geojson-object for quickview of raw trackdata 
                // with "short as possible" id-entification of features 
                function trackLogCreate(srcdata, title) {
                    
                    var logId = srcdata.time;

                    if(!logId) title;
                    if(!logId) logId = srcdata.id;
                    if(!logId) logId = srcdata.name;
                    
                    var trackLog = {};
                    trackLog[logId] = {
                        "layer": {
                            "type": "line",
                            "id": logId,
                            "source": logId
                        },
                        "srcdata": srcdata,
                        "raw": 1
                    };

                    return trackLog; 
                };

                var title; //  = this.srcmetax.key;
                if (!title) title = this.srcmetax.title;
                
                var trackLogObject = trackLogCreate(rawdata, title); 
                
                return trackLogObject;

            },

            // Derive contentObj usable by animatation-api 
            // !! id of features = "first coord-time"
            createRouteSet: function(rawdata, minTrackLength) {
                if (!minTrackLength) minTrackLength = 5; 
                var scope = this,
                    trackSet = [],
                    trackpoints, tracktimes,
                    track, tt, coordinates,
                    type, id, title;

                // 
                function extractPnts(coords, tt) {
                    // tracktimes = r.properties.coordTimes;
                    var tp, trackpoints = [];
                    if (!coords || !coords.length) return trackpoints;
                    var dott, utc;
                    coords.forEach(function(cc, j) {
                        dott = scope.trackTime(tt[j]);
                        utc = scope.utcTime(dott);
                        tp = {};
                        tp.coords = [cc[0], cc[1]]; // !!! mapbox
                        tp.z = cc[2];
                        tp.ab = dott;
                        tp.an = tp.ab;
                        tp.utc = utc;
                        trackpoints.push(tp);
                    });

                    return trackpoints;
                }
                // 
                if (rawdata.features) rawdata = rawdata.features;

                rawdata.forEach(function(r, i) {

                    coordinates = r.geometry.coordinates;

                    tracktimes = r.properties.coordTimes;

                    type = r.geometry.type;

                    if (type == "MultiLineString") {

                        coordinates.forEach(function(coords, j) {

                            if (coords.length > minTrackLength) {

                                tt = tracktimes[j];

                                id = tt[0];
                                //*********

                                trackpoints = extractPnts(coords, tt);
                                // console.log(id, coords, trackpoints);

                                track = {
                                    "id": id,
                                    "title": id,
                                    "unitsystem": "metric",
                                    "trackmode": true,
                                    "nodes": trackpoints
                                };

                                trackSet.push(track);
                            }
                        })

                    } else { // other like LineString

                        id = r.properties.time;
                        // ********************
                        id = id.replace(/-/g, "_");
                        
                        title = r.properties.name;
                        if (!title) title = r.properties.id;
                        if (!title) title = id;

                        if (coordinates.length > minTrackLength) {

                            trackpoints = extractPnts(coordinates, tracktimes);

                            route = {
                                "id": id,
                                "title": title,
                                "unitsystem": "metric",
                                "trackmode": true,
                                "nodes": trackpoints
                            };

                            trackSet.push(route);
                        }
                    }

                })

                return trackSet;
            }

        });
    </script>

</dom-module>